{
  "version": 3,
  "sources": ["../../@apollo/src/incremental/handlers/notImplemented.ts", "../../@apollo/src/utilities/graphql/DocumentTransform.ts", "../../@apollo/src/utilities/graphql/print.ts", "../../@apollo/src/utilities/graphql/storeUtils.ts", "../../@apollo/src/utilities/graphql/transform.ts", "../../@apollo/src/utilities/graphql/operations.ts", "../../@apollo/src/utilities/isNetworkRequestSettled.ts", "../../@apollo/src/utilities/isNetworkRequestInFlight.ts", "../../@apollo/src/cache/core/cache.ts", "../../@apollo/src/cache/core/types/common.ts", "../../@apollo/src/cache/inmemory/helpers.ts", "../../@apollo/src/cache/inmemory/entityStore.ts", "../../@apollo/src/masking/utils.ts", "../../@apollo/src/masking/maskDefinition.ts", "../../@apollo/src/masking/maskFragment.ts", "../../@apollo/src/masking/maskOperation.ts", "../../@apollo/src/cache/inmemory/key-extractor.ts", "../../@apollo/src/cache/inmemory/reactiveVars.ts", "../../@apollo/src/cache/inmemory/policies.ts", "../../@apollo/src/cache/inmemory/readFromStore.ts", "../../@apollo/src/cache/inmemory/writeToStore.ts", "../../@apollo/src/cache/inmemory/inMemoryCache.ts", "../../@apollo/src/core/networkStatus.ts", "../../@apollo/src/core/ObservableQuery.ts", "../../@apollo/src/core/QueryInfo.ts", "../../@apollo/src/core/QueryManager.ts", "../../@apollo/src/core/ApolloClient.ts", "../../@apollo/src/link/http/parseAndCheckHttpResponse.ts", "../../@apollo/src/link/http/selectHttpOptionsAndBody.ts", "../../@apollo/src/link/http/checkFetcher.ts", "../../@apollo/src/link/http/createSignalIfSupported.ts", "../../@apollo/src/link/http/selectURI.ts", "../../@apollo/src/link/http/rewriteURIForGET.ts", "../../@apollo/src/link/http/BaseHttpLink.ts", "../../@apollo/src/link/client-awareness/ClientAwarenessLink.ts", "../../@apollo/src/link/http/HttpLink.ts", "../../graphql-tag/src/index.ts"],
  "sourcesContent": ["import type { ApolloLink } from \"@apollo/client/link\";\nimport type { HKT } from \"@apollo/client/utilities\";\nimport { hasDirectives } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport type { Incremental } from \"../types.js\";\n\nexport declare namespace NotImplementedHandler {\n  interface NotImplementedResult extends HKT {\n    arg1: unknown; // TData\n    arg2: unknown; // TExtensions\n    return: never;\n  }\n  export interface TypeOverrides {\n    AdditionalApolloLinkResultTypes: NotImplementedResult;\n  }\n}\n\nexport class NotImplementedHandler implements Incremental.Handler<never> {\n  isIncrementalResult(_: any): _ is never {\n    return false;\n  }\n  prepareRequest(request: ApolloLink.Request) {\n    invariant(\n      !hasDirectives([\"defer\"], request.query),\n      \"`@defer` is not supported without specifying an incremental handler. Please pass a handler as the `incrementalHandler` option to the `ApolloClient` constructor.\"\n    );\n\n    return request;\n  }\n  extractErrors() {}\n  // This code path can never be reached, so we won't implement it.\n  startRequest = undefined as any;\n}\n", "import { WeakCache } from \"@wry/caches\";\nimport { Trie } from \"@wry/trie\";\nimport type { DocumentNode } from \"graphql\";\nimport { wrap } from \"optimism\";\n\nimport { checkDocument } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { cacheSizes } from \"../caching/sizes.js\";\n\nexport type DocumentTransformCacheKey = ReadonlyArray<unknown>;\n\ntype TransformFn = (document: DocumentNode) => DocumentNode;\n\ninterface DocumentTransformOptions {\n  /**\n   * Determines whether to cache the transformed GraphQL document. Caching can\n   * speed up repeated calls to the document transform for the same input\n   * document. Set to `false` to completely disable caching for the document\n   * transform. When disabled, this option takes precedence over the [`getCacheKey`](#getcachekey)\n   * option.\n   *\n   * @defaultValue `true`\n   */\n  cache?: boolean;\n  /**\n   * Defines a custom cache key for a GraphQL document that will determine whether to re-run the document transform when given the same input GraphQL document. Returns an array that defines the cache key. Return `undefined` to disable caching for that GraphQL document.\n   *\n   * > [!NOTE]\n   * > The items in the array can be any type, but each item needs to be\n   * > referentially stable to guarantee a stable cache key.\n   *\n   * @defaultValue `(document) => [document]`\n   */\n  getCacheKey?: (\n    document: DocumentNode\n  ) => DocumentTransformCacheKey | undefined;\n}\n\nfunction identity(document: DocumentNode) {\n  return document;\n}\n\n/**\n * A class for transforming GraphQL documents. See the [Document transforms\n * documentation](https://www.apollographql.com/docs/react/data/document-transforms) for more details on using them.\n *\n * @example\n *\n * ```ts\n * import { DocumentTransform } from \"@apollo/client/utilities\";\n * import { visit } from \"graphql\";\n *\n * const documentTransform = new DocumentTransform((doc) => {\n *   return visit(doc, {\n *     // ...\n *   });\n * });\n *\n * const transformedDoc = documentTransform.transformDocument(myDocument);\n * ```\n */\nexport class DocumentTransform {\n  private readonly transform: TransformFn;\n  private cached: boolean;\n\n  private readonly resultCache = new WeakSet<DocumentNode>();\n\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  private getCacheKey(\n    document: DocumentNode\n  ): DocumentTransformCacheKey | undefined {\n    return [document];\n  }\n\n  /**\n   * Creates a DocumentTransform that returns the input document unchanged.\n   *\n   * @returns The input document\n   */\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, { cache: false });\n  }\n\n  /**\n   * Creates a DocumentTransform that conditionally applies one of two transforms.\n   *\n   * @param predicate - Function that determines which transform to apply\n   * @param left - Transform to apply when `predicate` returns `true`\n   * @param right - Transform to apply when `predicate` returns `false`. If not provided, it defaults to `DocumentTransform.identity()`.\n   * @returns A DocumentTransform that conditionally applies a document transform based on the predicate\n   *\n   * @example\n   *\n   * ```ts\n   * import { isQueryOperation } from \"@apollo/client/utilities\";\n   *\n   * const conditionalTransform = DocumentTransform.split(\n   *   (document) => isQueryOperation(document),\n   *   queryTransform,\n   *   mutationTransform\n   * );\n   * ```\n   */\n  static split(\n    predicate: (document: DocumentNode) => boolean,\n    left: DocumentTransform,\n    right: DocumentTransform = DocumentTransform.identity()\n  ) {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          const documentTransform = predicate(document) ? left : right;\n\n          return documentTransform.transformDocument(document);\n        },\n        // Reasonably assume both `left` and `right` transforms handle their own caching\n        { cache: false }\n      ),\n      { left, right }\n    );\n  }\n\n  constructor(transform: TransformFn, options: DocumentTransformOptions = {}) {\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n    this.cached = options.cache !== false;\n\n    this.resetCache();\n  }\n\n  /**\n   * Resets the internal cache of this transform, if it is cached.\n   */\n  resetCache() {\n    if (this.cached) {\n      const stableCacheKeys = new Trie<WeakKey>();\n      this.performWork = wrap(\n        DocumentTransform.prototype.performWork.bind(this),\n        {\n          makeCacheKey: (document) => {\n            const cacheKeys = this.getCacheKey(document);\n            if (cacheKeys) {\n              invariant(\n                Array.isArray(cacheKeys),\n                \"`getCacheKey` must return an array or undefined\"\n              );\n              return stableCacheKeys.lookupArray(cacheKeys);\n            }\n          },\n          max: cacheSizes[\"documentTransform.cache\"],\n          cache: WeakCache<any, any>,\n        }\n      );\n    }\n  }\n\n  private performWork(document: DocumentNode) {\n    checkDocument(document);\n    return this.transform(document);\n  }\n\n  /**\n   * Transforms a GraphQL document using the configured transform function.\n   *\n   * @remarks\n   *\n   * Note that `transformDocument` caches the transformed document. Calling\n   * `transformDocument` again with the already-transformed document will\n   * immediately return it.\n   *\n   * @param document - The GraphQL document to transform\n   * @returns The transformed document\n   *\n   * @example\n   *\n   * ```ts\n   * const document = gql`\n   *   # ...\n   * `;\n   *\n   * const documentTransform = new DocumentTransform(transformFn);\n   * const transformedDocument = documentTransform.transformDocument(document);\n   * ```\n   */\n  transformDocument(document: DocumentNode) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    const transformedDocument = this.performWork(document);\n\n    this.resultCache.add(transformedDocument);\n\n    return transformedDocument;\n  }\n\n  /**\n   * Combines this document transform with another document transform. The\n   * returned document transform first applies the current document transform,\n   * then applies the other document transform.\n   *\n   * @param otherTransform - The transform to apply after this one\n   * @returns A new DocumentTransform that applies both transforms in sequence\n   *\n   * @example\n   *\n   * ```ts\n   * const combinedTransform = addTypenameTransform.concat(\n   *   removeDirectivesTransform\n   * );\n   * ```\n   */\n  concat(otherTransform: DocumentTransform): DocumentTransform {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          return otherTransform.transformDocument(\n            this.transformDocument(document)\n          );\n        },\n        // Reasonably assume both transforms handle their own caching\n        { cache: false }\n      ),\n      {\n        left: this,\n        right: otherTransform,\n      }\n    );\n  }\n\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly left?: DocumentTransform;\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly right?: DocumentTransform;\n}\n", "import type { ASTNode } from \"graphql\";\nimport { print as origPrint } from \"graphql\";\n\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport {\n  AutoCleanedWeakCache,\n  registerGlobalCache,\n} from \"@apollo/client/utilities/internal\";\n\nimport { cacheSizes, defaultCacheSizes } from \"../caching/index.js\";\n\nlet printCache!: AutoCleanedWeakCache<ASTNode, string>;\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n *\n * @remarks This is the same function as the GraphQL.js `print` function but\n * with an added cache to avoid recomputation when encountering the same\n * `ASTNode` more than once.\n */\nexport const print = Object.assign(\n  (ast: ASTNode) => {\n    let result = printCache.get(ast);\n\n    if (!result) {\n      result = origPrint(ast);\n      printCache.set(ast, result);\n    }\n    return result;\n  },\n  {\n    reset() {\n      printCache = new AutoCleanedWeakCache<ASTNode, string>(\n        cacheSizes.print || defaultCacheSizes.print\n      );\n    },\n  }\n);\nprint.reset();\n\nif (__DEV__) {\n  registerGlobalCache(\"print\", () => (printCache ? printCache.size : 0));\n}\n", "/**\n * Representation of a reference object inside the cache.\n */\nexport interface Reference {\n  readonly __ref: string;\n}\n\n/**\n * Determines if a given object is a reference object.\n *\n * @param obj - The object to check if its a reference object\n *\n * @example\n *\n * ```ts\n * import { isReference } from \"@apollo/client/utilities\";\n *\n * isReference({ __ref: \"User:1\" }); // true\n * isReference({ __typename: \"User\", id: 1 }); // false\n * ```\n */\nexport function isReference(obj: any): obj is Reference {\n  return Boolean(\n    obj && typeof obj === \"object\" && typeof obj.__ref === \"string\"\n  );\n}\n\n/**\n * Represents the union of valid values that can be stored in the cache.\n */\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | Reference\n  | Reference[]\n  | null\n  | undefined\n  | void\n  | Object;\n\n/**\n * Represents an object that is stored in the cache.\n */\nexport interface StoreObject {\n  __typename?: string;\n  [storeFieldName: string]: StoreValue;\n}\n\n/**\n * Workaround for a TypeScript quirk:\n * types per default have an implicit index signature that makes them\n * assignable to `StoreObject`.\n * interfaces do not have that implicit index signature, so they cannot\n * be assigned to `StoreObject`.\n * This type just maps over a type or interface that is passed in,\n * implicitly adding the index signature.\n * That way, the result can be assigned to `StoreObject`.\n *\n * This is important if some user-defined interface is used e.g.\n * in cache.modify, where the `toReference` method expects a\n * `StoreObject` as input.\n */\nexport type AsStoreObject<T extends { __typename?: string }> = {\n  [K in keyof T]: T[K];\n};\n", "import type { ASTNode, FieldNode, OperationDefinitionNode } from \"graphql\";\nimport { Kind, visit } from \"graphql\";\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: \"__typename\",\n  },\n};\n\n/**\n * Adds `__typename` to all selection sets in the document except for the root\n * selection set.\n *\n * @param doc - The `ASTNode` to add `__typename` to\n *\n * @example\n *\n * ```ts\n * const document = gql`\n *   # ...\n * `;\n *\n * const withTypename = addTypenameToDocument(document);\n * ```\n */\nexport const addTypenameToDocument = Object.assign(\n  function <TNode extends ASTNode>(doc: TNode): TNode {\n    return visit(doc, {\n      SelectionSet: {\n        enter(node, _key, parent) {\n          // Don't add __typename to OperationDefinitions.\n          if (\n            parent &&\n            (parent as OperationDefinitionNode).kind ===\n              Kind.OPERATION_DEFINITION\n          ) {\n            return;\n          }\n\n          // No changes if no selections.\n          const { selections } = node;\n          if (!selections) {\n            return;\n          }\n\n          // If selections already have a __typename, or are part of an\n          // introspection query, do nothing.\n          const skip = selections.some((selection) => {\n            return (\n              selection.kind === Kind.FIELD &&\n              (selection.name.value === \"__typename\" ||\n                selection.name.value.lastIndexOf(\"__\", 0) === 0)\n            );\n          });\n          if (skip) {\n            return;\n          }\n\n          // If this SelectionSet is @export-ed as an input variable, it should\n          // not have a __typename field (see issue #4691).\n          const field = parent as FieldNode;\n          if (\n            field.kind === Kind.FIELD &&\n            field.directives &&\n            field.directives.some((d) => d.name.value === \"export\")\n          ) {\n            return;\n          }\n\n          // Create and return a new SelectionSet with a __typename Field.\n          return {\n            ...node,\n            selections: [...selections, TYPENAME_FIELD],\n          };\n        },\n      },\n    });\n  },\n  {\n    added(field: FieldNode): boolean {\n      return field === TYPENAME_FIELD;\n    },\n  }\n);\n", "import type { DocumentNode } from \"@apollo/client\";\nimport { getOperationDefinition } from \"@apollo/client/utilities/internal\";\n\nfunction isOperation(\n  document: DocumentNode,\n  operation: \"query\" | \"mutation\" | \"subscription\"\n) {\n  return getOperationDefinition(document)?.operation === operation;\n}\n\n/**\n * Determine if a document is a mutation document.\n *\n * @remarks\n * If you are authoring an Apollo link, you might not need this utility.\n * Prefer using the `operationType` property the `operation` object instead.\n *\n * @param document - The GraphQL document to check\n * @returns A boolean indicating if the document is a mutation operation\n *\n * @example\n *\n * ```ts\n * import { isMutationOperation } from \"@apollo/client/utilities\";\n *\n * const mutation = gql`\n *   mutation MyMutation {\n *     # ...\n *   }\n * `;\n *\n * isMutationOperation(mutation); // true\n * ```\n */\nexport function isMutationOperation(document: DocumentNode) {\n  return isOperation(document, \"mutation\");\n}\n\n/**\n * Determine if a document is a query document.\n *\n * @remarks\n * If you are authoring an Apollo link, you might not need this utility.\n * Prefer using the `operationType` property the `operation` object instead.\n *\n * @param document - The GraphQL document to check\n * @returns A boolean indicating if the document is a query operation\n *\n * @example\n *\n * ```ts\n * import { isQueryOperation } from \"@apollo/client/utilities\";\n *\n * const query = gql`\n *   query MyQuery {\n *     # ...\n *   }\n * `;\n *\n * isQueryOperation(query); // true\n * ```\n */\nexport function isQueryOperation(document: DocumentNode) {\n  return isOperation(document, \"query\");\n}\n\n/**\n * Determine if a document is a subscription document.\n *\n * @remarks\n * If you are authoring an Apollo link, you might not need this utility.\n * Prefer using the `operationType` property the `operation` object instead.\n *\n * @param document - The GraphQL document to check\n * @returns A boolean indicating if the document is a subscription operation\n *\n * @example\n *\n * ```ts\n * import { isSubscriptionOperation } from \"@apollo/client/utilities\";\n *\n * const subscription = gql`\n *   subscription MySubscription {\n *     # ...\n *   }\n * `;\n *\n * isSubscriptionOperation(subscription); // true\n * ```\n */\nexport function isSubscriptionOperation(document: DocumentNode) {\n  return isOperation(document, \"subscription\");\n}\n", "import type { NetworkStatus } from \"@apollo/client\";\n\n/**\n * Returns true if the network request is in ready or error state according to a given network\n * status.\n */\nexport function isNetworkRequestSettled(\n  networkStatus?: NetworkStatus\n): boolean {\n  return networkStatus === 7 || networkStatus === 8;\n}\n", "import type { NetworkStatus } from \"@apollo/client\";\n\nimport { isNetworkRequestSettled } from \"./isNetworkRequestSettled.js\";\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus?: NetworkStatus\n): boolean {\n  return !isNetworkRequestSettled(networkStatus);\n}\n", "import { WeakCache } from \"@wry/caches\";\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { Observable } from \"rxjs\";\n\nimport type {\n  GetDataState,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"@apollo/client\";\nimport type { FragmentType, Unmasked } from \"@apollo/client/masking\";\nimport type { Reference, StoreObject } from \"@apollo/client/utilities\";\nimport { cacheSizes } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type { NoInfer } from \"@apollo/client/utilities/internal\";\nimport {\n  equalByQuery,\n  getApolloCacheMemoryInternals,\n  getFragmentDefinition,\n  getFragmentQueryDocument,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { defaultCacheSizes } from \"../../utilities/caching/sizes.js\";\n\nimport type { Cache } from \"./types/Cache.js\";\nimport type { MissingTree } from \"./types/common.js\";\n\nexport type Transaction = (c: ApolloCache) => void;\n\nexport declare namespace ApolloCache {\n  /**\n   * Watched fragment options.\n   */\n  export interface WatchFragmentOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /**\n     * A GraphQL fragment document parsed into an AST with the `gql`\n     * template literal.\n     *\n     * @docGroup 1. Required options\n     */\n    fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\n    /**\n     * An object containing a `__typename` and primary key fields\n     * (such as `id`) identifying the entity object from which the fragment will\n     * be retrieved, or a `{ __ref: \"...\" }` reference, or a `string` ID\n     * (uncommon).\n     *\n     * @docGroup 1. Required options\n     */\n    from: StoreObject | Reference | FragmentType<NoInfer<TData>> | string;\n    /**\n     * Any variables that the GraphQL fragment may depend on.\n     *\n     * @docGroup 2. Cache options\n     */\n    variables?: TVariables;\n    /**\n     * The name of the fragment defined in the fragment document.\n     *\n     * Required if the fragment document includes more than one fragment,\n     * optional otherwise.\n     *\n     * @docGroup 2. Cache options\n     */\n    fragmentName?: string;\n    /**\n     * If `true`, `watchFragment` returns optimistic results.\n     *\n     * The default value is `true`.\n     *\n     * @docGroup 2. Cache options\n     */\n    optimistic?: boolean;\n  }\n\n  /**\n   * Watched fragment results.\n   */\n  export type WatchFragmentResult<TData = unknown> =\n    | ({\n        complete: true;\n        missing?: never;\n      } & GetDataState<TData, \"complete\">)\n    | ({\n        complete: false;\n        missing: MissingTree;\n      } & GetDataState<TData, \"partial\">);\n}\n\nexport abstract class ApolloCache {\n  public readonly assumeImmutableResults: boolean = false;\n\n  // required to implement\n  // core API\n  public abstract read<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(query: Cache.ReadOptions<TData, TVariables>): Unmasked<TData> | null;\n  public abstract write<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(write: Cache.WriteOptions<TData, TVariables>): Reference | undefined;\n\n  /**\n   * Returns data read from the cache for a given query along with information\n   * about the cache result such as whether the result is complete and details\n   * about missing fields.\n   *\n   * Will return `complete` as `true` if it can fulfill the full cache result or\n   * `false` if not. When no data can be fulfilled from the cache, `null` is\n   * returned. When `returnPartialData` is `true`, non-null partial results are\n   * returned if it contains at least one field that can be fulfilled from the\n   * cache.\n   */\n  public abstract diff<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(query: Cache.DiffOptions<TData, TVariables>): Cache.DiffResult<TData>;\n  public abstract watch<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(watch: Cache.WatchOptions<TData, TVariables>): () => void;\n\n  // Empty the cache and restart all current watches (unless\n  // options.discardWatches is true).\n  public abstract reset(options?: Cache.ResetOptions): Promise<void>;\n\n  // Remove whole objects from the cache by passing just options.id, or\n  // specific fields by passing options.field and/or options.args. If no\n  // options.args are provided, all fields matching options.field (even\n  // those with arguments) will be removed. Returns true iff any data was\n  // removed from the cache.\n  public abstract evict(options: Cache.EvictOptions): boolean;\n\n  // initializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(serializedState: unknown): this;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): unknown;\n\n  // Optimistic API\n\n  public abstract removeOptimistic(id: string): void;\n\n  // Used by data masking to determine if an inline fragment with a type\n  // condition matches a given typename. Also used by local resolvers to match a\n  // fragment against a typename.\n  //\n  // If not implemented by a cache subclass, data masking will effectively be\n  // disabled since we will not be able to accurately determine if a given type\n  // condition for a union or interface matches a particular type.\n  public abstract fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string\n  ): boolean;\n\n  // Function used to lookup a fragment when a fragment definition is not part\n  // of the GraphQL document. This is useful for caches, such as InMemoryCache,\n  // that register fragments ahead of time so they can be referenced by name.\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return null;\n  }\n\n  // Transactional API\n\n  // The batch method is intended to replace/subsume both performTransaction\n  // and recordOptimisticTransaction, but performTransaction came first, so we\n  // provide a default batch implementation that's just another way of calling\n  // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n  // override the batch method to do more interesting things with its options.\n  public batch<U>(options: Cache.BatchOptions<this, U>): U {\n    const optimisticId =\n      typeof options.optimistic === \"string\" ? options.optimistic\n      : options.optimistic === false ? null\n      : void 0;\n    let updateResult: U;\n    this.performTransaction(\n      () => (updateResult = options.update(this)),\n      optimisticId\n    );\n    return updateResult!;\n  }\n\n  public abstract performTransaction(\n    transaction: Transaction,\n    // Although subclasses may implement recordOptimisticTransaction\n    // however they choose, the default implementation simply calls\n    // performTransaction with a string as the second argument, allowing\n    // performTransaction to handle both optimistic and non-optimistic\n    // (broadcast-batching) transactions. Passing null for optimisticId is\n    // also allowed, and indicates that performTransaction should apply\n    // the transaction non-optimistically (ignoring optimistic data).\n    optimisticId?: string | null\n  ): void;\n\n  public recordOptimisticTransaction(\n    transaction: Transaction,\n    optimisticId: string\n  ) {\n    this.performTransaction(transaction, optimisticId);\n  }\n\n  // Optional API\n\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  public identify(object: StoreObject | Reference): string | undefined {\n    return;\n  }\n\n  public gc(): string[] {\n    return [];\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    return false;\n  }\n\n  /**\n   * Read data from the cache for the specified query.\n   */\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    query,\n    variables,\n    id,\n    optimistic,\n    returnPartialData,\n  }: Cache.ReadQueryOptions<TData, TVariables>): Unmasked<TData> | null;\n  /**\n   * {@inheritDoc @apollo/client!ApolloCache#readQuery:member(1)}\n   */\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadQueryOptions<TData, TVariables>,\n    /**\n     * @deprecated Pass the `optimistic` argument as part of the first argument\n     * instead of passing it as a separate option.\n     */\n    optimistic: boolean\n  ): Unmasked<TData> | null;\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadQueryOptions<TData, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<TData> | null {\n    return this.read({\n      ...options,\n      rootId: options.id || \"ROOT_QUERY\",\n      optimistic,\n    });\n  }\n\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloCache.WatchFragmentOptions<TData, TVariables>\n  ): Observable<ApolloCache.WatchFragmentResult<Unmasked<TData>>> {\n    const {\n      fragment,\n      fragmentName,\n      from,\n      optimistic = true,\n      ...otherOptions\n    } = options;\n    const query = this.getFragmentDoc(fragment, fragmentName);\n    // While our TypeScript types do not allow for `undefined` as a valid\n    // `from`, its possible `useFragment` gives us an `undefined` since it\n    // calls` cache.identify` and provides that value to `from`. We are\n    // adding this fix here however to ensure those using plain JavaScript\n    // and using `cache.identify` themselves will avoid seeing the obscure\n    // warning.\n    const id =\n      typeof from === \"undefined\" || typeof from === \"string\" ?\n        from\n      : this.identify(from);\n\n    if (__DEV__) {\n      const actualFragmentName =\n        fragmentName || getFragmentDefinition(fragment).name.value;\n\n      if (!id) {\n        invariant.warn(\n          \"Could not identify object passed to `from` for '%s' fragment, either because the object is non-normalized or the key fields are missing. If you are masking this object, please ensure the key fields are requested by the parent object.\",\n          actualFragmentName\n        );\n      }\n    }\n\n    const diffOptions: Cache.DiffOptions<TData, TVariables> = {\n      ...otherOptions,\n      returnPartialData: true,\n      id,\n      query,\n      optimistic,\n    };\n\n    let latestDiff: Cache.DiffResult<TData> | undefined;\n\n    return new Observable((observer) => {\n      return this.watch<TData, TVariables>({\n        ...diffOptions,\n        immediate: true,\n        callback: (diff) => {\n          let data = diff.result;\n\n          // TODO: Remove this once `watchFragment` supports `null` as valid\n          // value emitted\n          if (data === null) {\n            data = {} as any;\n          }\n\n          if (\n            // Always ensure we deliver the first result\n            latestDiff &&\n            equalByQuery(\n              query,\n              { data: latestDiff.result },\n              { data },\n              options.variables\n            )\n          ) {\n            return;\n          }\n\n          const result = {\n            data,\n            dataState: diff.complete ? \"complete\" : \"partial\",\n            complete: !!diff.complete,\n          } as ApolloCache.WatchFragmentResult<Unmasked<TData>>;\n\n          if (diff.missing) {\n            result.missing = diff.missing.missing;\n          }\n\n          latestDiff = { ...diff, result: data } as Cache.DiffResult<TData>;\n          observer.next(result);\n        },\n      });\n    });\n  }\n\n  // Make sure we compute the same (===) fragment query document every\n  // time we receive the same fragment in readFragment.\n  private getFragmentDoc = wrap(getFragmentQueryDocument, {\n    max:\n      cacheSizes[\"cache.fragmentQueryDocuments\"] ||\n      defaultCacheSizes[\"cache.fragmentQueryDocuments\"],\n    cache: WeakCache,\n  });\n\n  /**\n   * Read data from the cache for the specified fragment.\n   */\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    fragment,\n    variables,\n    fragmentName,\n    id,\n    optimistic,\n    returnPartialData,\n  }: Cache.ReadFragmentOptions<TData, TVariables>): Unmasked<TData> | null;\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadFragmentOptions<TData, TVariables>,\n    /**\n     * @deprecated Pass the `optimistic` argument as part of the first argument\n     * instead of passing it as a separate option.\n     */\n    optimistic: boolean\n  ): Unmasked<TData> | null;\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadFragmentOptions<TData, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<TData> | null {\n    return this.read({\n      ...options,\n      query: this.getFragmentDoc(options.fragment, options.fragmentName),\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  /**\n   * Writes data to the root of the cache using the specified query to validate that\n   * the shape of the data you’re writing to the cache is the same as the shape of\n   * the data required by the query. Great for prepping the cache with initial data.\n   */\n  public writeQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    data,\n    query,\n    variables,\n    overwrite,\n    id,\n    broadcast,\n  }: Cache.WriteQueryOptions<TData, TVariables>): Reference | undefined;\n  public writeQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    id,\n    data,\n    ...options\n  }: Cache.WriteQueryOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        dataId: id || \"ROOT_QUERY\",\n        result: data,\n      })\n    );\n  }\n\n  /**\n   * Similar to `writeQuery` (writes data to the cache) but uses the specified\n   * fragment to validate that the shape of the data you’re writing to the cache\n   * is the same as the shape of the data required by the fragment.\n   */\n  public writeFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    data,\n    fragment,\n    fragmentName,\n    variables,\n    overwrite,\n    id,\n    broadcast,\n  }: Cache.WriteFragmentOptions<TData, TVariables>): Reference | undefined;\n  public writeFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    id,\n    data,\n    fragment,\n    fragmentName,\n    ...options\n  }: Cache.WriteFragmentOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        query: this.getFragmentDoc(fragment, fragmentName),\n        dataId: id,\n        result: data,\n      })\n    );\n  }\n\n  public updateQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.UpdateQueryOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    return this.batch({\n      update(cache) {\n        const value = cache.readQuery<TData, TVariables>(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  public updateFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.UpdateFragmentOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    return this.batch({\n      update(cache) {\n        const value = cache.readFragment<TData, TVariables>(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public declare getMemoryInternals?: typeof getApolloCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}\n", "import type { DocumentNode, FieldNode } from \"graphql\";\n\nimport type {\n  AsStoreObject,\n  DeepPartial,\n  isReference,\n  Reference,\n  StoreObject,\n  StoreValue,\n} from \"@apollo/client/utilities\";\n\nimport type { StorageType } from \"../../inmemory/policies.js\";\n\n// The Readonly<T> type only really works for object types, since it marks\n// all of the object's properties as readonly, but there are many cases when\n// a generic type parameter like TExisting might be a string or some other\n// primitive type, in which case we need to avoid wrapping it with Readonly.\n// SafeReadonly<string> collapses to just string, which makes string\n// assignable to SafeReadonly<any>, whereas string is not assignable to\n// Readonly<any>, somewhat surprisingly.\nexport type SafeReadonly<T> = T extends object ? Readonly<T> : T;\n\nexport type MissingTree =\n  | string\n  | {\n      readonly [key: string]: MissingTree;\n    };\n\nexport class MissingFieldError extends Error {\n  constructor(\n    public readonly message: string,\n    public readonly path: MissingTree | Array<string | number>,\n    public readonly query: DocumentNode,\n    public readonly variables?: Record<string, any>\n  ) {\n    // 'Error' breaks prototype chain here\n    super(message);\n    this.name = \"MissingFieldError\";\n\n    if (Array.isArray(this.path)) {\n      this.missing = this.message;\n      for (let i = this.path.length - 1; i >= 0; --i) {\n        this.missing = { [this.path[i]]: this.missing };\n      }\n    } else {\n      this.missing = this.path;\n    }\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully supported\n    // on Android (see issue #3236).\n    (this as any).__proto__ = MissingFieldError.prototype;\n  }\n\n  public readonly missing: MissingTree;\n}\n\nexport interface FieldSpecifier {\n  typename?: string;\n  fieldName: string;\n  field?: FieldNode;\n  args?: Record<string, any>;\n  variables?: Record<string, any>;\n}\n\nexport interface ReadFieldOptions extends FieldSpecifier {\n  from?: StoreObject | Reference;\n}\n\nexport interface ReadFieldFunction {\n  <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;\n  <V = StoreValue>(\n    fieldName: string,\n    from?: StoreObject | Reference\n  ): SafeReadonly<V> | undefined;\n}\n\nexport type ToReferenceFunction = (\n  objOrIdOrRef: StoreObject | string | Reference,\n  mergeIntoStore?: boolean\n) => Reference | undefined;\n\nexport type CanReadFunction = (value: StoreValue) => boolean;\n\ndeclare const _deleteModifier: unique symbol;\nexport interface DeleteModifier {\n  [_deleteModifier]: true;\n}\ndeclare const _invalidateModifier: unique symbol;\nexport interface InvalidateModifier {\n  [_invalidateModifier]: true;\n}\ndeclare const _ignoreModifier: unique symbol;\nexport interface IgnoreModifier {\n  [_ignoreModifier]: true;\n}\n\nexport type ModifierDetails = {\n  DELETE: DeleteModifier;\n  INVALIDATE: InvalidateModifier;\n  fieldName: string;\n  storeFieldName: string;\n  readField: ReadFieldFunction;\n  canRead: CanReadFunction;\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n  storage: StorageType;\n};\n\nexport type Modifier<T> = (\n  value: T,\n  details: ModifierDetails\n) => DeepPartial<T> | DeleteModifier | InvalidateModifier | undefined;\n\ntype StoreObjectValueMaybeReference<StoreVal> =\n  StoreVal extends Array<Record<string, any>> ?\n    StoreVal extends Array<infer Item> ?\n      [Item] extends [Record<string, any>] ?\n        ReadonlyArray<AsStoreObject<Item> | Reference>\n      : never\n    : never\n  : StoreVal extends Record<string, any> ? AsStoreObject<StoreVal> | Reference\n  : StoreVal;\n\nexport type AllFieldsModifier<Entity extends Record<string, any>> = Modifier<\n  Entity[keyof Entity] extends infer Value ?\n    StoreObjectValueMaybeReference<Exclude<Value, undefined>>\n  : never\n>;\n\nexport type Modifiers<T extends Record<string, any> = Record<string, unknown>> =\n  Partial<{\n    [FieldName in keyof T]: Modifier<\n      StoreObjectValueMaybeReference<Exclude<T[FieldName], undefined>>\n    >;\n  }>;\n", "import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type {\n  Reference,\n  StoreObject,\n  StoreValue,\n} from \"@apollo/client/utilities\";\nimport { isReference } from \"@apollo/client/utilities\";\nimport type {\n  FragmentMap,\n  FragmentMapFunction,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  compact,\n  createFragmentMap,\n  DeepMerger,\n  getFragmentDefinitions,\n  isArray,\n  isField,\n  isNonNullObject,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { FragmentRegistryAPI } from \"./fragmentRegistry.js\";\nimport type { KeyFieldsContext } from \"./policies.js\";\nimport type { InMemoryCacheConfig, NormalizedCache } from \"./types.js\";\n\nexport const { hasOwnProperty: hasOwn } = Object.prototype;\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n        id != null ? { id }\n        : _id != null ? { _id }\n        : void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (id == null && _id != null) {\n      id = _id;\n    }\n\n    if (id != null) {\n      return `${__typename}:${\n        typeof id === \"number\" || typeof id === \"string\" ?\n          id\n        : JSON.stringify(id)\n      }`;\n    }\n  }\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  resultCaching: true,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference\n): string | undefined {\n  return isReference(objectOrReference) ?\n      (store.get(objectOrReference.__ref, \"__typename\") as string)\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result) ?\n        result.every((item) =>\n          selectionSetMatchesResult(selectionSet, item, variables)\n        )\n      : selectionSet.selections.every((field) => {\n          if (isField(field) && shouldInclude(field, variables)) {\n            const key = resultKeyNameFromField(field);\n            return (\n              hasOwn.call(result, key) &&\n              (!field.selectionSet ||\n                selectionSetMatchesResult(\n                  field.selectionSet,\n                  result[key],\n                  variables\n                ))\n            );\n          }\n          // If the selection has been skipped with @skip(true) or\n          // @include(false), it should not count against the matching. If\n          // the selection is not a field, it must be a fragment (inline or\n          // named). We will determine if selectionSetMatchesResult for that\n          // fragment when we get to it, so for now we return true.\n          return true;\n        });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue\n): value is StoreObject {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n", "import { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\nimport type { OptimisticDependencyFunction } from \"optimism\";\nimport { dep } from \"optimism\";\n\nimport type {\n  Reference,\n  StoreObject,\n  StoreValue,\n} from \"@apollo/client/utilities\";\nimport { isReference } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport {\n  DeepMerger,\n  isNonNullObject,\n  makeReference,\n  maybeDeepFreeze,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type {\n  CanReadFunction,\n  DeleteModifier,\n  InvalidateModifier,\n  Modifier,\n  ModifierDetails,\n  Modifiers,\n  ReadFieldOptions,\n  SafeReadonly,\n  ToReferenceFunction,\n} from \"../core/types/common.js\";\n\nimport { fieldNameFromStoreName, hasOwn } from \"./helpers.js\";\nimport type { Policies, StorageType } from \"./policies.js\";\nimport type { NormalizedCache, NormalizedCacheObject } from \"./types.js\";\n\nconst DELETE = {} as DeleteModifier;\nconst delModifier: Modifier<any> = () => DELETE;\nconst INVALIDATE = {} as InvalidateModifier;\n\nexport abstract class EntityStore implements NormalizedCache {\n  public declare static Root: typeof Root;\n\n  protected data: NormalizedCacheObject = {};\n\n  constructor(\n    public readonly policies: Policies,\n    public readonly group: CacheGroup\n  ) {}\n\n  public abstract addLayer(\n    layerId: string,\n    replay: (layer: EntityStore) => any\n  ): Layer;\n\n  public abstract removeLayer(layerId: string): EntityStore;\n\n  // Although the EntityStore class is abstract, it contains concrete\n  // implementations of the various NormalizedCache interface methods that\n  // are inherited by the Root and Layer subclasses.\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data };\n  }\n\n  public has(dataId: string): boolean {\n    return this.lookup(dataId, true) !== void 0;\n  }\n\n  public get(dataId: string, fieldName: string): StoreValue {\n    this.group.depend(dataId, fieldName);\n    if (hasOwn.call(this.data, dataId)) {\n      const storeObject = this.data[dataId];\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n    if (\n      fieldName === \"__typename\" &&\n      hasOwn.call(this.policies.rootTypenamesById, dataId)\n    ) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  }\n\n  protected lookup(\n    dataId: string,\n    dependOnExistence?: boolean\n  ): StoreObject | undefined {\n    // The has method (above) calls lookup with dependOnExistence = true, so\n    // that it can later be invalidated when we add or remove a StoreObject for\n    // this dataId. Any consumer who cares about the contents of the StoreObject\n    // should not rely on this dependency, since the contents could change\n    // without the object being added or removed.\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n\n    if (this.policies.rootTypenamesById[dataId]) {\n      return {};\n    }\n  }\n\n  public merge(older: string | StoreObject, newer: StoreObject | string): void {\n    let dataId: string | undefined;\n\n    // Convert unexpected references to ID strings.\n    if (isReference(older)) older = older.__ref;\n    if (isReference(newer)) newer = newer.__ref;\n\n    const existing: StoreObject | undefined =\n      typeof older === \"string\" ? this.lookup((dataId = older)) : older;\n\n    const incoming: StoreObject | undefined =\n      typeof newer === \"string\" ? this.lookup((dataId = newer)) : newer;\n\n    // If newer was a string ID, but that ID was not defined in this store,\n    // then there are no fields to be merged, so we're done.\n    if (!incoming) return;\n\n    invariant(typeof dataId === \"string\", \"store.merge expects a string ID\");\n\n    const merged: StoreObject = new DeepMerger(storeObjectReconciler).merge(\n      existing,\n      incoming\n    );\n\n    // Even if merged === existing, existing may have come from a lower\n    // layer, so we always need to set this.data[dataId] on this level.\n    this.data[dataId] = merged;\n\n    if (merged !== existing) {\n      delete this.refs[dataId];\n      if (this.group.caching) {\n        const fieldsToDirty: Record<string, 1> = {};\n\n        // If we added a new StoreObject where there was previously none, dirty\n        // anything that depended on the existence of this dataId, such as the\n        // EntityStore#has method.\n        if (!existing) fieldsToDirty.__exists = 1;\n\n        // Now invalidate dependents who called getFieldValue for any fields\n        // that are changing as a result of this merge.\n        Object.keys(incoming).forEach((storeFieldName) => {\n          if (\n            !existing ||\n            existing[storeFieldName] !== merged[storeFieldName]\n          ) {\n            // Always dirty the full storeFieldName, which may include\n            // serialized arguments following the fieldName prefix.\n            fieldsToDirty[storeFieldName] = 1;\n\n            // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n            // different from storeFieldName and this field does not have\n            // keyArgs configured, because that means the cache can't make\n            // any assumptions about how field values with the same field\n            // name but different arguments might be interrelated, so it\n            // must err on the side of invalidating all field values that\n            // share the same short fieldName, regardless of arguments.\n            const fieldName = fieldNameFromStoreName(storeFieldName);\n            if (\n              fieldName !== storeFieldName &&\n              !this.policies.hasKeyArgs(merged.__typename, fieldName)\n            ) {\n              fieldsToDirty[fieldName] = 1;\n            }\n\n            // If merged[storeFieldName] has become undefined, and this is the\n            // Root layer, actually delete the property from the merged object,\n            // which is guaranteed to have been created fresh in this method.\n            if (merged[storeFieldName] === void 0 && !(this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n\n        if (\n          fieldsToDirty.__typename &&\n          !(existing && existing.__typename) &&\n          // Since we return default root __typename strings\n          // automatically from store.get, we don't need to dirty the\n          // ROOT_QUERY.__typename field if merged.__typename is equal\n          // to the default string (usually \"Query\").\n          this.policies.rootTypenamesById[dataId] === merged.__typename\n        ) {\n          delete fieldsToDirty.__typename;\n        }\n\n        Object.keys(fieldsToDirty).forEach((fieldName) =>\n          this.group.dirty(dataId as string, fieldName)\n        );\n      }\n    }\n  }\n\n  public modify(\n    dataId: string,\n    fields: Modifier<any> | Modifiers<Record<string, any>>,\n    exact: boolean\n  ): boolean {\n    const storeObject = this.lookup(dataId);\n\n    if (storeObject) {\n      const changedFields: Record<string, any> = {};\n      let needToMerge = false;\n      let allDeleted = true;\n\n      const sharedDetails = {\n        DELETE,\n        INVALIDATE,\n        isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: <V = StoreValue>(\n          fieldNameOrOptions: string | ReadFieldOptions,\n          from?: StoreObject | Reference\n        ) =>\n          this.policies.readField<V>(\n            typeof fieldNameOrOptions === \"string\" ?\n              {\n                fieldName: fieldNameOrOptions,\n                from: from || makeReference(dataId),\n              }\n            : fieldNameOrOptions,\n            { store: this }\n          ),\n      } satisfies Partial<ModifierDetails>;\n\n      Object.keys(storeObject).forEach((storeFieldName) => {\n        const fieldName = fieldNameFromStoreName(storeFieldName);\n        let fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        const modify: Modifier<StoreValue> | undefined =\n          typeof fields === \"function\" ? fields : (\n            fields[storeFieldName] || (exact ? undefined : fields[fieldName])\n          );\n        if (modify) {\n          let newValue =\n            modify === delModifier ? DELETE : (\n              modify(maybeDeepFreeze(fieldValue), {\n                ...sharedDetails,\n                fieldName,\n                storeFieldName,\n                storage: this.getStorage(dataId, storeFieldName),\n              })\n            );\n          if (newValue === INVALIDATE) {\n            this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n            if (newValue !== fieldValue) {\n              changedFields[storeFieldName] = newValue;\n              needToMerge = true;\n              fieldValue = newValue as StoreValue;\n\n              if (__DEV__) {\n                const checkReference = (ref: Reference) => {\n                  if (this.lookup(ref.__ref) === undefined) {\n                    invariant.warn(\n                      \"cache.modify: You are trying to write a Reference that is not part of the store: %o\\n\" +\n                        \"Please make sure to set the `mergeIntoStore` parameter to `true` when creating a Reference that is not part of the store yet:\\n\" +\n                        \"`toReference(object, true)`\",\n                      ref\n                    );\n                    return true;\n                  }\n                };\n                if (isReference(newValue)) {\n                  checkReference(newValue);\n                } else if (Array.isArray(newValue)) {\n                  // Warn about writing \"mixed\" arrays of Reference and non-Reference objects\n                  let seenReference: boolean = false;\n                  let someNonReference: unknown;\n                  for (const value of newValue) {\n                    if (isReference(value)) {\n                      seenReference = true;\n                      if (checkReference(value)) break;\n                    } else {\n                      // Do not warn on primitive values, since those could never be represented\n                      // by a reference. This is a valid (albeit uncommon) use case.\n                      if (typeof value === \"object\" && !!value) {\n                        const [id] = this.policies.identify(value);\n                        // check if object could even be referenced, otherwise we are not interested in it for this warning\n                        if (id) {\n                          someNonReference = value;\n                        }\n                      }\n                    }\n                    if (seenReference && someNonReference !== undefined) {\n                      invariant.warn(\n                        \"cache.modify: Writing an array with a mix of both References and Objects will not result in the Objects being normalized correctly.\\n\" +\n                          \"Please convert the object instance %o to a Reference before writing it to the cache by calling `toReference(object, true)`.\",\n                        someNonReference\n                      );\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (fieldValue !== void 0) {\n          allDeleted = false;\n        }\n      });\n\n      if (needToMerge) {\n        this.merge(dataId, changedFields);\n\n        if (allDeleted) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n          this.group.dirty(dataId, \"__exists\");\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // If called with only one argument, removes the entire entity\n  // identified by dataId. If called with a fieldName as well, removes all\n  // fields of that entity whose names match fieldName according to the\n  // fieldNameFromStoreName helper function. If called with a fieldName\n  // and variables, removes all fields of that entity whose names match fieldName\n  // and whose arguments when cached exactly match the variables passed.\n  public delete(\n    dataId: string,\n    fieldName?: string,\n    args?: Record<string, any>\n  ) {\n    const storeObject = this.lookup(dataId);\n    if (storeObject) {\n      const typename = this.getFieldValue<string>(storeObject, \"__typename\");\n      const storeFieldName =\n        fieldName && args ?\n          this.policies.getStoreFieldName({ typename, fieldName, args })\n        : fieldName;\n      return this.modify(\n        dataId,\n        storeFieldName ?\n          {\n            [storeFieldName]: delModifier,\n          }\n        : delModifier,\n        !!args\n      );\n    }\n    return false;\n  }\n\n  public evict(options: Cache.EvictOptions, limit: EntityStore): boolean {\n    let evicted = false;\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n      if (this instanceof Layer && this !== limit) {\n        evicted = this.parent.evict(options, limit) || evicted;\n      }\n      // Always invalidate the field to trigger rereading of watched\n      // queries, even if no cache data was modified by the eviction,\n      // because queries may depend on computed fields with custom read\n      // functions, whose values are not stored in the EntityStore.\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n    return evicted;\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public extract(): NormalizedCacheObject {\n    const obj = this.toObject();\n    const extraRootIds: string[] = [];\n    this.getRootIdSet().forEach((id) => {\n      if (!hasOwn.call(this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n    if (extraRootIds.length) {\n      obj.__META = { extraRootIds: extraRootIds.sort() };\n    }\n    return obj;\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    Object.keys(this.data).forEach((dataId) => {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        this.delete(dataId);\n      }\n    });\n    if (newData) {\n      const { __META, ...rest } = newData;\n      Object.keys(rest).forEach((dataId) => {\n        this.merge(dataId, rest[dataId] as StoreObject);\n      });\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  }\n\n  public abstract getStorage(\n    idOrObj: string | StoreObject,\n    ...storeFieldNames: (string | number)[]\n  ): StorageType;\n\n  // Maps root entity IDs to the number of times they have been retained, minus\n  // the number of times they have been released. Retained entities keep other\n  // entities they reference (even indirectly) from being garbage collected.\n  private rootIds: {\n    [rootId: string]: number;\n  } = {};\n\n  public retain(rootId: string): number {\n    return (this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1);\n  }\n\n  public release(rootId: string): number {\n    if (this.rootIds[rootId] > 0) {\n      const count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n    return 0;\n  }\n\n  // Return a Set<string> of all the ID strings that have been retained by\n  // this layer/root *and* any layers/roots beneath it.\n  public getRootIdSet(ids = new Set<string>()) {\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n      // always considered roots for garbage collection, regardless of\n      // their retainment counts in this.rootIds.\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n    return ids;\n  }\n\n  // The goal of garbage collection is to remove IDs from the Root layer of the\n  // store that are no longer reachable starting from any IDs that have been\n  // explicitly retained (see retain and release, above). Returns an array of\n  // dataId strings that were removed from the store.\n  public gc() {\n    const ids = this.getRootIdSet();\n    const snapshot = this.toObject();\n    ids.forEach((id) => {\n      if (hasOwn.call(snapshot, id)) {\n        // Because we are iterating over an ECMAScript Set, the IDs we add here\n        // will be visited in later iterations of the forEach loop only if they\n        // were not previously contained by the Set.\n        Object.keys(this.findChildRefIds(id)).forEach(ids.add, ids);\n        // By removing IDs from the snapshot object here, we protect them from\n        // getting removed from the root store layer below.\n        delete snapshot[id];\n      }\n    });\n    const idsToRemove = Object.keys(snapshot);\n    if (idsToRemove.length) {\n      let root: EntityStore = this;\n      while (root instanceof Layer) root = root.parent;\n      idsToRemove.forEach((id) => root.delete(id));\n    }\n    return idsToRemove;\n  }\n\n  // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n  private refs: {\n    [dataId: string]: Record<string, true>;\n  } = {};\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    if (!hasOwn.call(this.refs, dataId)) {\n      const found = (this.refs[dataId] = {} as Record<string, true>);\n      const root = this.data[dataId];\n      if (!root) return found;\n\n      const workSet = new Set<Record<string | number, any>>([root]);\n      // Within the store, only arrays and objects can contain child entity\n      // references, so we can prune the traversal using this predicate:\n      workSet.forEach((obj) => {\n        if (isReference(obj)) {\n          found[obj.__ref] = true;\n          // In rare cases, a { __ref } Reference object may have other fields.\n          // This often indicates a mismerging of References with StoreObjects,\n          // but garbage collection should not be fooled by a stray __ref\n          // property in a StoreObject (ignoring all the other fields just\n          // because the StoreObject looks like a Reference). To avoid this\n          // premature termination of findChildRefIds recursion, we fall through\n          // to the code below, which will handle any other properties of obj.\n        }\n        if (isNonNullObject(obj)) {\n          Object.keys(obj).forEach((key) => {\n            const child = obj[key];\n            // No need to add primitive values to the workSet, since they cannot\n            // contain reference objects.\n            if (isNonNullObject(child)) {\n              workSet.add(child);\n            }\n          });\n        }\n      });\n    }\n    return this.refs[dataId];\n  }\n\n  // Used to compute cache keys specific to this.group.\n  /** overload for `InMemoryCache.maybeBroadcastWatch` */\n  public makeCacheKey(\n    document: DocumentNode,\n    callback: Cache.WatchCallback<any>,\n    details: string\n  ): object;\n  /** overload for `StoreReader.executeSelectionSet` */\n  public makeCacheKey(\n    selectionSet: SelectionSetNode,\n    parent: string /* = ( Reference.__ref ) */ | StoreObject,\n    varString: string | undefined\n  ): object;\n  /** overload for `StoreReader.executeSubSelectedArray` */\n  public makeCacheKey(\n    field: FieldNode,\n    array: readonly any[],\n    varString: string | undefined\n  ): object;\n  /**\n   * @deprecated This is only meant for internal usage,\n   * in your own code please use a `Trie` instance instead.\n   */\n  public makeCacheKey(...args: any[]): object;\n  public makeCacheKey() {\n    return this.group.keyMaker.lookupArray(arguments);\n  }\n\n  // Bound function that can be passed around to provide easy access to fields\n  // of Reference objects as well as ordinary objects.\n  public getFieldValue = <T = StoreValue>(\n    objectOrReference: StoreObject | Reference | undefined,\n    storeFieldName: string\n  ) =>\n    maybeDeepFreeze(\n      isReference(objectOrReference) ?\n        this.get(objectOrReference.__ref, storeFieldName)\n      : objectOrReference && objectOrReference[storeFieldName]\n    ) as SafeReadonly<T>;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  public canRead: CanReadFunction = (objOrRef) => {\n    return isReference(objOrRef) ?\n        this.has(objOrRef.__ref)\n      : typeof objOrRef === \"object\";\n  };\n\n  // Bound function that converts an id or an object with a __typename and\n  // primary key fields to a Reference object. If called with a Reference object,\n  // that same Reference object is returned. Pass true for mergeIntoStore to persist\n  // an object into the store.\n  public toReference: ToReferenceFunction = (objOrIdOrRef, mergeIntoStore) => {\n    if (typeof objOrIdOrRef === \"string\") {\n      return makeReference(objOrIdOrRef);\n    }\n\n    if (isReference(objOrIdOrRef)) {\n      return objOrIdOrRef;\n    }\n\n    const [id] = this.policies.identify(objOrIdOrRef);\n\n    if (id) {\n      const ref = makeReference(id);\n      if (mergeIntoStore) {\n        this.merge(id, objOrIdOrRef);\n      }\n      return ref;\n    }\n  };\n\n  public get supportsResultCaching(): boolean {\n    return this.group.caching;\n  }\n}\n\nexport type FieldValueGetter = EntityStore[\"getFieldValue\"];\n\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nclass CacheGroup {\n  private d: OptimisticDependencyFunction<string> | null = null;\n\n  // Used by the EntityStore#makeCacheKey method to compute cache keys\n  // specific to this CacheGroup.\n  public keyMaker!: Trie<object>;\n\n  constructor(\n    public readonly caching: boolean,\n    private parent: CacheGroup | null = null\n  ) {\n    this.resetCaching();\n  }\n\n  public resetCaching() {\n    this.d = this.caching ? dep<string>() : null;\n    this.keyMaker = new Trie();\n  }\n\n  public depend(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      const fieldName = fieldNameFromStoreName(storeFieldName);\n      if (fieldName !== storeFieldName) {\n        // Fields with arguments that contribute extra identifying\n        // information to the fieldName (thus forming the storeFieldName)\n        // depend not only on the full storeFieldName but also on the\n        // short fieldName, so the field can be invalidated using either\n        // level of specificity.\n        this.d(makeDepKey(dataId, fieldName));\n      }\n      if (this.parent) {\n        this.parent.depend(dataId, storeFieldName);\n      }\n    }\n  }\n\n  public dirty(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d.dirty(\n        makeDepKey(dataId, storeFieldName),\n        // When storeFieldName === \"__exists\", that means the entity identified\n        // by dataId has either disappeared from the cache or was newly added,\n        // so the result caching system would do well to \"forget everything it\n        // knows\" about that object. To achieve that kind of invalidation, we\n        // not only dirty the associated result cache entry, but also remove it\n        // completely from the dependency graph. For the optimism implementation\n        // details, see https://github.com/benjamn/optimism/pull/195.\n        storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\"\n      );\n    }\n  }\n}\n\nfunction makeDepKey(dataId: string, storeFieldName: string) {\n  // Since field names cannot have '#' characters in them, this method\n  // of joining the field name and the ID should be unambiguous, and much\n  // cheaper than JSON.stringify([dataId, fieldName]).\n  return storeFieldName + \"#\" + dataId;\n}\n\nexport function maybeDependOnExistenceOfEntity(\n  store: NormalizedCache,\n  entityId: string\n) {\n  if (supportsResultCaching(store)) {\n    // We use this pseudo-field __exists elsewhere in the EntityStore code to\n    // represent changes in the existence of the entity object identified by\n    // entityId. This dependency gets reliably dirtied whenever an object with\n    // this ID is deleted (or newly created) within this group, so any result\n    // cache entries (for example, StoreReader#executeSelectionSet results) that\n    // depend on __exists for this entityId will get dirtied as well, leading to\n    // the eventual recomputation (instead of reuse) of those result objects the\n    // next time someone reads them from the cache.\n    store.group.depend(entityId, \"__exists\");\n  }\n}\n\nclass Root extends EntityStore {\n  constructor({\n    policies,\n    resultCaching = true,\n    seed,\n  }: {\n    policies: Policies;\n    resultCaching?: boolean;\n    seed?: NormalizedCacheObject;\n  }) {\n    super(policies, new CacheGroup(resultCaching));\n    if (seed) this.replace(seed);\n  }\n\n  public readonly stump = new Stump(this);\n\n  public addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer {\n    // Adding an optimistic Layer on top of the Root actually adds the Layer\n    // on top of the Stump, so the Stump always comes between the Root and\n    // any Layer objects that we've added.\n    return this.stump.addLayer(layerId, replay);\n  }\n\n  public removeLayer(): Root {\n    // Never remove the root layer.\n    return this;\n  }\n\n  public readonly storageTrie = new Trie<StorageType>();\n  public getStorage(): StorageType {\n    return this.storageTrie.lookupArray(arguments);\n  }\n}\nEntityStore.Root = Root;\n\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nclass Layer extends EntityStore {\n  constructor(\n    public readonly id: string,\n    public readonly parent: EntityStore,\n    public readonly replay: (layer: EntityStore) => any,\n    public readonly group: CacheGroup\n  ) {\n    super(parent.policies, group);\n    replay(this);\n  }\n\n  public addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer {\n    return new Layer(layerId, this, replay, this.group);\n  }\n\n  public removeLayer(layerId: string): EntityStore {\n    // Remove all instances of the given id, not just the first one.\n    const parent = this.parent.removeLayer(layerId);\n\n    if (layerId === this.id) {\n      if (this.group.caching) {\n        // Dirty every ID we're removing. Technically we might be able to avoid\n        // dirtying fields that have values in higher layers, but we don't have\n        // easy access to higher layers here, and we're about to recreate those\n        // layers anyway (see parent.addLayer below).\n        Object.keys(this.data).forEach((dataId) => {\n          const ownStoreObject = this.data[dataId];\n          const parentStoreObject = parent[\"lookup\"](dataId);\n          if (!parentStoreObject) {\n            // The StoreObject identified by dataId was defined in this layer\n            // but will be undefined in the parent layer, so we can delete the\n            // whole entity using this.delete(dataId). Since we're about to\n            // throw this layer away, the only goal of this deletion is to dirty\n            // the removed fields.\n            this.delete(dataId);\n          } else if (!ownStoreObject) {\n            // This layer had an entry for dataId but it was undefined, which\n            // means the entity was deleted in this layer, and it's about to\n            // become undeleted when we remove this layer, so we need to dirty\n            // all fields that are about to be reexposed.\n            this.group.dirty(dataId, \"__exists\");\n            Object.keys(parentStoreObject).forEach((storeFieldName) => {\n              this.group.dirty(dataId, storeFieldName);\n            });\n          } else if (ownStoreObject !== parentStoreObject) {\n            // If ownStoreObject is not exactly the same as parentStoreObject,\n            // dirty any fields whose values will change as a result of this\n            // removal.\n            Object.keys(ownStoreObject).forEach((storeFieldName) => {\n              if (\n                !equal(\n                  ownStoreObject[storeFieldName],\n                  parentStoreObject[storeFieldName]\n                )\n              ) {\n                this.group.dirty(dataId, storeFieldName);\n              }\n            });\n          }\n        });\n      }\n\n      return parent;\n    }\n\n    // No changes are necessary if the parent chain remains identical.\n    if (parent === this.parent) return this;\n\n    // Recreate this layer on top of the new parent.\n    return parent.addLayer(this.id, this.replay);\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    const fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId) ?\n        {\n          ...fromParent,\n          ...super.findChildRefIds(dataId),\n        }\n      : fromParent;\n  }\n\n  public getStorage(\n    ...args: Parameters<EntityStore[\"getStorage\"]>\n  ): StorageType {\n    let p: EntityStore = this.parent;\n    while ((p as Layer).parent) p = (p as Layer).parent;\n    return p.getStorage(...args);\n  }\n}\n\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nclass Stump extends Layer {\n  constructor(root: Root) {\n    super(\n      \"EntityStore.Stump\",\n      root,\n      () => {},\n      new CacheGroup(root.group.caching, root.group)\n    );\n  }\n\n  public removeLayer() {\n    // Never remove the Stump layer.\n    return this;\n  }\n\n  public merge(older: string | StoreObject, newer: string | StoreObject) {\n    // We never want to write any data into the Stump, so we forward any merge\n    // calls to the Root instead. Another option here would be to throw an\n    // exception, but the toReference(object, true) function can sometimes\n    // trigger Stump writes (which used to be Root writes, before the Stump\n    // concept was introduced).\n    return this.parent.merge(older, newer);\n  }\n}\n\nfunction storeObjectReconciler(\n  existingObject: StoreObject,\n  incomingObject: StoreObject,\n  property: string | number\n): StoreValue {\n  const existingValue = existingObject[property];\n  const incomingValue = incomingObject[property];\n  // Wherever there is a key collision, prefer the incoming value, unless\n  // it is deeply equal to the existing value. It's worth checking deep\n  // equality here (even though blindly returning incoming would be\n  // logically correct) because preserving the referential identity of\n  // existing data can prevent needless rereading and rerendering.\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\n\nexport function supportsResultCaching(store: any): store is EntityStore {\n  // When result caching is disabled, store.depend will be null.\n  return !!(store && store.supportsResultCaching);\n}\n", "import type { FragmentSpreadNode } from \"graphql\";\nimport { Kind } from \"graphql\";\nimport { Slot } from \"optimism\";\n\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\n// Contextual slot that allows us to disable accessor warnings on fields when in\n// migrate mode.\n/** @internal */\nexport const disableWarningsSlot = new Slot<boolean>();\n\nexport function getFragmentMaskMode(\n  fragment: FragmentSpreadNode\n): \"mask\" | \"migrate\" | \"unmask\" {\n  const directive = fragment.directives?.find(\n    ({ name }) => name.value === \"unmask\"\n  );\n\n  if (!directive) {\n    return \"mask\";\n  }\n\n  const modeArg = directive.arguments?.find(\n    ({ name }) => name.value === \"mode\"\n  );\n\n  if (__DEV__) {\n    if (modeArg) {\n      if (modeArg.value.kind === Kind.VARIABLE) {\n        invariant.warn(\"@unmask 'mode' argument does not support variables.\");\n      } else if (modeArg.value.kind !== Kind.STRING) {\n        invariant.warn(\"@unmask 'mode' argument must be of type string.\");\n      } else if (modeArg.value.value !== \"migrate\") {\n        invariant.warn(\n          \"@unmask 'mode' argument does not recognize value '%s'.\",\n          modeArg.value.value\n        );\n      }\n    }\n  }\n\n  if (\n    modeArg &&\n    \"value\" in modeArg.value &&\n    modeArg.value.value === \"migrate\"\n  ) {\n    return \"migrate\";\n  }\n\n  return \"unmask\";\n}\n", "import type { FragmentDefinitionNode, SelectionSetNode } from \"graphql\";\nimport { Kind } from \"graphql\";\n\nimport type { ApolloCache } from \"@apollo/client/cache\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type { FragmentMap } from \"@apollo/client/utilities/internal\";\nimport {\n  maybeDeepFreeze,\n  resultKeyNameFromField,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { disableWarningsSlot, getFragmentMaskMode } from \"./utils.js\";\n\ninterface MaskingContext {\n  operationType: \"query\" | \"mutation\" | \"subscription\" | \"fragment\";\n  operationName: string | undefined;\n  fragmentMap: FragmentMap;\n  cache: ApolloCache;\n  mutableTargets: WeakMap<any, any>;\n  knownChanged: WeakSet<any>;\n}\n\nexport function maskDefinition(\n  data: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext\n) {\n  return disableWarningsSlot.withValue(true, () => {\n    const masked = maskSelectionSet(data, selectionSet, context, false);\n\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\n\nfunction getMutableTarget(\n  data: Record<string, any>,\n  mutableTargets: WeakMap<any, any>\n): typeof data {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n\n  const mutableTarget = Array.isArray(data) ? [] : {};\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\n\nfunction maskSelectionSet(\n  data: any,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext,\n  migration: boolean,\n  path?: string | undefined\n): typeof data {\n  const { knownChanged } = context;\n  const memo = getMutableTarget(data, context.mutableTargets);\n\n  if (Array.isArray(data)) {\n    for (const [index, item] of Array.from(data.entries())) {\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n\n      const masked = maskSelectionSet(\n        item,\n        selectionSet,\n        context,\n        migration,\n        __DEV__ ? `${path || \"\"}[${index}]` : void 0\n      );\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n\n      memo[index] = masked;\n    }\n\n    return knownChanged.has(memo) ? memo : data;\n  }\n\n  for (const selection of selectionSet.selections) {\n    let value: any;\n\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n\n    if (selection.kind === Kind.FIELD) {\n      const keyName = resultKeyNameFromField(selection);\n      const childSelectionSet = selection.selectionSet;\n\n      value = memo[keyName] || data[keyName];\n\n      if (value === void 0) {\n        continue;\n      }\n\n      if (childSelectionSet && value !== null) {\n        const masked = maskSelectionSet(\n          data[keyName],\n          childSelectionSet,\n          context,\n          migration,\n          __DEV__ ? `${path || \"\"}.${keyName}` : void 0\n        );\n\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n\n      if (!__DEV__) {\n        memo[keyName] = value;\n      }\n      if (__DEV__) {\n        if (\n          migration &&\n          keyName !== \"__typename\" &&\n          // either the field is not present in the memo object\n          // or it has a `get` descriptor, not a `value` descriptor\n          // => it is a warning accessor and we can overwrite it\n          // with another accessor\n          !Object.getOwnPropertyDescriptor(memo, keyName)?.value\n        ) {\n          Object.defineProperty(\n            memo,\n            keyName,\n            getAccessorWarningDescriptor(\n              keyName,\n              value,\n              path || \"\",\n              context.operationName,\n              context.operationType\n            )\n          );\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n\n    if (\n      selection.kind === Kind.INLINE_FRAGMENT &&\n      (!selection.typeCondition ||\n        context.cache.fragmentMatches(selection, data.__typename))\n    ) {\n      value = maskSelectionSet(\n        data,\n        selection.selectionSet,\n        context,\n        migration,\n        path\n      );\n    }\n\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = selection.name.value;\n      const fragment: FragmentDefinitionNode | null =\n        context.fragmentMap[fragmentName] ||\n        (context.fragmentMap[fragmentName] =\n          context.cache.lookupFragment(fragmentName)!);\n      invariant(\n        fragment,\n        \"Could not find fragment with name '%s'.\",\n        fragmentName\n      );\n\n      const mode = getFragmentMaskMode(selection);\n\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(\n          data,\n          fragment.selectionSet,\n          context,\n          mode === \"migrate\",\n          path\n        );\n      }\n    }\n\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n\n  return knownChanged.has(memo) ? memo : data;\n}\n\nfunction getAccessorWarningDescriptor(\n  fieldName: string,\n  value: any,\n  path: string,\n  operationName: string | undefined,\n  operationType: string\n): PropertyDescriptor {\n  let getValue = () => {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n\n    invariant.warn(\n      \"Accessing unmasked field on %s at path '%s'. This field will not be available when masking is enabled. Please read the field from the fragment instead.\",\n      operationName ?\n        `${operationType} '${operationName}'`\n      : `anonymous ${operationType}`,\n      `${path}.${fieldName}`.replace(/^\\./, \"\")\n    );\n\n    getValue = () => value;\n\n    return value;\n  };\n\n  return {\n    get() {\n      return getValue();\n    },\n    set(newValue) {\n      getValue = () => newValue;\n    },\n    enumerable: true,\n    configurable: true,\n  };\n}\n", "import { equal } from \"@wry/equality\";\nimport type { FragmentDefinitionNode } from \"graphql\";\nimport { Kind } from \"graphql\";\n\nimport type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"@apollo/client\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { maskDefinition } from \"./maskDefinition.js\";\n\n/** @internal */\nexport function maskFragment<TData = unknown>(\n  data: TData,\n  document: TypedDocumentNode<TData> | DocumentNode,\n  cache: ApolloCache,\n  fragmentName?: string\n): TData {\n  const fragments = document.definitions.filter(\n    (node): node is FragmentDefinitionNode =>\n      node.kind === Kind.FRAGMENT_DEFINITION\n  );\n\n  if (typeof fragmentName === \"undefined\") {\n    invariant(\n      fragments.length === 1,\n      `Found %s fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n      fragments.length\n    );\n    fragmentName = fragments[0].name.value;\n  }\n\n  const fragment = fragments.find(\n    (fragment) => fragment.name.value === fragmentName\n  );\n\n  invariant(\n    !!fragment,\n    `Could not find fragment with name \"%s\".`,\n    fragmentName\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new WeakMap(),\n    knownChanged: new WeakSet(),\n  });\n}\n", "import type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"@apollo/client\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getOperationDefinition,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { maskDefinition } from \"./maskDefinition.js\";\n\n/** @internal */\nexport function maskOperation<TData = unknown>(\n  data: TData,\n  document: DocumentNode | TypedDocumentNode<TData>,\n  cache: ApolloCache\n): TData {\n  const definition = getOperationDefinition(document);\n\n  invariant(\n    definition,\n    \"Expected a parsed GraphQL document with a query, mutation, or subscription.\"\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  return maskDefinition(data, definition.selectionSet, {\n    operationType: definition.operation,\n    operationName: definition.name?.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new WeakMap(),\n    knownChanged: new WeakSet(),\n  });\n}\n", "import {\n  argumentsObjectFromField,\n  DeepMerger,\n  isArray,\n  isNonEmptyArray,\n  isNonNullObject,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { hasOwn } from \"./helpers.js\";\nimport type {\n  KeyArgsFunction,\n  KeyFieldsFunction,\n  KeySpecifier,\n} from \"./policies.js\";\n\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nconst specifierInfoCache: Record<\n  string,\n  {\n    paths?: string[][];\n    keyFieldsFn?: KeyFieldsFunction;\n    keyArgsFn?: KeyArgsFunction;\n  }\n> = {};\n\nfunction lookupSpecifierInfo(spec: KeySpecifier) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  const cacheKey = JSON.stringify(spec);\n  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = {});\n}\n\nexport function keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyFieldsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyFieldsFn ||\n    (info.keyFieldsFn = (object, context) => {\n      const extract: typeof extractKey = (from, key) =>\n        context.readField(key, from);\n\n      const keyObject = (context.keyObject = collectSpecifierPaths(\n        specifier,\n        (schemaKeyPath) => {\n          let extracted = extractKeyPath(\n            context.storeObject,\n            schemaKeyPath,\n            // Using context.readField to extract paths from context.storeObject\n            // allows the extraction to see through Reference objects and respect\n            // custom read functions.\n            extract\n          );\n\n          if (\n            extracted === void 0 &&\n            object !== context.storeObject &&\n            hasOwn.call(object, schemaKeyPath[0])\n          ) {\n            // If context.storeObject fails to provide a value for the requested\n            // path, fall back to the raw result object, if it has a top-level key\n            // matching the first key in the path (schemaKeyPath[0]). This allows\n            // key fields included in the written data to be saved in the cache\n            // even if they are not selected explicitly in context.selectionSet.\n            // Not being mentioned by context.selectionSet is convenient here,\n            // since it means these extra fields cannot be affected by field\n            // aliasing, which is why we can use extractKey instead of\n            // context.readField for this extraction.\n            extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n          }\n\n          invariant(\n            extracted !== void 0,\n            `Missing field '%s' while extracting keyFields from %s`,\n            schemaKeyPath.join(\".\"),\n            object\n          );\n\n          return extracted;\n        }\n      ));\n\n      return `${context.typename}:${JSON.stringify(keyObject)}`;\n    })\n  );\n}\n\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyArgsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyArgsFn ||\n    (info.keyArgsFn = (args, { field, variables, fieldName }) => {\n      const collected = collectSpecifierPaths(specifier, (keyPath) => {\n        const firstKey = keyPath[0];\n        const firstChar = firstKey.charAt(0);\n\n        if (firstChar === \"@\") {\n          if (field && isNonEmptyArray(field.directives)) {\n            const directiveName = firstKey.slice(1);\n            // If the directive appears multiple times, only the first\n            // occurrence's arguments will be used. TODO Allow repetition?\n            // TODO Cache this work somehow, a la aliasMap?\n            const d = field.directives.find(\n              (d) => d.name.value === directiveName\n            );\n            // Fortunately argumentsObjectFromField works for DirectiveNode!\n            const directiveArgs = d && argumentsObjectFromField(d, variables);\n            // For directives without arguments (d defined, but directiveArgs ===\n            // null), the presence or absence of the directive still counts as\n            // part of the field key, so we return null in those cases. If no\n            // directive with this name was found for this field (d undefined and\n            // thus directiveArgs undefined), we return undefined, which causes\n            // this value to be omitted from the key object returned by\n            // collectSpecifierPaths.\n            return (\n              directiveArgs &&\n              extractKeyPath(\n                directiveArgs,\n                // If keyPath.length === 1, this code calls extractKeyPath with an\n                // empty path, which works because it uses directiveArgs as the\n                // extracted value.\n                keyPath.slice(1)\n              )\n            );\n          }\n          // If the key started with @ but there was no corresponding directive,\n          // we want to omit this value from the key object, not fall through to\n          // treating @whatever as a normal argument name.\n          return;\n        }\n\n        if (firstChar === \"$\") {\n          const variableName = firstKey.slice(1);\n          if (variables && hasOwn.call(variables, variableName)) {\n            const varKeyPath = keyPath.slice(0);\n            varKeyPath[0] = variableName;\n            return extractKeyPath(variables, varKeyPath);\n          }\n          // If the key started with $ but there was no corresponding variable, we\n          // want to omit this value from the key object, not fall through to\n          // treating $whatever as a normal argument name.\n          return;\n        }\n\n        if (args) {\n          return extractKeyPath(args, keyPath);\n        }\n      });\n\n      const suffix = JSON.stringify(collected);\n\n      // If no arguments were passed to this field, and it didn't have any other\n      // field key contributions from directives or variables, hide the empty\n      // :{} suffix from the field key. However, a field passed no arguments can\n      // still end up with a non-empty :{...} suffix if its key configuration\n      // refers to directives or variables.\n      if (args || suffix !== \"{}\") {\n        fieldName += \":\" + suffix;\n      }\n\n      return fieldName;\n    })\n  );\n}\n\nexport function collectSpecifierPaths(\n  specifier: KeySpecifier,\n  extractor: (path: string[]) => any\n): Record<string, any> {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  const merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce((collected, path) => {\n    let toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (let i = path.length - 1; i >= 0; --i) {\n        toMerge = { [path[i]]: toMerge };\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, {});\n}\n\nexport function getSpecifierPaths(spec: KeySpecifier): string[][] {\n  const info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    const paths: string[][] = (info.paths = []);\n    const currentPath: string[] = [];\n\n    spec.forEach((s, i) => {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach((p) => paths.push(currentPath.concat(p)));\n        currentPath.length = 0;\n      } else {\n        currentPath.push(s);\n        if (!isArray(spec[i + 1])) {\n          paths.push(currentPath.slice(0));\n          currentPath.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths!;\n}\n\nfunction extractKey<TObj extends Record<string, any>, TKey extends string>(\n  object: TObj,\n  key: TKey\n): TObj[TKey] | undefined {\n  return object[key];\n}\n\nexport function extractKeyPath(\n  object: Record<string, any>,\n  path: string[],\n  extract?: typeof extractKey\n): any {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(\n    path.reduce(function reducer(obj, key): any {\n      return isArray(obj) ?\n          obj.map((child) => reducer(child, key))\n        : obj && extract!(obj, key);\n    }, object)\n  );\n}\n\nfunction normalize<T>(value: T): T {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize) as any;\n    }\n    return collectSpecifierPaths(Object.keys(value).sort(), (path) =>\n      extractKeyPath(value, path)\n    ) as T;\n  }\n  return value;\n}\n", "import type { OptimisticDependencyFunction } from \"optimism\";\nimport { dep, Slot } from \"optimism\";\n\nimport type { ApolloCache } from \"@apollo/client\";\n\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\n\nexport interface ReactiveVar<T> {\n  (newValue?: T): T;\n  onNextChange(listener: ReactiveListener<T>): () => void;\n  attachCache(cache: ApolloCache): this;\n  forgetCache(cache: ApolloCache): boolean;\n}\n\ntype ReactiveListener<T> = (value: T) => any;\n\n// Contextual Slot that acquires its value when custom read functions are\n// called in Policies#readField.\nexport const cacheSlot = new Slot<ApolloCache>();\n\nconst cacheInfoMap = new WeakMap<\n  ApolloCache,\n  {\n    vars: Set<ReactiveVar<any>>;\n    dep: OptimisticDependencyFunction<ReactiveVar<any>>;\n  }\n>();\n\nfunction getCacheInfo(cache: ApolloCache) {\n  let info = cacheInfoMap.get(cache)!;\n  if (!info) {\n    cacheInfoMap.set(\n      cache,\n      (info = {\n        vars: new Set(),\n        dep: dep(),\n      })\n    );\n  }\n  return info;\n}\n\nexport function forgetCache(cache: ApolloCache) {\n  getCacheInfo(cache).vars.forEach((rv) => rv.forgetCache(cache));\n}\n\n// Calling forgetCache(cache) serves to silence broadcasts and allows the\n// cache to be garbage collected. However, the varsByCache WeakMap\n// preserves the set of reactive variables that were previously associated\n// with this cache, which makes it possible to \"recall\" the cache at a\n// later time, by reattaching it to those variables. If the cache has been\n// garbage collected in the meantime, because it is no longer reachable,\n// you won't be able to call recallCache(cache), and the cache will\n// automatically disappear from the varsByCache WeakMap.\nexport function recallCache(cache: ApolloCache) {\n  getCacheInfo(cache).vars.forEach((rv) => rv.attachCache(cache));\n}\n\nexport function makeVar<T>(value: T): ReactiveVar<T> {\n  const caches = new Set<ApolloCache>();\n  const listeners = new Set<ReactiveListener<T>>();\n\n  const rv: ReactiveVar<T> = function (newValue) {\n    if (arguments.length > 0) {\n      if (value !== newValue) {\n        value = newValue!;\n        caches.forEach((cache) => {\n          // Invalidate any fields with custom read functions that\n          // consumed this variable, so query results involving those\n          // fields will be recomputed the next time we read them.\n          getCacheInfo(cache).dep.dirty(rv);\n          // Broadcast changes to any caches that have previously read\n          // from this variable.\n          broadcast(cache);\n        });\n        // Finally, notify any listeners added via rv.onNextChange.\n        const oldListeners = Array.from(listeners);\n        listeners.clear();\n        oldListeners.forEach((listener) => listener(value));\n      }\n    } else {\n      // When reading from the variable, obtain the current cache from\n      // context via cacheSlot. This isn't entirely foolproof, but it's\n      // the same system that powers varDep.\n      const cache = cacheSlot.getValue();\n      if (cache) {\n        attach(cache);\n        getCacheInfo(cache).dep(rv);\n      }\n    }\n\n    return value;\n  };\n\n  rv.onNextChange = (listener) => {\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n    };\n  };\n\n  const attach = (rv.attachCache = (cache) => {\n    caches.add(cache);\n    getCacheInfo(cache).vars.add(rv);\n    return rv;\n  });\n\n  rv.forgetCache = (cache) => caches.delete(cache);\n\n  return rv;\n}\n\ntype Broadcastable = ApolloCache & {\n  // This method is protected in InMemoryCache, which we are ignoring, but\n  // we still want some semblance of type safety when we call it.\n  broadcastWatches?: InMemoryCache[\"broadcastWatches\"];\n};\n\nfunction broadcast(cache: Broadcastable) {\n  if (cache.broadcastWatches) {\n    cache.broadcastWatches();\n  }\n}\n", "import type {\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { OperationVariables } from \"@apollo/client\";\nimport { disableWarningsSlot } from \"@apollo/client/masking\";\nimport type {\n  Reference,\n  StoreObject,\n  StoreValue,\n} from \"@apollo/client/utilities\";\nimport { isReference } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type { FragmentMap } from \"@apollo/client/utilities/internal\";\nimport {\n  argumentsObjectFromField,\n  getStoreKeyName,\n  isArray,\n  isNonNullObject,\n  storeKeyNameFromField,\n  stringifyForDisplay,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  invariant,\n  newInvariantError,\n} from \"@apollo/client/utilities/invariant\";\n\nimport type {\n  CanReadFunction,\n  FieldSpecifier,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  SafeReadonly,\n  ToReferenceFunction,\n} from \"../core/types/common.js\";\n\nimport {\n  defaultDataIdFromObject,\n  fieldNameFromStoreName,\n  hasOwn,\n  selectionSetMatchesResult,\n  storeValueIsStoreObject,\n  TypeOrFieldNameRegExp,\n} from \"./helpers.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport {\n  keyArgsFnFromSpecifier,\n  keyFieldsFnFromSpecifier,\n} from \"./key-extractor.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport type {\n  IdGetter,\n  MergeInfo,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport type { WriteContext } from \"./writeToStore.js\";\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n};\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\nexport type KeySpecifier = ReadonlyArray<string | KeySpecifier>;\n\nexport type KeyFieldsContext = {\n  // The __typename of the incoming object, even if the __typename field was\n  // aliased to another name in the raw result object. May be undefined when\n  // dataIdFromObject is called for objects without __typename fields.\n  typename: string | undefined;\n\n  // The object to be identified, after processing to remove aliases and\n  // normalize identifiable child objects with references.\n  storeObject: StoreObject;\n\n  // Handy tool for reading additional fields from context.storeObject, either\n  // readField(\"fieldName\") to read storeObject[fieldName], or readField(\"name\",\n  // objectOrReference) to read from another object or Reference. If you read a\n  // field with a read function, that function will be invoked.\n  readField: ReadFieldFunction;\n\n  // If you are writing a custom keyFields function, and you plan to use the raw\n  // result object passed as the first argument, you may also need access to the\n  // selection set and available fragments for this object, just in case any\n  // fields have aliases. Since this logic is tricky to get right, and these\n  // context properties are not even always provided (for example, they are\n  // omitted when calling cache.identify(object), where object is assumed to be\n  // a StoreObject), we recommend you use context.storeObject (which has already\n  // been de-aliased) and context.readField (which can read from references as\n  // well as objects) instead of the raw result object in your keyFields\n  // functions, or just rely on the internal implementation of keyFields:[...]\n  // syntax to get these details right for you.\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n\n  // Internal. May be set by the KeyFieldsFunction to report fields that were\n  // involved in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\ntype KeyFieldsResult = Exclude<ReturnType<KeyFieldsFunction>, KeySpecifier>;\n\n// TODO Should TypePolicy be a generic type, with a TObject or TEntity\n// type parameter?\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // Allows defining a merge function (or merge:true/false shorthand) to\n  // be used for merging objects of this type wherever they appear, unless\n  // the parent field also defines a merge function/boolean (that is,\n  // parent field merge functions take precedence over type policy merge\n  // functions). In many cases, defining merge:true for a given type\n  // policy can save you from specifying merge:true for all the field\n  // policies where that type might be encountered.\n  merge?: FieldMergeFunction | boolean;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true;\n  mutationType?: true;\n  subscriptionType?: true;\n\n  fields?: {\n    [fieldName: string]: FieldPolicy<any> | FieldReadFunction<any>;\n  };\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  }\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\nexport type FieldPolicy<\n  // The internal representation used to store the field's data in the\n  // cache. Must be JSON-serializable if you plan to serialize the result\n  // of cache.extract() using JSON.\n  TExisting = any,\n  // The type of the incoming parameter passed to the merge function,\n  // typically matching the GraphQL response format, but with Reference\n  // objects substituted for any identifiable child objects. Often the\n  // same as TExisting, but not necessarily.\n  TIncoming = TExisting,\n  // The type that the read function actually returns, using TExisting\n  // data and options.args as input. Usually the same as TIncoming.\n  TReadResult = TIncoming,\n  // Allows FieldFunctionOptions definition to be overwritten by the\n  // developer\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult, TOptions>;\n  merge?: FieldMergeFunction<TExisting, TIncoming, TOptions> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return (\n    spec.args !== void 0 ? spec.args\n    : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\n    : null\n  );\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVariables extends OperationVariables = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVariables;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects: MergeObjectsFunction;\n}\n\ntype MergeObjectsFunction = <T extends StoreObject | Reference>(\n  existing: T,\n  incoming: T\n) => T;\n\nexport type FieldReadFunction<\n  TExisting = any,\n  TReadResult = TExisting,\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: TOptions\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<\n  TExisting = any,\n  TIncoming = TExisting,\n  // Passing the whole FieldFunctionOptions makes the current definition\n  // independent from its implementation\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: TOptions\n) => SafeReadonly<TExisting>;\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> = (\n  existing,\n  incoming,\n  { mergeObjects }\n) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\ntype InternalFieldPolicy = {\n  typename: string;\n  keyFn?: KeyArgsFunction;\n  read?: FieldReadFunction<any>;\n  merge?: FieldMergeFunction<any>;\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      merge?: FieldMergeFunction<any>;\n      fields: {\n        [fieldName: string]: InternalFieldPolicy;\n      };\n    };\n  } = {};\n\n  private toBeAdded: {\n    [__typename: string]: TypePolicy[];\n  } = {};\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> = {};\n  public readonly rootTypenamesById: Record<string, string> = {};\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(\n    private config: {\n      cache: InMemoryCache;\n      dataIdFromObject?: KeyFieldsFunction;\n      possibleTypes?: PossibleTypesMap;\n      typePolicies?: TypePolicies;\n    }\n  ) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    partialContext?: Partial<KeyFieldsContext>\n  ): [string?, StoreObject?] {\n    const policies = this;\n\n    const typename =\n      (partialContext &&\n        (partialContext.typename || partialContext.storeObject?.__typename)) ||\n      object.__typename;\n\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    // Default context.storeObject to object if not otherwise provided.\n    const storeObject =\n      (partialContext && partialContext.storeObject) || object;\n\n    const context: KeyFieldsContext = {\n      ...partialContext,\n      typename,\n      storeObject,\n      readField:\n        (partialContext && partialContext.readField) ||\n        (((...args) => {\n          const options = normalizeReadFieldOptions(args, storeObject);\n          return policies.readField(options, {\n            store: policies.cache[\"data\"],\n            variables: options.variables,\n          });\n        }) satisfies ReadFieldFunction),\n    };\n\n    let id: KeyFieldsResult;\n\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n\n    disableWarningsSlot.withValue(true, () => {\n      while (keyFn) {\n        const specifierOrId = keyFn({ ...object, ...storeObject }, context);\n        if (isArray(specifierOrId)) {\n          keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n        } else {\n          id = specifierOrId;\n          break;\n        }\n      }\n    });\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach((typename) => {\n      const { queryType, mutationType, subscriptionType, ...incoming } =\n        typePolicies[typename];\n\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n\n  private updateTypePolicy(\n    typename: string,\n    incoming: TypePolicy,\n    existingFieldPolicies: Record<string, InternalFieldPolicy>\n  ) {\n    const existing = this.getTypePolicy(typename);\n    const { keyFields, fields } = incoming;\n\n    function setMerge(\n      existing: { merge?: FieldMergeFunction | boolean },\n      merge?: FieldMergeFunction | boolean\n    ) {\n      existing.merge =\n        typeof merge === \"function\" ? merge\n          // Pass merge:true as a shorthand for a merge implementation\n          // that returns options.mergeObjects(existing, incoming).\n        : merge === true ? mergeTrueFn\n          // Pass merge:false to make incoming always replace existing\n          // without any warnings about data clobbering.\n        : merge === false ? mergeFalseFn\n        : existing.merge;\n    }\n\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n\n    existing.keyFn =\n      // Pass false to disable normalization for this typename.\n      keyFields === false ? nullKeyFieldsFn\n        // Pass an array of strings to use those fields to compute a\n        // composite ID for objects of this typename.\n      : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n        // Pass a function to take full control over identification.\n      : typeof keyFields === \"function\" ? keyFields\n        // Leave existing.keyFn unchanged if above cases fail.\n      : existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach((fieldName) => {\n        let existing = existingFieldPolicies[fieldName] as\n          | InternalFieldPolicy\n          | undefined;\n        // Field policy inheritance is atomic/shallow: you can't inherit a\n        // field policy and then override just its read function, since read\n        // and merge functions often need to cooperate, so changing only one\n        // of them would be a recipe for inconsistency.\n        // So here we avoid merging an inherited field policy with an updated one.\n        if (!existing || existing?.typename !== typename) {\n          existing = existingFieldPolicies[fieldName] = { typename };\n        }\n        const incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const { keyArgs, read, merge } = incoming;\n\n          existing.keyFn =\n            // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false ? simpleKeyArgsFn\n              // Pass an array of strings to use named arguments to\n              // compute a composite identity for the field.\n            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n              // Pass a function to take full control over field identity.\n            : typeof keyArgs === \"function\" ? keyArgs\n              // Leave existing.keyFn unchanged if above cases fail.\n            : existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(\n        !old || old === which,\n        `Cannot change root %s __typename more than once`,\n        which\n      );\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach((supertype) => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach((subtype) => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(typename: string): Policies[\"typePolicies\"][string] {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy: Policies[\"typePolicies\"][string] = (this.typePolicies[\n        typename\n      ] = {} as any);\n      policy.fields = {};\n\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its properties can\n      // still be updated directly using addTypePolicies, but future changes to\n      // inherited supertype policies will not be reflected in this subtype\n      // policy, because this code runs at most once per typename.\n      let supertypes = this.supertypeMap.get(typename);\n      if (!supertypes && this.fuzzySubtypes.size) {\n        // To make the inheritance logic work for unknown typename strings that\n        // may have fuzzy supertypes, we give this typename an empty supertype\n        // set and then populate it with any fuzzy supertypes that match.\n        supertypes = this.getSupertypeSet(typename, true)!;\n        // This only works for typenames that are directly matched by a fuzzy\n        // supertype. What if there is an intermediate chain of supertypes?\n        // While possible, that situation can only be solved effectively by\n        // specifying the intermediate relationships via possibleTypes, manually\n        // and in a non-fuzzy way.\n        this.fuzzySubtypes.forEach((regExp, fuzzy) => {\n          if (regExp.test(typename)) {\n            // The fuzzy parameter is just the original string version of regExp\n            // (not a valid __typename string), but we can look up the\n            // associated supertype(s) in this.supertypeMap.\n            const fuzzySupertypes = this.supertypeMap.get(fuzzy);\n            if (fuzzySupertypes) {\n              fuzzySupertypes.forEach((supertype) =>\n                supertypes!.add(supertype)\n              );\n            }\n          }\n        });\n      }\n      if (supertypes && supertypes.size) {\n        supertypes.forEach((supertype) => {\n          const { fields, ...rest } = this.getTypePolicy(supertype);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach((policy) => {\n        this.updateTypePolicy(\n          typename,\n          policy,\n          this.typePolicies[typename].fields\n        );\n      });\n    }\n\n    return this.typePolicies[typename];\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string\n  ): InternalFieldPolicy | undefined {\n    if (typename) {\n      return this.getTypePolicy(typename).fields[fieldName];\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, (supertypeSet = new Set<string>()));\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (\n          supertypeSet &&\n          supertypeSet.size &&\n          workQueue.indexOf(supertypeSet) < 0\n        ) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(\n                `Inferring subtype %s of supertype %s`,\n                typename,\n                supertype\n              );\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (\n          needToCheckFuzzySubtypes &&\n          // Start checking fuzzy subtypes only after exhausting all\n          // non-fuzzy subtypes (after the final iteration of the loop).\n          i === workQueue.length - 1 &&\n          // We could wait to compare fragment.selectionSet to result\n          // after we verify the supertype, but this check is often less\n          // expensive than that search, and we will have to do the\n          // comparison anyway whenever we find a potential match.\n          selectionSetMatchesResult(fragment.selectionSet, result!, variables)\n        ) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public hasKeyArgs(typename: string | undefined, fieldName: string) {\n    const policy = this.getFieldPolicy(typename, fieldName);\n    return !!(policy && policy.keyFn);\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName);\n    let storeFieldName: Exclude<ReturnType<KeyArgsFunction>, KeySpecifier>;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName =\n        fieldSpec.field ?\n          storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(\n        objectOrReference,\n        \"__typename\"\n      );\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(\n      objectOrReference,\n      storeFieldName\n    );\n    const policy = this.getFieldPolicy(options.typename, fieldName);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference) ?\n            objectOrReference.__ref\n          : objectOrReference,\n          storeFieldName\n        )\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(this.cache, read, [\n        existing,\n        readOptions,\n      ]) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public getReadFunction(\n    typename: string | undefined,\n    fieldName: string\n  ): FieldReadFunction | undefined {\n    const policy = this.getFieldPolicy(typename, fieldName);\n    return policy && policy.read;\n  }\n\n  public getMergeFunction(\n    parentTypename: string | undefined,\n    fieldName: string,\n    childTypename: string | undefined\n  ): FieldMergeFunction | undefined {\n    let policy:\n      | Policies[\"typePolicies\"][string]\n      | Policies[\"typePolicies\"][string][\"fields\"][string]\n      | undefined = this.getFieldPolicy(parentTypename, fieldName);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n\n  public runMergeFunction(\n    existing: StoreValue,\n    incoming: StoreValue,\n    { field, typename, merge }: MergeInfo,\n    context: WriteContext,\n    storage?: StorageType\n  ) {\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(context.store)(\n        existing as StoreObject,\n        incoming as StoreObject\n      );\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(\n      existing,\n      incoming,\n      makeFieldFunctionOptions(\n        this,\n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0,\n        {\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        },\n        context,\n        storage || {}\n      )\n    );\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n    readField<T>(...args: any[]) {\n      return policies.readField<T>(\n        normalizeReadFieldOptions(args, objectOrReference, variables),\n        context\n      );\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store),\n  };\n}\n\nexport function normalizeReadFieldOptions(\n  readFieldArgs: any[],\n  objectOrReference: StoreObject | Reference | undefined,\n  variables?: ReadMergeModifyContext[\"variables\"]\n): ReadFieldOptions {\n  const { 0: fieldNameOrOptions, 1: from, length: argc } = readFieldArgs;\n\n  let options: ReadFieldOptions;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference,\n    };\n  } else {\n    options = { ...fieldNameOrOptions };\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (__DEV__ && options.from === void 0) {\n    invariant.warn(\n      `Undefined 'from' passed to readField with arguments %s`,\n      stringifyForDisplay(Array.from(readFieldArgs))\n    );\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(\n  store: NormalizedCache\n): MergeObjectsFunction {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      const eType = store.getFieldValue(existing, \"__typename\");\n      const iType = store.getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (\n        storeValueIsStoreObject(existing) &&\n        storeValueIsStoreObject(incoming)\n      ) {\n        return { ...existing, ...incoming };\n      }\n    }\n\n    return incoming;\n  };\n}\n", "import type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\nimport { Kind } from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\n\nimport type { Reference, StoreObject } from \"@apollo/client/utilities\";\nimport {\n  addTypenameToDocument,\n  cacheSizes,\n  canonicalStringify,\n  isReference,\n} from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type {\n  FragmentMap,\n  FragmentMapFunction,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  DeepMerger,\n  getDefaultValues,\n  getFragmentFromSelection,\n  getMainDefinition,\n  getQueryDefinition,\n  isArray,\n  isField,\n  isNonNullObject,\n  makeReference,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  invariant,\n  newInvariantError,\n} from \"@apollo/client/utilities/invariant\";\n\nimport { defaultCacheSizes } from \"../../utilities/caching/sizes.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type { MissingTree } from \"../core/types/common.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\n\nimport {\n  maybeDependOnExistenceOfEntity,\n  supportsResultCaching,\n} from \"./entityStore.js\";\nimport {\n  extractFragmentContext,\n  getTypenameFromStoreObject,\n} from \"./helpers.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { Policies } from \"./policies.js\";\nimport type {\n  DiffQueryAgainstStoreOptions,\n  InMemoryCacheConfig,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n}\n\ntype ExecResult<R = any> = {\n  result: R;\n  missing?: MissingTree;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: readonly any[];\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ninterface StoreReaderConfig {\n  cache: InMemoryCache;\n  fragments?: InMemoryCacheConfig[\"fragments\"];\n}\n\n// Arguments type after keyArgs translation.\ntype ExecSelectionSetKeyArgs = [\n  SelectionSetNode,\n  StoreObject | Reference,\n  ReadMergeModifyContext,\n];\n\nfunction execSelectionSetKeyArgs(\n  options: ExecSelectionSetOptions\n): ExecSelectionSetKeyArgs {\n  return [options.selectionSet, options.objectOrReference, options.context];\n}\n\nexport class StoreReader {\n  // cached version of executeSelectionSet\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    ExecSelectionSetKeyArgs\n  >;\n\n  // cached version of executeSubSelectedArray\n  private executeSubSelectedArray: OptimisticWrapperFunction<\n    [ExecSubSelectedArrayOptions],\n    ExecResult<any>,\n    [ExecSubSelectedArrayOptions]\n  >;\n\n  private config: {\n    cache: InMemoryCache;\n    fragments?: InMemoryCacheConfig[\"fragments\"];\n  };\n\n  private knownResults = new WeakMap<Record<string, any>, SelectionSetNode>();\n\n  constructor(config: StoreReaderConfig) {\n    this.config = config;\n\n    // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n    this.executeSelectionSet = wrap(\n      (options) => {\n        const peekArgs = execSelectionSetKeyArgs(options);\n\n        const other = this.executeSelectionSet.peek(...peekArgs);\n\n        if (other) {\n          // If we previously read this result with canonization enabled, we can\n          // return that canonized result as-is.\n          return other;\n        }\n\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n\n        // Finally, if we didn't find any useful previous results, run the real\n        // execSelectionSetImpl method with the given options.\n        return this.execSelectionSetImpl(options);\n      },\n      {\n        max:\n          cacheSizes[\"inMemoryCache.executeSelectionSet\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"],\n        keyArgs: execSelectionSetKeyArgs,\n        // Note that the parameters of makeCacheKey are determined by the\n        // array returned by keyArgs.\n        makeCacheKey(selectionSet, parent, context) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(\n              selectionSet,\n              isReference(parent) ? parent.__ref : parent,\n              context.varString\n            );\n          }\n        },\n      }\n    );\n\n    this.executeSubSelectedArray = wrap(\n      (options: ExecSubSelectedArrayOptions) => {\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n        return this.execSubSelectedArrayImpl(options);\n      },\n      {\n        max:\n          cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"],\n        makeCacheKey({ field, array, context }) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(field, array, context.varString);\n          }\n        },\n      }\n    );\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = \"ROOT_QUERY\",\n    variables,\n    returnPartialData = true,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables!,\n    };\n\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables),\n        ...extractFragmentContext(query, this.config.fragments),\n      },\n    });\n\n    let missing: MissingFieldError | undefined;\n    if (execResult.missing) {\n      missing = new MissingFieldError(\n        firstMissing(execResult.missing)!,\n        execResult.missing,\n        query,\n        variables\n      );\n    }\n\n    const complete = !missing;\n    const { result } = execResult;\n\n    return {\n      result:\n        complete || returnPartialData ?\n          Object.keys(result).length === 0 ?\n            null\n          : result\n        : null,\n      complete,\n      missing,\n    } as Cache.DiffResult<T>;\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext\n  ): boolean {\n    if (\n      supportsResultCaching(context.store) &&\n      this.knownResults.get(result) === selectionSet\n    ) {\n      const latest = this.executeSelectionSet.peek(\n        selectionSet,\n        parent,\n        context\n      );\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    enclosingRef,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (\n      isReference(objectOrReference) &&\n      !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n      !context.store.has(objectOrReference.__ref)\n    ) {\n      return {\n        result: {},\n        missing: `Dangling reference to missing ${objectOrReference.__ref} object`,\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const typename = store.getFieldValue<string>(\n      objectOrReference,\n      \"__typename\"\n    );\n\n    const objectsToMerge: Record<string, any>[] = [];\n    let missing: MissingTree | undefined;\n    const missingMerger = new DeepMerger();\n\n    if (typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one. Note that this field can be overridden by other\n      // merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function handleMissing<T>(result: ExecResult<T>, resultName: string): T {\n      if (result.missing) {\n        missing = missingMerger.merge(missing, {\n          [resultName]: result.missing,\n        });\n      }\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach((selection) => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField(\n          {\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables,\n            from: objectOrReference,\n          },\n          context\n        );\n\n        const resultName = resultKeyNameFromField(selection);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, {\n              [resultName]: `Can't find field '${selection.name.value}' on ${\n                isReference(objectOrReference) ?\n                  objectOrReference.__ref + \" object\"\n                : \"object \" + JSON.stringify(objectOrReference, null, 2)\n              }`,\n            });\n          }\n        } else if (isArray(fieldValue)) {\n          if (fieldValue.length > 0) {\n            fieldValue = handleMissing(\n              this.executeSubSelectedArray({\n                field: selection,\n                array: fieldValue,\n                enclosingRef,\n                context,\n              }),\n              resultName\n            );\n          }\n        } else if (!selection.selectionSet) {\n          // do nothing\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(\n            this.executeSelectionSet({\n              selectionSet: selection.selectionSet,\n              objectOrReference: fieldValue as StoreObject | Reference,\n              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n              context,\n            }),\n            resultName\n          );\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.lookupFragment\n        );\n\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(`No fragment named %s`, selection.name.value);\n        }\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    const result = mergeDeepArray(objectsToMerge);\n    const finalResult: ExecResult = { result, missing };\n    const frozen = maybeDeepFreeze(finalResult);\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  }\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    enclosingRef,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingTree | undefined;\n    let missingMerger = new DeepMerger<MissingTree[]>();\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, { [i]: childResult.missing });\n      }\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(\n          this.executeSubSelectedArray({\n            field,\n            array: item,\n            enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(\n          this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            objectOrReference: item,\n            enclosingRef: isReference(item) ? item : enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n\n    return {\n      result: array,\n      missing,\n    };\n  }\n}\n\nfunction firstMissing(tree: MissingTree): string | undefined {\n  try {\n    JSON.stringify(tree, (_, value) => {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result as string;\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach((value) => {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type %s returned for query field %s`,\n          getTypenameFromStoreObject(store, value),\n          field.name.value\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n", "import { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport type {\n  FieldNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from \"graphql\";\nimport { Kind } from \"graphql\";\n\nimport type { Cache, OperationVariables } from \"@apollo/client\";\nimport type {\n  Reference,\n  StoreObject,\n  StoreValue,\n} from \"@apollo/client/utilities\";\nimport {\n  addTypenameToDocument,\n  canonicalStringify,\n  isReference,\n} from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type {\n  FragmentMap,\n  FragmentMapFunction,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  argumentsObjectFromField,\n  cloneDeep,\n  getDefaultValues,\n  getFragmentFromSelection,\n  getOperationDefinition,\n  isArray,\n  isField,\n  isNonEmptyArray,\n  makeReference,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  invariant,\n  newInvariantError,\n} from \"@apollo/client/utilities/invariant\";\n\nimport type { ReadFieldFunction } from \"../core/types/common.js\";\n\nimport type { EntityStore } from \"./entityStore.js\";\nimport {\n  extractFragmentContext,\n  fieldNameFromStoreName,\n  makeProcessedFieldsMerger,\n  storeValueIsStoreObject,\n} from \"./helpers.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\nimport type { StoreReader } from \"./readFromStore.js\";\nimport type {\n  InMemoryCacheConfig,\n  MergeTree,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\n\nexport interface WriteContext extends ReadMergeModifyContext {\n  readonly written: {\n    [dataId: string]: SelectionSetNode[];\n  };\n  readonly fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n  // General-purpose deep-merge function for use during writes.\n  merge<T>(existing: T, incoming: T): T;\n  // If true, merge functions will be called with undefined existing data.\n  overwrite: boolean;\n  incomingById: Map<\n    string,\n    {\n      storeObject: StoreObject;\n      mergeTree?: MergeTree;\n      fieldNodeSet: Set<FieldNode>;\n    }\n  >;\n  // Directive metadata for @client and @defer. We could use a bitfield for this\n  // information to save some space, and use that bitfield number as the keys in\n  // the context.flavors Map.\n  clientOnly: boolean;\n  deferred: boolean;\n  flavors: Map<string, FlavorableWriteContext>;\n}\n\ntype FlavorableWriteContext = Pick<\n  WriteContext,\n  \"clientOnly\" | \"deferred\" | \"flavors\"\n>;\n\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor<TContext extends FlavorableWriteContext>(\n  context: TContext,\n  clientOnly: TContext[\"clientOnly\"],\n  deferred: TContext[\"deferred\"]\n): TContext {\n  const key = `${clientOnly}${deferred}`;\n  let flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(\n      key,\n      (flavored =\n        context.clientOnly === clientOnly && context.deferred === deferred ?\n          context\n        : {\n            ...context,\n            clientOnly,\n            deferred,\n          })\n    );\n  }\n  return flavored as TContext;\n}\n\ninterface ProcessSelectionSetOptions {\n  dataId?: string;\n  result: Record<string, any>;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n  mergeTree: MergeTree;\n}\n\nexport class StoreWriter {\n  constructor(\n    public readonly cache: InMemoryCache,\n    private reader?: StoreReader,\n    private fragments?: InMemoryCacheConfig[\"fragments\"]\n  ) {}\n\n  public writeToStore<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    store: NormalizedCache,\n    {\n      query,\n      result,\n      dataId,\n      variables,\n      overwrite,\n    }: Cache.WriteOptions<TData, TVariables>\n  ): Reference | undefined {\n    const operationDefinition = getOperationDefinition(query)!;\n    const merger = makeProcessedFieldsMerger();\n\n    variables = {\n      ...getDefaultValues(operationDefinition),\n      ...variables!,\n    };\n\n    const context: WriteContext = {\n      store,\n      written: {},\n      merge<T>(existing: T, incoming: T) {\n        return merger.merge(existing, incoming) as T;\n      },\n      variables: variables as OperationVariables,\n      varString: canonicalStringify(variables),\n      ...extractFragmentContext(query, this.fragments),\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map(),\n    };\n\n    const ref = this.processSelectionSet({\n      result: result || {},\n      dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: { map: new Map() },\n      context,\n    });\n\n    if (!isReference(ref)) {\n      throw newInvariantError(`Could not identify object %s`, result);\n    }\n\n    // So far, the store has not been modified, so now it's time to process\n    // context.incomingById and merge those incoming fields into context.store.\n    context.incomingById.forEach(\n      ({ storeObject, mergeTree, fieldNodeSet }, dataId) => {\n        const entityRef = makeReference(dataId);\n\n        if (mergeTree && mergeTree.map.size) {\n          const applied = this.applyMerges(\n            mergeTree,\n            entityRef,\n            storeObject,\n            context\n          );\n          if (isReference(applied)) {\n            // Assume References returned by applyMerges have already been merged\n            // into the store. See makeMergeObjectsFunction in policies.ts for an\n            // example of how this can happen.\n            return;\n          }\n          // Otherwise, applyMerges returned a StoreObject, whose fields we should\n          // merge into the store (see store.merge statement below).\n          storeObject = applied;\n        }\n\n        if (__DEV__ && !context.overwrite) {\n          const fieldsWithSelectionSets: Record<string, true> = {};\n          fieldNodeSet.forEach((field) => {\n            if (field.selectionSet) {\n              fieldsWithSelectionSets[field.name.value] = true;\n            }\n          });\n\n          const hasSelectionSet = (storeFieldName: string) =>\n            fieldsWithSelectionSets[fieldNameFromStoreName(storeFieldName)] ===\n            true;\n\n          const hasMergeFunction = (storeFieldName: string) => {\n            const childTree = mergeTree && mergeTree.map.get(storeFieldName);\n            return Boolean(childTree && childTree.info && childTree.info.merge);\n          };\n\n          Object.keys(storeObject).forEach((storeFieldName) => {\n            // If a merge function was defined for this field, trust that it\n            // did the right thing about (not) clobbering data. If the field\n            // has no selection set, it's a scalar field, so it doesn't need\n            // a merge function (even if it's an object, like JSON data).\n            if (\n              hasSelectionSet(storeFieldName) &&\n              !hasMergeFunction(storeFieldName)\n            ) {\n              warnAboutDataLoss(\n                entityRef,\n                storeObject,\n                storeFieldName,\n                context.store\n              );\n            }\n          });\n        }\n\n        store.merge(dataId, storeObject);\n      }\n    );\n\n    // Any IDs written explicitly to the cache will be retained as\n    // reachable root IDs for garbage collection purposes. Although this\n    // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n    // retainment counts are effectively ignored because cache.gc() always\n    // includes them in its root ID set.\n    store.retain(ref.__ref);\n\n    return ref;\n  }\n\n  private processSelectionSet({\n    dataId,\n    result,\n    selectionSet,\n    context,\n    // This object allows processSelectionSet to report useful information\n    // to its callers without explicitly returning that information.\n    mergeTree,\n  }: ProcessSelectionSetOptions): StoreObject | Reference {\n    const { policies } = this.cache;\n\n    // This variable will be repeatedly updated using context.merge to\n    // accumulate all fields that need to be written into the store.\n    let incoming: StoreObject = {};\n\n    // If typename was not passed in, infer it. Note that typename is\n    // always passed in for tricky-to-infer cases such as \"Query\" for\n    // ROOT_QUERY.\n    const typename: string | undefined =\n      (dataId && policies.rootTypenamesById[dataId]) ||\n      getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n      (dataId && (context.store.get(dataId, \"__typename\") as string));\n\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n\n    // This readField function will be passed as context.readField in the\n    // KeyFieldsContext object created within policies.identify (called below).\n    // In addition to reading from the existing context.store (thanks to the\n    // policies.readField(options, context) line at the very bottom), this\n    // version of readField can read from Reference objects that are currently\n    // pending in context.incomingById, which is important whenever keyFields\n    // need to be extracted from a child object that processSelectionSet has\n    // turned into a Reference.\n    const readField: ReadFieldFunction = (...args) => {\n      const options = normalizeReadFieldOptions(\n        args,\n        incoming,\n        context.variables\n      );\n\n      if (isReference(options.from)) {\n        const info = context.incomingById.get(options.from.__ref);\n        if (info) {\n          const result = policies.readField(\n            {\n              ...options,\n              from: info.storeObject,\n            },\n            context\n          );\n\n          if (result !== void 0) {\n            return result;\n          }\n        }\n      }\n\n      return policies.readField(options, context);\n    };\n\n    const fieldNodeSet = new Set<FieldNode>();\n\n    this.flattenFields(\n      selectionSet,\n      result,\n      // This WriteContext will be the default context value for fields returned\n      // by the flattenFields method, but some fields may be assigned a modified\n      // context, depending on the presence of @client and other directives.\n      context,\n      typename\n    ).forEach((context, field) => {\n      const resultFieldKey = resultKeyNameFromField(field);\n      const value = result[resultFieldKey];\n\n      fieldNodeSet.add(field);\n\n      if (value !== void 0) {\n        const storeFieldName = policies.getStoreFieldName({\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        });\n\n        const childTree = getChildMergeTree(mergeTree, storeFieldName);\n\n        let incomingValue = this.processFieldValue(\n          value,\n          field,\n          // Reset context.clientOnly and context.deferred to their default\n          // values before processing nested selection sets.\n          field.selectionSet ?\n            getContextFlavor(context, false, false)\n          : context,\n          childTree\n        );\n\n        // To determine if this field holds a child object with a merge function\n        // defined in its type policy (see PR #7070), we need to figure out the\n        // child object's __typename.\n        let childTypename: string | undefined;\n\n        // The field's value can be an object that has a __typename only if the\n        // field has a selection set. Otherwise incomingValue is scalar.\n        if (\n          field.selectionSet &&\n          (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))\n        ) {\n          childTypename = readField<string>(\"__typename\", incomingValue);\n        }\n\n        const merge = policies.getMergeFunction(\n          typename,\n          field.name.value,\n          childTypename\n        );\n\n        if (merge) {\n          childTree.info = {\n            // TODO Check compatibility against any existing childTree.field?\n            field,\n            typename,\n            merge,\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n\n        incoming = context.merge(incoming, {\n          [storeFieldName]: incomingValue,\n        });\n      } else if (\n        __DEV__ &&\n        !context.clientOnly &&\n        !context.deferred &&\n        !addTypenameToDocument.added(field) &&\n        // If the field has a read function, it may be a synthetic field or\n        // provide a default value, so its absence from the written data should\n        // not be cause for alarm.\n        !policies.getReadFunction(typename, field.name.value)\n      ) {\n        invariant.error(\n          `Missing field '%s' while writing result %o`,\n          resultKeyNameFromField(field),\n          result\n        );\n      }\n    });\n\n    // Identify the result object, even if dataId was already provided,\n    // since we always need keyObject below.\n    try {\n      const [id, keyObject] = policies.identify(result, {\n        typename,\n        selectionSet,\n        fragmentMap: context.fragmentMap,\n        storeObject: incoming,\n        readField,\n      });\n\n      // If dataId was not provided, fall back to the id just generated by\n      // policies.identify.\n      dataId = dataId || id;\n\n      // Write any key fields that were used during identification, even if\n      // they were not mentioned in the original query.\n      if (keyObject) {\n        // TODO Reverse the order of the arguments?\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      // If dataId was provided, tolerate failure of policies.identify.\n      if (!dataId) throw e;\n    }\n\n    if (\"string\" === typeof dataId) {\n      const dataRef = makeReference(dataId);\n\n      // Avoid processing the same entity object using the same selection\n      // set more than once. We use an array instead of a Set since most\n      // entity IDs will be written using only one selection set, so the\n      // size of this array is likely to be very small, meaning indexOf is\n      // likely to be faster than Set.prototype.has.\n      const sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n\n      // If we're about to write a result object into the store, but we\n      // happen to know that the exact same (===) result object would be\n      // returned if we were to reread the result with the same inputs,\n      // then we can skip the rest of the processSelectionSet work for\n      // this object, and immediately return a Reference to it.\n      if (\n        this.reader &&\n        this.reader.isFresh(result, dataRef, selectionSet, context)\n      ) {\n        return dataRef;\n      }\n\n      const previous = context.incomingById.get(dataId);\n      if (previous) {\n        previous.storeObject = context.merge(previous.storeObject, incoming);\n        previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);\n        fieldNodeSet.forEach((field) => previous.fieldNodeSet.add(field));\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          // Save a reference to mergeTree only if it is not empty, because\n          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n          // reused for entirely different parts of the result tree.\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet,\n        });\n      }\n\n      return dataRef;\n    }\n\n    return incoming;\n  }\n\n  private processFieldValue(\n    value: any,\n    field: FieldNode,\n    context: WriteContext,\n    mergeTree: MergeTree\n  ): StoreValue {\n    if (!field.selectionSet || value === null) {\n      // In development, we need to clone scalar values so that they can be\n      // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n      // it's cheaper to store the scalar values directly in the cache.\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n\n    if (isArray(value)) {\n      return value.map((item, i) => {\n        const value = this.processFieldValue(\n          item,\n          field,\n          context,\n          getChildMergeTree(mergeTree, i)\n        );\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context,\n      mergeTree,\n    });\n  }\n\n  // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n  // some additions for tracking @client and @defer directives.\n  private flattenFields<\n    TContext extends Pick<\n      WriteContext,\n      | \"clientOnly\"\n      | \"deferred\"\n      | \"flavors\"\n      | \"fragmentMap\"\n      | \"lookupFragment\"\n      | \"variables\"\n    >,\n  >(\n    selectionSet: SelectionSetNode,\n    result: Record<string, any>,\n    context: TContext,\n    typename = getTypenameFromResult(result, selectionSet, context.fragmentMap)\n  ): Map<FieldNode, TContext> {\n    const fieldMap = new Map<FieldNode, TContext>();\n    const { policies } = this.cache;\n\n    const limitingTrie = new Trie<{\n      // Tracks whether (selectionSet, clientOnly, deferred) has been flattened\n      // before. The GraphQL specification only uses the fragment name for\n      // skipping previously visited fragments, but the top-level fragment\n      // selection set corresponds 1:1 with the fagment name (and is slightly\n      // easier too work with), and we need to consider clientOnly and deferred\n      // values as well, potentially revisiting selection sets that were\n      // previously visited with different inherited configurations of those\n      // directives.\n      visited?: boolean;\n    }>(false); // No need for WeakMap, since limitingTrie does not escape.\n\n    (function flatten(\n      this: void,\n      selectionSet: SelectionSetNode,\n      inheritedContext: TContext\n    ) {\n      const visitedNode = limitingTrie.lookup(\n        selectionSet,\n        // Because we take inheritedClientOnly and inheritedDeferred into\n        // consideration here (in addition to selectionSet), it's possible for\n        // the same selection set to be flattened more than once, if it appears\n        // in the query with different @client and/or @directive configurations.\n        inheritedContext.clientOnly,\n        inheritedContext.deferred\n      );\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n\n      selectionSet.selections.forEach((selection) => {\n        if (!shouldInclude(selection, context.variables)) return;\n\n        let { clientOnly, deferred } = inheritedContext;\n        if (\n          // Since the presence of @client or @defer on this field can only\n          // cause clientOnly or deferred to become true, we can skip the\n          // forEach loop if both clientOnly and deferred are already true.\n          !(clientOnly && deferred) &&\n          isNonEmptyArray(selection.directives)\n        ) {\n          selection.directives.forEach((dir) => {\n            const name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n            if (name === \"defer\") {\n              const args = argumentsObjectFromField(dir, context.variables);\n              // The @defer directive takes an optional args.if boolean\n              // argument, similar to @include(if: boolean). Note that\n              // @defer(if: false) does not make context.deferred false, but\n              // instead behaves as if there was no @defer directive.\n              if (!args || (args as { if?: boolean }).if !== false) {\n                deferred = true;\n              }\n              // TODO In the future, we may want to record args.label using\n              // context.deferred, if a label is specified.\n            }\n          });\n        }\n\n        if (isField(selection)) {\n          const existing = fieldMap.get(selection);\n          if (existing) {\n            // If this field has been visited along another recursive path\n            // before, the final context should have clientOnly or deferred set\n            // to true only if *all* paths have the directive (hence the &&).\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n\n          fieldMap.set(\n            selection,\n            getContextFlavor(context, clientOnly, deferred)\n          );\n        } else {\n          const fragment = getFragmentFromSelection(\n            selection,\n            context.lookupFragment\n          );\n\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw newInvariantError(\n              `No fragment named %s`,\n              selection.name.value\n            );\n          }\n\n          if (\n            fragment &&\n            policies.fragmentMatches(\n              fragment,\n              typename,\n              result,\n              context.variables\n            )\n          ) {\n            flatten(\n              fragment.selectionSet,\n              getContextFlavor(context, clientOnly, deferred)\n            );\n          }\n        }\n      });\n    })(selectionSet, context);\n\n    return fieldMap;\n  }\n\n  private applyMerges<T extends StoreValue>(\n    mergeTree: MergeTree,\n    existing: StoreValue,\n    incoming: T,\n    context: WriteContext,\n    getStorageArgs?: Parameters<EntityStore[\"getStorage\"]>\n  ): T | Reference {\n    if (mergeTree.map.size && !isReference(incoming)) {\n      const e: StoreObject | Reference | undefined =\n        // Items in the same position in different arrays are not\n        // necessarily related to each other, so when incoming is an array\n        // we process its elements as if there was no existing data.\n        (\n          !isArray(incoming) &&\n          // Likewise, existing must be either a Reference or a StoreObject\n          // in order for its fields to be safe to merge with the fields of\n          // the incoming object.\n          (isReference(existing) || storeValueIsStoreObject(existing))\n        ) ?\n          existing\n        : void 0;\n\n      // This narrowing is implied by mergeTree.map.size > 0 and\n      // !isReference(incoming), though TypeScript understandably cannot\n      // hope to infer this type.\n      const i = incoming as StoreObject | StoreValue[];\n\n      // The options.storage objects provided to read and merge functions\n      // are derived from the identity of the parent object plus a\n      // sequence of storeFieldName strings/numbers identifying the nested\n      // field name path of each field value to be merged.\n      if (e && !getStorageArgs) {\n        getStorageArgs = [isReference(e) ? e.__ref : e];\n      }\n\n      // It's possible that applying merge functions to this subtree will\n      // not change the incoming data, so this variable tracks the fields\n      // that did change, so we can create a new incoming object when (and\n      // only when) at least one incoming field has changed. We use a Map\n      // to preserve the type of numeric keys.\n      let changedFields: Map<string | number, StoreValue> | undefined;\n\n      const getValue = (\n        from: typeof e | typeof i,\n        name: string | number\n      ): StoreValue => {\n        return (\n          isArray(from) ?\n            typeof name === \"number\" ?\n              from[name]\n            : void 0\n          : context.store.getFieldValue(from, String(name))\n        );\n      };\n\n      mergeTree.map.forEach((childTree, storeFieldName) => {\n        const eVal = getValue(e, storeFieldName);\n        const iVal = getValue(i, storeFieldName);\n        // If we have no incoming data, leave any existing data untouched.\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        const aVal = this.applyMerges(\n          childTree,\n          eVal,\n          iVal,\n          context,\n          getStorageArgs\n        );\n        if (aVal !== iVal) {\n          changedFields = changedFields || new Map();\n          changedFields.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n\n      if (changedFields) {\n        // Shallow clone i so we can add changed fields to it.\n        incoming = (isArray(i) ? i.slice(0) : { ...i }) as T;\n        changedFields.forEach((value, name) => {\n          (incoming as any)[name] = value;\n        });\n      }\n    }\n\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(\n        existing,\n        incoming,\n        mergeTree.info,\n        context,\n        getStorageArgs && context.store.getStorage(...getStorageArgs)\n      );\n    }\n\n    return incoming;\n  }\n}\n\nconst emptyMergeTreePool: MergeTree[] = [];\n\nfunction getChildMergeTree(\n  { map }: MergeTree,\n  name: string | number\n): MergeTree {\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || { map: new Map() });\n  }\n  return map.get(name)!;\n}\n\nfunction mergeMergeTrees(\n  left: MergeTree | undefined,\n  right: MergeTree | undefined\n): MergeTree {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left!;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n\n  const info =\n    left.info && right.info ?\n      {\n        ...left.info,\n        ...right.info,\n      }\n    : left.info || right.info;\n\n  const needToMergeMaps = left.map.size && right.map.size;\n  const map =\n    needToMergeMaps ? new Map()\n    : left.map.size ? left.map\n    : right.map;\n\n  const merged = { info, map };\n\n  if (needToMergeMaps) {\n    const remainingRightKeys = new Set(right.map.keys());\n\n    left.map.forEach((leftTree, key) => {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys.delete(key);\n    });\n\n    remainingRightKeys.forEach((key) => {\n      merged.map.set(\n        key,\n        mergeMergeTrees(right.map.get(key), left.map.get(key))\n      );\n    });\n  }\n\n  return merged;\n}\n\nfunction mergeTreeIsEmpty(tree: MergeTree | undefined): boolean {\n  return !tree || !(tree.info || tree.map.size);\n}\n\nfunction maybeRecycleChildMergeTree({ map }: MergeTree, name: string | number) {\n  const childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\n\nconst warnings = new Set<string>();\n\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(\n  existingRef: Reference,\n  incomingObj: StoreObject,\n  storeFieldName: string,\n  store: NormalizedCache\n) {\n  const getChild = (objOrRef: StoreObject | Reference): StoreObject | false => {\n    const child = store.getFieldValue<StoreObject>(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  const existing = getChild(existingRef);\n  if (!existing) return;\n\n  const incoming = getChild(incomingObj);\n  if (!incoming) return;\n\n  // It's always safe to replace a reference, since it refers to data\n  // safely stored elsewhere.\n  if (isReference(existing)) return;\n\n  // If the values are structurally equivalent, we do not need to worry\n  // about incoming replacing existing.\n  if (equal(existing, incoming)) return;\n\n  // If we're replacing every key of the existing object, then the\n  // existing data would be overwritten even if the objects were\n  // normalized, so warning would not be helpful here.\n  if (\n    Object.keys(existing).every(\n      (key) => store.getFieldValue(incoming, key) !== void 0\n    )\n  ) {\n    return;\n  }\n\n  const parentType =\n    store.getFieldValue<string>(existingRef, \"__typename\") ||\n    store.getFieldValue<string>(incomingObj, \"__typename\");\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const typeDotName = `${parentType}.${fieldName}`;\n  // Avoid warning more than once for the same type and field name.\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n\n  const childTypenames: string[] = [];\n  // Arrays do not have __typename fields, and always need a custom merge\n  // function, even if their elements are normalized entities.\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach((child) => {\n      const typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  invariant.warn(\n    `Cache data may be lost when replacing the %s field of a %s object.\n\nThis could cause additional (usually avoidable) network requests to fetch data that were otherwise cached.\n\nTo address this problem (which is not a bug in Apollo Client), %sdefine a custom merge function for the %s field, so InMemoryCache can safely merge these objects:\n\n  existing: %o\n  incoming: %o\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n`,\n    fieldName,\n    parentType,\n    childTypenames.length ?\n      \"either ensure all objects of type \" +\n        childTypenames.join(\" and \") +\n        \" have an ID or a custom merge function, or \"\n    : \"\",\n    typeDotName,\n    { ...existing },\n    { ...incoming }\n  );\n}\n\nfunction getTypenameFromResult(\n  result: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  fragmentMap?: FragmentMap\n): string | undefined {\n  let fragments: undefined | Array<InlineFragmentNode | FragmentSpreadNode>;\n  for (const selection of selectionSet.selections) {\n    if (isField(selection)) {\n      if (selection.name.value === \"__typename\") {\n        return result[resultKeyNameFromField(selection)];\n      }\n    } else if (fragments) {\n      fragments.push(selection);\n    } else {\n      fragments = [selection];\n    }\n  }\n  if (typeof result.__typename === \"string\") {\n    return result.__typename;\n  }\n  if (fragments) {\n    for (const selection of fragments) {\n      const typename = getTypenameFromResult(\n        result,\n        getFragmentFromSelection(selection, fragmentMap)!.selectionSet,\n        fragmentMap\n      );\n      if (typeof typename === \"string\") {\n        return typename;\n      }\n    }\n  }\n}\n", "import { equal } from \"@wry/equality\";\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\n\nimport type { OperationVariables } from \"@apollo/client\";\nimport type {\n  DeepPartial,\n  Reference,\n  StoreObject,\n} from \"@apollo/client/utilities\";\nimport {\n  addTypenameToDocument,\n  cacheSizes,\n  canonicalStringify,\n  DocumentTransform,\n  isReference,\n  print,\n} from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { getInMemoryCacheMemoryInternals } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { defaultCacheSizes } from \"../../utilities/caching/sizes.js\";\nimport { ApolloCache } from \"../core/cache.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\n\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { hasOwn, normalizeConfig } from \"./helpers.js\";\nimport { Policies } from \"./policies.js\";\nimport { forgetCache, makeVar, recallCache } from \"./reactiveVars.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport type { InMemoryCacheConfig, NormalizedCacheObject } from \"./types.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\n\ntype BroadcastOptions = Pick<\n  Cache.BatchOptions<InMemoryCache>,\n  \"optimistic\" | \"onWatchUpdated\"\n>;\n\nexport class InMemoryCache extends ApolloCache {\n  private data!: EntityStore;\n  private optimisticData!: EntityStore;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions<any, any>>();\n\n  private storeReader!: StoreReader;\n  private storeWriter!: StoreWriter;\n  private addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n\n  private maybeBroadcastWatch!: OptimisticWrapperFunction<\n    [Cache.WatchOptions<any, any>, BroadcastOptions?],\n    any,\n    [Cache.WatchOptions<any, any>]\n  >;\n\n  // Override the default value, since InMemoryCache result objects are frozen\n  // in development and expected to remain logically immutable in production.\n  public readonly assumeImmutableResults = true;\n\n  // Dynamically imported code can augment existing typePolicies or\n  // possibleTypes by calling cache.policies.addTypePolicies or\n  // cache.policies.addPossibletypes.\n  public readonly policies: Policies;\n\n  public readonly makeVar = makeVar;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = normalizeConfig(config);\n\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies,\n    });\n\n    this.init();\n  }\n\n  private init() {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    const rootStore = (this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching,\n    }));\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n\n    this.resetResultCache();\n  }\n\n  private resetResultCache() {\n    const { fragments } = this.config;\n\n    this.addTypenameTransform.resetCache();\n    fragments?.resetCaches();\n\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(\n      this,\n      (this.storeReader = new StoreReader({ cache: this, fragments })),\n      fragments\n    );\n\n    this.maybeBroadcastWatch = wrap(\n      (c: Cache.WatchOptions, options?: BroadcastOptions) => {\n        return this.broadcastWatch(c, options);\n      },\n      {\n        max:\n          cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] ||\n          defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"],\n        makeCacheKey: (c: Cache.WatchOptions) => {\n          // Return a cache key (thus enabling result caching) only if we're\n          // currently using a data store that can track cache dependencies.\n          const store = c.optimistic ? this.optimisticData : this.data;\n          if (supportsResultCaching(store)) {\n            const { optimistic, id, variables } = c;\n            return store.makeCacheKey(\n              c.query,\n              // Different watches can have the same query, optimistic\n              // status, rootId, and variables, but if their callbacks are\n              // different, the (identical) result needs to be delivered to\n              // each distinct callback. The easiest way to achieve that\n              // separation is to include c.callback in the cache key for\n              // maybeBroadcastWatch calls. See issue #5733.\n              c.callback,\n              canonicalStringify({ optimistic, id, variables })\n            );\n          }\n        },\n      }\n    );\n\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([this.data.group, this.optimisticData.group]).forEach((group) =>\n      group.resetCaching()\n    );\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n\n  public read<TData = unknown>(\n    options: Cache.ReadOptions<TData, OperationVariables> & {\n      returnPartialData: true;\n    }\n  ): TData | DeepPartial<TData> | null;\n\n  public read<TData = unknown>(\n    options: Cache.ReadOptions<TData, OperationVariables>\n  ): TData | null;\n\n  public read<TData = unknown>(\n    options: Cache.ReadOptions<TData, OperationVariables>\n  ): TData | DeepPartial<TData> | null {\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false,\n    } = options;\n\n    return this.storeReader.diffQueryAgainstStore<TData>({\n      ...options,\n      store: options.optimistic ? this.optimisticData : this.data,\n      config: this.config,\n      returnPartialData,\n    }).result;\n  }\n\n  public write<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: Cache.WriteOptions<TData, TVariables>): Reference | undefined {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store =\n      (\n        options.optimistic // Defaults to false.\n      ) ?\n        this.optimisticData\n      : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields, false);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public diff<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: Cache.DiffOptions<TData, TVariables>): Cache.DiffResult<TData> {\n    return this.storeReader.diffQueryAgainstStore({\n      ...options,\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config,\n    });\n  }\n\n  public watch<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(watch: Cache.WatchOptions<TData, TVariables>): () => void {\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n\n  public gc(options?: {\n    // If true, also free non-essential result cache memory by bulk-releasing\n    // this.{store{Reader,Writer},maybeBroadcastWatch}. Defaults to false.\n    resetResultCache?: boolean;\n  }) {\n    canonicalStringify.reset();\n    print.reset();\n    const ids = this.optimisticData.gc();\n    if (options && !this.txCount && options.resetResultCache) {\n      this.resetResultCache();\n    }\n    return ids;\n  }\n\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  public retain(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  public release(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  public identify(object: StoreObject | Reference): string | undefined {\n    if (isReference(object)) return object.__ref;\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      invariant.warn(e);\n    }\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = { ...options, id: \"ROOT_QUERY\" };\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public reset(options?: Cache.ResetOptions): Promise<void> {\n    this.init();\n\n    canonicalStringify.reset();\n\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach((watch) => this.maybeBroadcastWatch.forget(watch));\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n\n  private txCount = 0;\n\n  public batch<TUpdateResult>(\n    options: Cache.BatchOptions<InMemoryCache, TUpdateResult>\n  ): TUpdateResult {\n    const {\n      update,\n      optimistic = true,\n      removeOptimistic,\n      onWatchUpdated,\n    } = options;\n\n    let updateResult: TUpdateResult;\n    const perform = (layer?: EntityStore): TUpdateResult => {\n      const { data, optimisticData } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        return (updateResult = update(this));\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n\n    const alreadyDirty = new Set<Cache.WatchOptions>();\n\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch) {\n          alreadyDirty.add(watch);\n          return false;\n        },\n      });\n    }\n\n    if (typeof optimistic === \"string\") {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch, diff) {\n          const result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        },\n      });\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach((watch) => this.maybeBroadcastWatch.dirty(watch));\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n\n    return updateResult!;\n  }\n\n  public performTransaction(\n    update: (cache: InMemoryCache) => any,\n    optimisticId?: string | null\n  ) {\n    return this.batch({\n      update,\n      optimistic: optimisticId || optimisticId !== null,\n    });\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return this.addTypenameTransform.transformDocument(\n      this.addFragmentsToDocument(document)\n    );\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string\n  ): boolean {\n    return this.policies.fragmentMatches(fragment, typename);\n  }\n\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return this.config.fragments?.lookup(fragmentName) || null;\n  }\n\n  protected broadcastWatches(options?: BroadcastOptions) {\n    if (!this.txCount) {\n      this.watches.forEach((c) => this.maybeBroadcastWatch(c, options));\n    }\n  }\n\n  private addFragmentsToDocument(document: DocumentNode) {\n    const { fragments } = this.config;\n    return fragments ? fragments.transform(document) : document;\n  }\n\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  private broadcastWatch(c: Cache.WatchOptions, options?: BroadcastOptions) {\n    const { lastDiff } = c;\n\n    // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n    const diff = this.diff<any>(c);\n\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n\n      if (\n        options.onWatchUpdated &&\n        options.onWatchUpdated.call(this, c, diff, lastDiff) === false\n      ) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback((c.lastDiff = diff), lastDiff);\n    }\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public declare getMemoryInternals?: typeof getInMemoryCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}\n", "/**\n * The current status of a query’s execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n\n  /**\n   * Indicates that a `@defer` query has received at least the first chunk of\n   * the result but the full result has not yet been fully streamed to the\n   * client.\n   */\n  streaming = 9,\n}\n", "import { equal } from \"@wry/equality\";\nimport type { DocumentNode } from \"graphql\";\nimport type {\n  InteropObservable,\n  MonoTypeOperatorFunction,\n  Observer,\n  OperatorFunction,\n  Subscribable,\n  Subscription,\n} from \"rxjs\";\nimport { BehaviorSubject, Observable, share, Subject, tap } from \"rxjs\";\n\nimport type { Cache, MissingFieldError } from \"@apollo/client/cache\";\nimport type { MissingTree } from \"@apollo/client/cache\";\nimport type { MaybeMasked, Unmasked } from \"@apollo/client/masking\";\nimport type { DeepPartial } from \"@apollo/client/utilities\";\nimport { isNetworkRequestInFlight } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport {\n  compact,\n  equalByQuery,\n  filterMap,\n  getOperationDefinition,\n  getOperationName,\n  getQueryDefinition,\n  preventUnhandledRejection,\n  toQueryResult,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\nimport type {\n  DataState,\n  DefaultContext,\n  ErrorLike,\n  GetDataState,\n  OperationVariables,\n  QueryNotification,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type {\n  ErrorPolicy,\n  NextFetchPolicyContext,\n  RefetchWritePolicy,\n  SubscribeToMoreUpdateQueryFn,\n  UpdateQueryMapFn,\n  UpdateQueryOptions,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nconst { assign, hasOwnProperty } = Object;\n\ninterface TrackedOperation {\n  /**\n   * This NetworkStatus will be used to override the current networkStatus\n   */\n  override?: NetworkStatus;\n  /**\n   * Will abort tracking the operation from this ObservableQuery and remove it from `activeOperations`\n   */\n  abort: () => void;\n  /**\n   * `query` that was used by the `ObservableQuery` as the \"main query\" at the time the operation was started\n   * This is not necessarily the same query as the query the operation itself is doing.\n   */\n  query: DocumentNode;\n  variables: OperationVariables;\n}\n\nconst uninitialized: ObservableQuery.Result<any> = {\n  loading: true,\n  networkStatus: NetworkStatus.loading,\n  data: undefined,\n  dataState: \"empty\",\n  partial: true,\n};\n\nconst empty: ObservableQuery.Result<any> = {\n  loading: false,\n  networkStatus: NetworkStatus.ready,\n  data: undefined,\n  dataState: \"empty\",\n  partial: true,\n};\n\nconst enum EmitBehavior {\n  /**\n   * Emit will be calculated by the normal rules. (`undefined` will be treated the same as this)\n   */\n  default = 0,\n  /**\n   * This result should always be emitted, even if the result is equal to the\n   * previous result. (e.g. the first value after a `refetch`)\n   */\n  force = 1,\n  /**\n   * Never emit this result, it is only used to update `currentResult`.\n   */\n  never = 2,\n  /**\n   * This is a result carrying only a \"network status change\"/loading state update,\n   * emit according to the `notifyOnNetworkStatusChange` option.\n   */\n  networkStatusChange = 3,\n}\ninterface Meta {\n  shouldEmit?: EmitBehavior;\n  /** can be used to override `ObservableQuery.options.fetchPolicy` for this notification */\n  fetchPolicy?: WatchQueryFetchPolicy;\n}\n\nexport declare namespace ObservableQuery {\n  export type Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#nextFetchPolicy:member} */\n    nextFetchPolicy?:\n      | WatchQueryFetchPolicy\n      | ((\n          this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n          currentFetchPolicy: WatchQueryFetchPolicy,\n          context: NextFetchPolicyContext<TData, TVariables>\n        ) => WatchQueryFetchPolicy);\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#initialFetchPolicy:member} */\n    initialFetchPolicy: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n    refetchWritePolicy?: RefetchWritePolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#pollInterval:member} */\n    pollInterval?: number;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n    notifyOnNetworkStatusChange?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n    returnPartialData?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skipPollAttempt:member} */\n    skipPollAttempt?: () => boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#query:member} */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n    variables: TVariables;\n  };\n\n  export type FetchMoreOptions<\n    TData,\n    TVariables extends OperationVariables,\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#query:member} */\n    query?: DocumentNode | TypedDocumentNode<TFetchData, TFetchVars>;\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n    variables?: Partial<NoInfer<TFetchVars>>;\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n    updateQuery?: (\n      previousQueryResult: Unmasked<TData>,\n      options: {\n        fetchMoreResult: Unmasked<TFetchData>;\n        variables: TFetchVars;\n      }\n    ) => Unmasked<TData>;\n  };\n\n  export interface SubscribeToMoreOptions<\n    // eslint-disable-next-line local-rules/tdata-tvariables-order\n    TData = unknown,\n    TSubscriptionVariables extends OperationVariables = OperationVariables,\n    TSubscriptionData = TData,\n    TVariables extends OperationVariables = TSubscriptionVariables,\n  > {\n    document:\n      | DocumentNode\n      | TypedDocumentNode<TSubscriptionData, TSubscriptionVariables>;\n    variables?: TSubscriptionVariables;\n    updateQuery?: SubscribeToMoreUpdateQueryFn<\n      TData,\n      TVariables,\n      TSubscriptionData\n    >;\n    onError?: (error: ErrorLike) => void;\n    context?: DefaultContext;\n  }\n\n  /**\n   * @internal\n   * This describes the `WatchOptions` used by `ObservableQuery` to\n   * subscribe to the cache.\n   */\n  interface CacheWatchOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > extends Cache.WatchOptions<TData, TVariables> {\n    /**\n     * @internal\n     * We cannot suppress the broadcast completely, since that would\n     * result in external updates to be lost if we go from\n     * (external A) -> (own B) -> (external C) when A and C have the same\n     * value.\n     * Without the `own B` being broadcast, the `cache.watch` would swallow\n     * C.\n     * So instead we track the last \"own diff\" and suppress further processing\n     * in the callback.\n     */\n    lastOwnDiff?: Cache.DiffResult<TData>;\n  }\n\n  export type Result<\n    TData,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = {\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n    error?: ErrorLike;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#loading:member} */\n    loading: boolean;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n    networkStatus: NetworkStatus;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#partial:member} */\n    partial: boolean;\n  } & GetDataState<TData, TStates>;\n\n  /**\n   * Promise returned by `reobserve` and `refetch` methods.\n   *\n   * By default, if the `ObservableQuery` is not interested in the result\n   * of this operation anymore, the network operation will be cancelled.\n   *\n   * This has an additional `retain` method that can be used to keep the\n   * network operation running until it is finished nonetheless.\n   */\n  interface ResultPromise<T> extends Promise<T> {\n    /**\n     * Kepp the network operation running until it is finished, even if\n     * `ObservableQuery` unsubscribed from the operation.\n     */\n    retain(): this;\n  }\n\n  export namespace DocumentationTypes {\n    type OperatorFunctionChain<From, To> = [];\n    interface ObservableMethods<TData, OperatorResult> {\n      /** {@inheritDoc @apollo/client!ObservableQuery#pipe:member} */\n      pipe(\n        ...operators: OperatorFunctionChain<\n          ObservableQuery.Result<TData>,\n          OperatorResult\n        >\n      ): Observable<OperatorResult>;\n\n      /** {@inheritDoc @apollo/client!ObservableQuery#subscribe:member} */\n      subscribe(\n        observerOrNext:\n          | Partial<Observer<ObservableQuery.Result<MaybeMasked<TData>>>>\n          | ((value: ObservableQuery.Result<MaybeMasked<TData>>) => void)\n      ): Subscription;\n    }\n  }\n}\n\ninterface SubjectValue<TData, TVariables extends OperationVariables> {\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  variables: TVariables;\n  result: ObservableQuery.Result<TData>;\n  meta: Meta;\n}\n\nexport class ObservableQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >\n  implements\n    Subscribable<ObservableQuery.Result<MaybeMasked<TData>>>,\n    InteropObservable<ObservableQuery.Result<MaybeMasked<TData>>>\n{\n  public readonly options: ObservableQuery.Options<TData, TVariables>;\n  public readonly queryName?: string;\n\n  /** @internal will be read and written from `QueryInfo` */\n  public _lastWrite?: unknown;\n\n  // The `query` computed property will always reflect the document transformed\n  // by the last run query. `this.options.query` will always reflect the raw\n  // untransformed query to ensure document transforms with runtime conditionals\n  // are run on the original document.\n  public get query(): TypedDocumentNode<TData, TVariables> {\n    return this.lastQuery;\n  }\n\n  /**\n   * An object containing the variables that were provided for the query.\n   */\n  public get variables(): TVariables {\n    return this.options.variables;\n  }\n\n  private unsubscribeFromCache?: {\n    (): void;\n    query: TypedDocumentNode<TData, TVariables>;\n    variables: TVariables;\n  };\n  private input!: Subject<\n    QueryNotification.Value<TData> & {\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n      variables: TVariables;\n      meta: Meta;\n    }\n  >;\n  private subject!: BehaviorSubject<\n    SubjectValue<MaybeMasked<TData>, TVariables>\n  >;\n\n  private isTornDown: boolean;\n  private queryManager: QueryManager;\n  private subscriptions = new Set<Subscription>();\n\n  /**\n   * If an `ObservableQuery` is created with a `network-only` fetch policy,\n   * it should actually start receiving cache updates, but not before it has\n   * received the first result from the network.\n   */\n  private waitForNetworkResult: boolean;\n  private lastQuery: DocumentNode;\n\n  private linkSubscription?: Subscription;\n\n  private pollingInfo?: {\n    interval: number;\n    timeout: ReturnType<typeof setTimeout>;\n  };\n\n  private get networkStatus(): NetworkStatus {\n    return this.subject.getValue().result.networkStatus;\n  }\n\n  constructor({\n    queryManager,\n    options,\n    transformedQuery = queryManager.transform(options.query),\n  }: {\n    queryManager: QueryManager;\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>;\n    transformedQuery?: DocumentNode | TypedDocumentNode<TData, TVariables>;\n    queryId?: string;\n  }) {\n    this.queryManager = queryManager;\n\n    // active state\n    this.waitForNetworkResult = options.fetchPolicy === \"network-only\";\n    this.isTornDown = false;\n\n    this.subscribeToMore = this.subscribeToMore.bind(this);\n    this.maskResult = this.maskResult.bind(this);\n\n    const {\n      watchQuery: { fetchPolicy: defaultFetchPolicy = \"cache-first\" } = {},\n    } = queryManager.defaultOptions;\n\n    const {\n      fetchPolicy = defaultFetchPolicy,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      initialFetchPolicy = fetchPolicy === \"standby\" ? defaultFetchPolicy : (\n        fetchPolicy\n      ),\n    } = options;\n\n    this.lastQuery = transformedQuery;\n\n    this.options = {\n      ...options,\n\n      // Remember the initial options.fetchPolicy so we can revert back to this\n      // policy when variables change. This information can also be specified\n      // (or overridden) by providing options.initialFetchPolicy explicitly.\n      initialFetchPolicy,\n\n      // This ensures this.options.fetchPolicy always has a string value, in\n      // case options.fetchPolicy was not provided.\n      fetchPolicy,\n      variables: this.getVariablesWithDefaults(options.variables),\n    };\n\n    this.initializeObservablesQueue();\n\n    this[\"@@observable\"] = () => this;\n    if (Symbol.observable) {\n      this[Symbol.observable] = () => this;\n    }\n\n    const opDef = getOperationDefinition(this.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n  }\n\n  private initializeObservablesQueue() {\n    this.subject = new BehaviorSubject<\n      SubjectValue<MaybeMasked<TData>, TVariables>\n    >({\n      query: this.query,\n      variables: this.variables,\n      result: uninitialized,\n      meta: {},\n    });\n    const observable = this.subject.pipe(\n      tap({\n        subscribe: () => {\n          if (!this.subject.observed) {\n            this.reobserve();\n\n            // TODO: See if we can rework updatePolling to better handle this.\n            // reobserve calls updatePolling but this `subscribe` callback is\n            // called before the subject is subscribed to so `updatePolling`\n            // can't accurately detect if there is an active subscription.\n            // Calling it again here ensures that it can detect if it can poll\n            setTimeout(() => this.updatePolling());\n          }\n        },\n        unsubscribe: () => {\n          if (!this.subject.observed) {\n            this.tearDownQuery();\n          }\n        },\n      }),\n      filterMap(\n        (\n          { query, variables, result: current, meta },\n          context: {\n            previous?: ObservableQuery.Result<TData>;\n            previousVariables?: TVariables;\n          }\n        ) => {\n          const { shouldEmit } = meta;\n\n          if (current === uninitialized) {\n            // reset internal state after `ObservableQuery.reset()`\n            context.previous = undefined;\n            context.previousVariables = undefined;\n          }\n          if (\n            this.options.fetchPolicy === \"standby\" ||\n            shouldEmit === EmitBehavior.never\n          )\n            return;\n          if (shouldEmit === EmitBehavior.force) return emit();\n\n          const { previous, previousVariables } = context;\n\n          if (previous) {\n            const documentInfo = this.queryManager.getDocumentInfo(query);\n            const dataMasking = this.queryManager.dataMasking;\n            const maskedQuery =\n              dataMasking ? documentInfo.nonReactiveQuery : query;\n\n            const resultIsEqual =\n              dataMasking || documentInfo.hasNonreactiveDirective ?\n                equalByQuery(maskedQuery, previous, current, variables)\n              : equal(previous, current);\n\n            if (resultIsEqual && equal(previousVariables, variables)) {\n              return;\n            }\n          }\n\n          if (\n            shouldEmit === EmitBehavior.networkStatusChange &&\n            (!this.options.notifyOnNetworkStatusChange ||\n              equal(previous, current))\n          ) {\n            return;\n          }\n          return emit();\n\n          function emit() {\n            context.previous = current;\n            context.previousVariables = variables;\n            return current;\n          }\n        },\n        () => ({})\n      )\n    );\n\n    this.pipe = observable.pipe.bind(observable);\n    this.subscribe = observable.subscribe.bind(observable);\n\n    this.input = new Subject();\n    // we want to feed many streams into `this.subject`, but none of them should\n    // be able to close `this.input`\n    this.input.complete = () => {};\n    this.input.pipe(this.operator).subscribe(this.subject);\n  }\n\n  // We can't use Observable['subscribe'] here as the type as it conflicts with\n  // the ability to infer T from Subscribable<T>. This limits the surface area\n  // to the non-deprecated signature which works properly with type inference.\n  /**\n   * Subscribes to the `ObservableQuery`.\n   * @param observerOrNext - Either an RxJS `Observer` with some or all callback methods,\n   * or the `next` handler that is called for each value emitted from the subscribed Observable.\n   * @returns A subscription reference to the registered handlers.\n   */\n  public subscribe!: (\n    observerOrNext:\n      | Partial<Observer<ObservableQuery.Result<MaybeMasked<TData>>>>\n      | ((value: ObservableQuery.Result<MaybeMasked<TData>>) => void)\n  ) => Subscription;\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   *\n   * @example\n   *\n   * ```ts\n   * import { filter, map } from 'rxjs';\n   *\n   * observableQuery\n   *   .pipe(\n   *     filter(...),\n   *     map(...),\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   *\n   * @returns The Observable result of all the operators having been called\n   * in the order they were passed in.\n   */\n  public pipe!: Observable<ObservableQuery.Result<MaybeMasked<TData>>>[\"pipe\"];\n\n  public [Symbol.observable]!: () => Subscribable<\n    ObservableQuery.Result<MaybeMasked<TData>>\n  >;\n  public [\"@@observable\"]: () => Subscribable<\n    ObservableQuery.Result<MaybeMasked<TData>>\n  >;\n\n  /**\n   * @internal\n   */\n  public getCacheDiff({ optimistic = true } = {}) {\n    return this.queryManager.cache.diff<TData>({\n      query: this.query,\n      variables: this.variables,\n      returnPartialData: true,\n      optimistic,\n    });\n  }\n\n  private getInitialResult(\n    initialFetchPolicy?: WatchQueryFetchPolicy\n  ): ObservableQuery.Result<MaybeMasked<TData>> {\n    const fetchPolicy =\n      this.queryManager.prioritizeCacheValues ?\n        \"cache-first\"\n      : initialFetchPolicy || this.options.fetchPolicy;\n\n    const cacheResult = (): ObservableQuery.Result<TData> => {\n      const diff = this.getCacheDiff();\n      // TODO: queryInfo.getDiff should handle this since cache.diff returns a\n      // null when returnPartialData is false\n      const data =\n        this.options.returnPartialData || diff.complete ?\n          (diff.result as TData) ?? undefined\n        : undefined;\n\n      return this.maskResult({\n        data,\n        dataState:\n          diff.complete ? \"complete\"\n          : data === undefined ? \"empty\"\n          : \"partial\",\n        loading: !diff.complete,\n        networkStatus:\n          diff.complete ? NetworkStatus.ready : NetworkStatus.loading,\n        partial: !diff.complete,\n      } as ObservableQuery.Result<TData>);\n    };\n\n    switch (fetchPolicy) {\n      case \"cache-only\": {\n        return {\n          ...cacheResult(),\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n      }\n      case \"cache-first\":\n        return cacheResult();\n      case \"cache-and-network\":\n        return {\n          ...cacheResult(),\n          loading: true,\n          networkStatus: NetworkStatus.loading,\n        };\n      case \"standby\":\n        return empty;\n\n      default:\n        return uninitialized;\n    }\n  }\n\n  private resubscribeCache() {\n    const { variables, fetchPolicy } = this.options;\n    const query = this.query;\n\n    const shouldUnsubscribe =\n      fetchPolicy === \"standby\" ||\n      fetchPolicy === \"no-cache\" ||\n      this.waitForNetworkResult;\n\n    const shouldResubscribe =\n      !isEqualQuery({ query, variables }, this.unsubscribeFromCache) &&\n      !this.waitForNetworkResult;\n\n    if (shouldUnsubscribe || shouldResubscribe) {\n      this.unsubscribeFromCache?.();\n    }\n\n    if (shouldUnsubscribe || !shouldResubscribe) {\n      return;\n    }\n\n    const watch: ObservableQuery.CacheWatchOptions<TData, TVariables> = {\n      query,\n      variables,\n      optimistic: true,\n      watcher: this,\n      callback: (diff) => {\n        const info = this.queryManager.getDocumentInfo(query);\n        if (info.hasClientExports || info.hasForcedResolvers) {\n          // If this is not set to something different than `diff`, we will\n          // not be notified about future cache changes with an equal `diff`.\n          // That would be the case if we are working with client-only fields\n          // that are forced or with `exports` fields that might change, causing\n          // local resovlers to return a new result.\n          // This is based on an implementation detail of `InMemoryCache`, which\n          // is not optimal - but the only alternative to this would be to\n          // resubscribe to the cache asynchonouly, which would bear the risk of\n          // missing further synchronous updates.\n          watch.lastDiff = undefined;\n        }\n        if (watch.lastOwnDiff === diff) {\n          // skip cache updates that were caused by our own writes\n          return;\n        }\n\n        const { result: previousResult } = this.subject.getValue();\n\n        if (\n          !diff.complete &&\n          // If we are trying to deliver an incomplete cache result, we avoid\n          // reporting it if the query has errored, otherwise we let the broadcast try\n          // and repair the partial result by refetching the query. This check avoids\n          // a situation where a query that errors and another succeeds with\n          // overlapping data does not report the partial data result to the errored\n          // query.\n          //\n          // See https://github.com/apollographql/apollo-client/issues/11400 for more\n          // information on this issue.\n          (previousResult.error ||\n            // Prevent to schedule a notify directly after the `ObservableQuery`\n            // has been `reset` (which will set the `previousResult` to `uninitialized` or `empty`)\n            // as in those cases, `resetCache` will manually call `refetch` with more intentional timing.\n            previousResult === uninitialized ||\n            previousResult === empty)\n        ) {\n          return;\n        }\n\n        if (!equal(previousResult.data, diff.result)) {\n          this.scheduleNotify();\n        }\n      },\n    };\n    const cancelWatch = this.queryManager.cache.watch(watch);\n\n    this.unsubscribeFromCache = Object.assign(\n      () => {\n        this.unsubscribeFromCache = undefined;\n        cancelWatch();\n      },\n      { query, variables }\n    );\n  }\n\n  private stableLastResult?: ObservableQuery.Result<MaybeMasked<TData>>;\n  public getCurrentResult(): ObservableQuery.Result<MaybeMasked<TData>> {\n    const { result: current } = this.subject.getValue();\n    let value =\n      (\n        // if the `current` result is in an error state, we will always return that\n        // error state, even if we have no observers\n        current.networkStatus === NetworkStatus.error ||\n        // if we have observers, we are watching the cache and\n        // this.subject.getValue() will always be up to date\n        this.hasObservers() ||\n        // if we are using a `no-cache` fetch policy in which case this\n        // `ObservableQuery` cannot have been updated from the outside - in\n        // that case, we prefer to keep the current value\n        this.options.fetchPolicy === \"no-cache\"\n      ) ?\n        current\n        // otherwise, the `current` value might be outdated due to missed\n        // external updates - calculate it again\n      : this.getInitialResult();\n\n    if (value === uninitialized) {\n      value = this.getInitialResult();\n    }\n    if (!equal(this.stableLastResult, value)) {\n      this.stableLastResult = value;\n    }\n    return this.stableLastResult!;\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * Returns a `ResultPromise` with an additional `.retain()` method. Calling\n   * `.retain()` keeps the network operation running even if the `ObservableQuery`\n   * no longer requires the result.\n   *\n   * Note: `refetch()` guarantees that a value will be emitted from the\n   * observable, even if the result is deep equal to the previous value.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(\n    variables?: Partial<TVariables>\n  ): ObservableQuery.ResultPromise<ApolloClient.QueryResult<TData>> {\n    const { fetchPolicy } = this.options;\n\n    const reobserveOptions: Partial<\n      ObservableQuery.Options<TData, TVariables>\n    > = {\n      // Always disable polling for refetches.\n      pollInterval: 0,\n    };\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy === \"no-cache\") {\n      reobserveOptions.fetchPolicy = \"no-cache\";\n    } else {\n      reobserveOptions.fetchPolicy = \"network-only\";\n    }\n\n    if (__DEV__ && variables && hasOwnProperty.call(variables, \"variables\")) {\n      const queryDef = getQueryDefinition(this.query);\n      const vars = queryDef.variableDefinitions;\n      if (!vars || !vars.some((v) => v.variable.name.value === \"variables\")) {\n        invariant.warn(\n          `Called refetch(%o) for query %o, which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?`,\n          variables,\n          queryDef.name?.value || queryDef\n        );\n      }\n    }\n\n    if (variables && !equal(this.variables, variables)) {\n      // Update the existing options with new variables\n      reobserveOptions.variables = this.options.variables =\n        this.getVariablesWithDefaults({ ...this.variables, ...variables });\n    }\n\n    this._lastWrite = undefined;\n    return this._reobserve(reobserveOptions, {\n      newNetworkStatus: NetworkStatus.refetch,\n    });\n  }\n\n  /**\n   * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n   */\n  public fetchMore<\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  >(\n    options: ObservableQuery.FetchMoreOptions<\n      TData,\n      TVariables,\n      TFetchData,\n      TFetchVars\n    >\n  ): Promise<ApolloClient.QueryResult<TFetchData>>;\n  public fetchMore<\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  >({\n    query,\n    variables,\n    context,\n    errorPolicy,\n    updateQuery,\n  }: ObservableQuery.FetchMoreOptions<\n    TData,\n    TVariables,\n    TFetchData,\n    TFetchVars\n  >): Promise<ApolloClient.QueryResult<TFetchData>> {\n    invariant(\n      this.options.fetchPolicy !== \"cache-only\",\n      \"Cannot execute `fetchMore` for 'cache-only' query '%s'. Please use a different fetch policy.\",\n      getOperationName(this.query, \"(anonymous)\")\n    );\n    const combinedOptions = {\n      ...compact(\n        this.options,\n        { errorPolicy: \"none\" },\n        {\n          query,\n          context,\n          errorPolicy,\n        }\n      ),\n      variables: (query ? variables : (\n        {\n          ...this.variables,\n          ...variables,\n        }\n      )) as TFetchVars,\n      // The fetchMore request goes immediately to the network and does\n      // not automatically write its result to the cache (hence no-cache\n      // instead of network-only), because we allow the caller of\n      // fetchMore to provide an updateQuery callback that determines how\n      // the data gets written to the cache.\n      fetchPolicy: \"no-cache\",\n      notifyOnNetworkStatusChange: this.options.notifyOnNetworkStatusChange,\n    } as ApolloClient.QueryOptions<TFetchData, TFetchVars>;\n\n    combinedOptions.query = this.transformDocument(combinedOptions.query);\n\n    // If a temporary query is passed to `fetchMore`, we don't want to store\n    // it as the last query result since it may be an optimized query for\n    // pagination. We will however run the transforms on the original document\n    // as well as the document passed in `fetchMoreOptions` to ensure the cache\n    // uses the most up-to-date document which may rely on runtime conditionals.\n    this.lastQuery =\n      query ?\n        this.transformDocument(this.options.query)\n      : combinedOptions.query;\n\n    let wasUpdated = false;\n\n    const isCached = this.options.fetchPolicy !== \"no-cache\";\n\n    if (!isCached) {\n      invariant(\n        updateQuery,\n        \"You must provide an `updateQuery` function when using `fetchMore` with a `no-cache` fetch policy.\"\n      );\n    }\n\n    const { finalize, pushNotification } = this.pushOperation(\n      NetworkStatus.fetchMore\n    );\n    pushNotification(\n      {\n        source: \"newNetworkStatus\",\n        kind: \"N\",\n        value: {},\n      },\n      { shouldEmit: EmitBehavior.networkStatusChange }\n    );\n    return this.queryManager\n      .fetchQuery(combinedOptions, NetworkStatus.fetchMore)\n      .then((fetchMoreResult) => {\n        // disable the `fetchMore` override that is currently active\n        // the next updates caused by this should not be `fetchMore` anymore,\n        // but `ready` or whatever other calculated loading state is currently\n        // appropriate\n        finalize();\n\n        if (isCached) {\n          // Separately getting a diff here before the batch - `onWatchUpdated` might be\n          // called with an `undefined` `lastDiff` on the watcher if the cache was just subscribed to.\n          const lastDiff = this.getCacheDiff();\n          // Performing this cache update inside a cache.batch transaction ensures\n          // any affected cache.watch watchers are notified at most once about any\n          // updates. Most watchers will be using the QueryInfo class, which\n          // responds to notifications by calling reobserveCacheFirst to deliver\n          // fetchMore cache results back to this ObservableQuery.\n          this.queryManager.cache.batch({\n            update: (cache) => {\n              if (updateQuery) {\n                cache.updateQuery(\n                  {\n                    query: this.query,\n                    variables: this.variables,\n                    returnPartialData: true,\n                    optimistic: false,\n                  },\n                  (previous) =>\n                    updateQuery(previous! as any, {\n                      fetchMoreResult: fetchMoreResult.data as any,\n                      variables: combinedOptions.variables as TFetchVars,\n                    })\n                );\n              } else {\n                // If we're using a field policy instead of updateQuery, the only\n                // thing we need to do is write the new data to the cache using\n                // combinedOptions.variables (instead of this.variables, which is\n                // what this.updateQuery uses, because it works by abusing the\n                // original field value, keyed by the original variables).\n                cache.writeQuery({\n                  query: combinedOptions.query,\n                  variables: combinedOptions.variables,\n                  data: fetchMoreResult.data as Unmasked<any>,\n                });\n              }\n            },\n            onWatchUpdated: (watch, diff) => {\n              if (\n                watch.watcher === this &&\n                !equal(diff.result, lastDiff.result)\n              ) {\n                wasUpdated = true;\n              }\n            },\n          });\n        } else {\n          // There is a possibility `lastResult` may not be set when\n          // `fetchMore` is called which would cause this to crash. This should\n          // only happen if we haven't previously reported a result. We don't\n          // quite know what the right behavior should be here since this block\n          // of code runs after the fetch result has executed on the network.\n          // We plan to let it crash in the meantime.\n          //\n          // If we get bug reports due to the `data` property access on\n          // undefined, this should give us a real-world scenario that we can\n          // use to test against and determine the right behavior. If we do end\n          // up changing this behavior, this may require, for example, an\n          // adjustment to the types on `updateQuery` since that function\n          // expects that the first argument always contains previous result\n          // data, but not `undefined`.\n          const lastResult = this.getCurrentResult();\n          const data = updateQuery!(lastResult.data as Unmasked<TData>, {\n            fetchMoreResult: fetchMoreResult.data as Unmasked<TFetchData>,\n            variables: combinedOptions.variables as TFetchVars,\n          });\n          // was reportResult\n          pushNotification({\n            kind: \"N\",\n            value: {\n              ...lastResult,\n              networkStatus: NetworkStatus.ready,\n              // will be overwritten anyways, just here for types sake\n              loading: false,\n              data: data as any,\n              dataState:\n                lastResult.dataState === \"streaming\" ? \"streaming\" : \"complete\",\n            },\n            source: \"network\",\n          });\n        }\n\n        return this.maskResult(fetchMoreResult);\n      })\n      .finally(() => {\n        // call `finalize` a second time in case the `.then` case above was not reached\n        finalize();\n\n        // In case the cache writes above did not generate a broadcast\n        // notification (which would have been intercepted by onWatchUpdated),\n        // likely because the written data were the same as what was already in\n        // the cache, we still want fetchMore to deliver its final loading:false\n        // result with the unchanged data.\n        if (isCached && !wasUpdated) {\n          pushNotification(\n            {\n              kind: \"N\",\n              source: \"newNetworkStatus\",\n              value: {},\n            },\n            { shouldEmit: EmitBehavior.force }\n          );\n        }\n      });\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  /**\n   * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n   *\n   * This function returns _another_ function that you can call to terminate the subscription.\n   */\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables extends OperationVariables = TVariables,\n  >(\n    options: ObservableQuery.SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData,\n      TVariables\n    >\n  ): () => void {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n        context: options.context,\n      })\n      .subscribe({\n        next: (subscriptionData) => {\n          const { updateQuery, onError } = options;\n          const { error } = subscriptionData;\n\n          if (error) {\n            if (onError) {\n              onError(error);\n            } else {\n              invariant.error(\"Unhandled GraphQL subscription error\", error);\n            }\n\n            return;\n          }\n\n          if (updateQuery) {\n            this.updateQuery((previous, updateOptions) =>\n              updateQuery(previous, {\n                subscriptionData: subscriptionData as {\n                  data: Unmasked<TSubscriptionData>;\n                },\n                ...updateOptions,\n              })\n            );\n          }\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  /** @internal */\n  public applyOptions(\n    newOptions: Partial<ObservableQuery.Options<TData, TVariables>>\n  ): void {\n    const mergedOptions = compact(this.options, newOptions || {});\n    assign(this.options, mergedOptions);\n    this.updatePolling();\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. Most users should prefer `refetch` instead of\n   * `setVariables` in order to to be properly notified of results even when\n   * they come from the cache.\n   *\n   * Note: `setVariables()` guarantees that a value will be emitted from the\n   * observable, even if the result is deeply equal to the previous value.\n   *\n   * Note: the promise will resolve with the last emitted result\n   * when either the variables match the current variables or there\n   * are no subscribers to the query.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public async setVariables(\n    variables: TVariables\n  ): Promise<ApolloClient.QueryResult<TData>> {\n    variables = this.getVariablesWithDefaults(variables);\n\n    if (equal(this.variables, variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return toQueryResult(this.getCurrentResult());\n    }\n\n    this.options.variables = variables;\n\n    // See comment above\n    if (!this.hasObservers()) {\n      return toQueryResult(this.getCurrentResult());\n    }\n\n    return this._reobserve(\n      {\n        // Reset options.fetchPolicy to its original value.\n        fetchPolicy: this.options.initialFetchPolicy,\n        variables,\n      },\n      { newNetworkStatus: NetworkStatus.setVariables }\n    );\n  }\n\n  /**\n   * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n   *\n   * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n   */\n  public updateQuery(mapFn: UpdateQueryMapFn<TData, TVariables>): void {\n    const { queryManager } = this;\n    const { result, complete } = this.getCacheDiff({ optimistic: false });\n\n    const newResult = mapFn(\n      result! as DeepPartial<Unmasked<TData>>,\n      {\n        variables: this.variables,\n        complete: !!complete,\n        previousData: result,\n      } as UpdateQueryOptions<TData, TVariables>\n    );\n\n    if (newResult) {\n      queryManager.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables,\n      });\n\n      queryManager.broadcastQueries();\n    }\n  }\n\n  /**\n   * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n   */\n  public startPolling(pollInterval: number) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  }\n\n  /**\n   * A function that instructs the query to stop polling after a previous call to `startPolling`.\n   */\n  public stopPolling() {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  }\n\n  // Update options.fetchPolicy according to options.nextFetchPolicy.\n  private applyNextFetchPolicy(\n    reason: NextFetchPolicyContext<TData, TVariables>[\"reason\"],\n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>\n  ) {\n    if (options.nextFetchPolicy) {\n      const { fetchPolicy = \"cache-first\", initialFetchPolicy = fetchPolicy } =\n        options;\n\n      if (fetchPolicy === \"standby\") {\n        // Do nothing, leaving options.fetchPolicy unchanged.\n      } else if (typeof options.nextFetchPolicy === \"function\") {\n        // When someone chooses \"cache-and-network\" or \"network-only\" as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the \"cache-and-network\" or \"network-only\" policies would\n        // seem to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete. To\n        // that end, the options.nextFetchPolicy option provides an easy way to\n        // update options.fetchPolicy after the initial network request, without\n        // having to call observableQuery.reobserve.\n        options.fetchPolicy = options.nextFetchPolicy.call(\n          options as any,\n          fetchPolicy,\n          { reason, options, observable: this, initialFetchPolicy }\n        );\n      } else if (reason === \"variables-changed\") {\n        options.fetchPolicy = initialFetchPolicy;\n      } else {\n        options.fetchPolicy = options.nextFetchPolicy;\n      }\n    }\n\n    return options.fetchPolicy;\n  }\n\n  private fetch(\n    options: ObservableQuery.Options<TData, TVariables>,\n    networkStatus: NetworkStatus,\n    fetchQuery: DocumentNode,\n    operator: MonoTypeOperatorFunction<QueryNotification.Value<TData>>\n  ) {\n    // TODO Make sure we update the networkStatus (and infer fetchVariables)\n    // before actually committing to the fetch.\n    const initialFetchPolicy = this.options.fetchPolicy;\n    options.context ??= {};\n\n    let synchronouslyEmitted = false;\n    const onCacheHit = () => {\n      synchronouslyEmitted = true;\n    };\n    const fetchQueryOperator = // we cannot use `tap` here, since it allows only for a \"before subscription\"\n      // hook with `subscribe` and we care for \"directly before and after subscription\"\n      <T>(source: Observable<T>) =>\n        new Observable<T>((subscriber) => {\n          try {\n            return source.subscribe({\n              next(value) {\n                synchronouslyEmitted = true;\n                subscriber.next(value);\n              },\n              error: (error) => subscriber.error(error),\n              complete: () => subscriber.complete(),\n            });\n          } finally {\n            if (!synchronouslyEmitted) {\n              operation.override = networkStatus;\n              this.input.next({\n                kind: \"N\",\n                source: \"newNetworkStatus\",\n                value: {\n                  resetError: true,\n                },\n                query,\n                variables,\n                meta: {\n                  shouldEmit: EmitBehavior.networkStatusChange,\n                  /*\n                   * The moment this notification is emitted, `nextFetchPolicy`\n                   * might already have switched from a `network-only` to a\n                   * `cache-something` policy, so we want to ensure that the\n                   * loading state emit doesn't accidentally read from the cache\n                   * in those cases.\n                   */\n                  fetchPolicy: initialFetchPolicy,\n                },\n              });\n            }\n          }\n        });\n\n    let { observable, fromLink } = this.queryManager.fetchObservableWithInfo(\n      options,\n      {\n        networkStatus,\n        query: fetchQuery,\n        onCacheHit,\n        fetchQueryOperator,\n        observableQuery: this,\n      }\n    );\n\n    // track query and variables from the start of the operation\n    const { query, variables } = this;\n    const operation: TrackedOperation = {\n      abort: () => {\n        subscription.unsubscribe();\n      },\n      query,\n      variables,\n    };\n    this.activeOperations.add(operation);\n\n    let forceFirstValueEmit =\n      networkStatus == NetworkStatus.refetch ||\n      networkStatus == NetworkStatus.setVariables;\n    observable = observable.pipe(operator, share());\n    const subscription = observable\n      .pipe(\n        tap({\n          next: (notification) => {\n            if (\n              notification.source === \"newNetworkStatus\" ||\n              (notification.kind === \"N\" && notification.value.loading)\n            ) {\n              operation.override = networkStatus;\n            } else {\n              delete operation.override;\n            }\n          },\n          finalize: () => this.activeOperations.delete(operation),\n        })\n      )\n      .subscribe({\n        next: (value) => {\n          const meta: Meta = {};\n\n          if (\n            forceFirstValueEmit &&\n            value.kind === \"N\" &&\n            \"loading\" in value.value &&\n            !value.value.loading\n          ) {\n            forceFirstValueEmit = false;\n            meta.shouldEmit = EmitBehavior.force;\n          }\n\n          this.input.next({ ...value, query, variables, meta });\n        },\n      });\n\n    return { fromLink, subscription, observable };\n  }\n\n  // Turns polling on or off based on this.options.pollInterval.\n  private didWarnCacheOnlyPolling = false;\n  private updatePolling() {\n    // Avoid polling in SSR mode\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n\n    const {\n      pollingInfo,\n      options: { fetchPolicy, pollInterval },\n    } = this;\n\n    if (!pollInterval || !this.hasObservers() || fetchPolicy === \"cache-only\") {\n      if (__DEV__) {\n        if (\n          !this.didWarnCacheOnlyPolling &&\n          pollInterval &&\n          fetchPolicy === \"cache-only\"\n        ) {\n          invariant.warn(\n            \"Cannot poll on 'cache-only' query '%s' and as such, polling is disabled. Please use a different fetch policy.\",\n            getOperationName(this.query, \"(anonymous)\")\n          );\n          this.didWarnCacheOnlyPolling = true;\n        }\n      }\n\n      this.cancelPolling();\n      return;\n    }\n\n    if (pollingInfo?.interval === pollInterval) {\n      return;\n    }\n\n    const info = pollingInfo || (this.pollingInfo = {} as any);\n    info.interval = pollInterval;\n\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (\n          !isNetworkRequestInFlight(this.networkStatus) &&\n          !this.options.skipPollAttempt?.()\n        ) {\n          this._reobserve(\n            {\n              // Most fetchPolicy options don't make sense to use in a polling context, as\n              // users wouldn't want to be polling the cache directly. However, network-only and\n              // no-cache are both useful for when the user wants to control whether or not the\n              // polled results are written to the cache.\n              fetchPolicy:\n                this.options.initialFetchPolicy === \"no-cache\" ?\n                  \"no-cache\"\n                : \"network-only\",\n            },\n            {\n              newNetworkStatus: NetworkStatus.poll,\n            }\n          ).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n    };\n\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  }\n\n  // This differs from stopPolling in that it does not set pollInterval to 0\n  private cancelPolling() {\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      delete this.pollingInfo;\n    }\n  }\n\n  /**\n   * Reevaluate the query, optionally against new options. New options will be\n   * merged with the current options when given.\n   *\n   * Note: `variables` can be reset back to their defaults (typically empty) by calling `reobserve` with\n   * `variables: undefined`.\n   */\n  public reobserve(\n    newOptions?: Partial<ObservableQuery.Options<TData, TVariables>>\n  ): ObservableQuery.ResultPromise<\n    ApolloClient.QueryResult<MaybeMasked<TData>>\n  > {\n    return this._reobserve(newOptions);\n  }\n  private _reobserve(\n    newOptions?: Partial<ObservableQuery.Options<TData, TVariables>>,\n    internalOptions?: {\n      newNetworkStatus?: NetworkStatus;\n    }\n  ): ObservableQuery.ResultPromise<\n    ApolloClient.QueryResult<MaybeMasked<TData>>\n  > {\n    this.isTornDown = false;\n    let { newNetworkStatus } = internalOptions || {};\n\n    this.queryManager.obsQueries.add(this);\n\n    const useDisposableObservable =\n      // Refetching uses a disposable Observable to allow refetches using different\n      // options, without permanently altering the options of the\n      // original ObservableQuery.\n      newNetworkStatus === NetworkStatus.refetch ||\n      // Polling uses a disposable Observable so the polling options (which force\n      // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n      newNetworkStatus === NetworkStatus.poll;\n\n    // Save the old variables, since Object.assign may modify them below.\n    const oldVariables = this.variables;\n    const oldFetchPolicy = this.options.fetchPolicy;\n\n    const mergedOptions = compact(this.options, newOptions || {});\n    const options =\n      useDisposableObservable ?\n        // Disposable Observable fetches receive a shallow copy of this.options\n        // (merged with newOptions), leaving this.options unmodified.\n        mergedOptions\n      : assign(this.options, mergedOptions);\n\n    // Don't update options.query with the transformed query to avoid\n    // overwriting this.options.query when we aren't using a disposable concast.\n    // We want to ensure we can re-run the custom document transforms the next\n    // time a request is made against the original query.\n    const query = this.transformDocument(options.query);\n\n    this.lastQuery = query;\n\n    // Reevaluate variables to allow resetting variables with variables: undefined,\n    // otherwise `compact` will ignore the `variables` key in `newOptions`. We\n    // do this after we run the query transform to ensure we get default\n    // variables from the transformed query.\n    //\n    // Note: updating options.variables may mutate this.options.variables\n    // in the case of a non-disposable query. This is intentional.\n    if (newOptions && \"variables\" in newOptions) {\n      options.variables = this.getVariablesWithDefaults(newOptions.variables);\n    }\n\n    if (!useDisposableObservable) {\n      // We can skip calling updatePolling if we're not changing this.options.\n      this.updatePolling();\n\n      // Reset options.fetchPolicy to its original value when variables change,\n      // unless a new fetchPolicy was provided by newOptions.\n      if (\n        newOptions &&\n        newOptions.variables &&\n        !equal(newOptions.variables, oldVariables) &&\n        // Don't mess with the fetchPolicy if it's currently \"standby\".\n        options.fetchPolicy !== \"standby\" &&\n        // If we're changing the fetchPolicy anyway, don't try to change it here\n        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n        (options.fetchPolicy === oldFetchPolicy ||\n          // A `nextFetchPolicy` function has even higher priority, though,\n          // so in that case `applyNextFetchPolicy` must be called.\n          typeof options.nextFetchPolicy === \"function\")\n      ) {\n        // This might mutate options.fetchPolicy\n        this.applyNextFetchPolicy(\"variables-changed\", options);\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n\n    const oldNetworkStatus = this.networkStatus;\n\n    if (!newNetworkStatus) {\n      newNetworkStatus = NetworkStatus.loading;\n\n      if (\n        oldNetworkStatus !== NetworkStatus.loading &&\n        newOptions?.variables &&\n        !equal(newOptions.variables, oldVariables)\n      ) {\n        newNetworkStatus = NetworkStatus.setVariables;\n      }\n\n      // QueryManager does not emit any values for standby fetch policies so we\n      // want ensure that the networkStatus remains ready.\n      if (options.fetchPolicy === \"standby\") {\n        newNetworkStatus = NetworkStatus.ready;\n      }\n    }\n\n    if (options.fetchPolicy === \"standby\") {\n      this.cancelPolling();\n    }\n\n    this.resubscribeCache();\n    const { promise, operator: promiseOperator } = getTrackingOperatorPromise(\n      (value: QueryNotification.Value<TData>) => {\n        switch (value.kind) {\n          case \"E\":\n            throw value.error;\n          case \"N\":\n            if (value.source !== \"newNetworkStatus\" && !value.value.loading)\n              return value.value;\n        }\n      },\n      // This default value should only be used when using a `fetchPolicy` of\n      // `standby` since that fetch policy completes without emitting a\n      // result. Since we are converting this to a QueryResult type, we\n      // omit the extra fields from ApolloQueryResult in the default value.\n      options.fetchPolicy === \"standby\" ?\n        ({ data: undefined } as ObservableQuery.Result<TData>)\n      : undefined\n    );\n    const { subscription, observable, fromLink } = this.fetch(\n      options,\n      newNetworkStatus,\n      query,\n      promiseOperator\n    );\n\n    if (!useDisposableObservable && (fromLink || !this.linkSubscription)) {\n      if (this.linkSubscription) {\n        this.linkSubscription.unsubscribe();\n      }\n\n      this.linkSubscription = subscription;\n    }\n\n    const ret = Object.assign(\n      preventUnhandledRejection(\n        promise\n          .then((result) => toQueryResult(this.maskResult(result)))\n          .finally(() => {\n            if (!this.hasObservers() && this.activeOperations.size === 0) {\n              // If `reobserve` was called on a query without any obervers,\n              // the teardown logic would never be called, so we need to\n              // call it here to ensure the query is properly torn down.\n              this.tearDownQuery();\n            }\n          })\n      ),\n      {\n        retain: () => {\n          const subscription = observable.subscribe({});\n          const unsubscribe = () => subscription.unsubscribe();\n          promise.then(unsubscribe, unsubscribe);\n          return ret;\n        },\n      }\n    );\n    return ret;\n  }\n\n  public hasObservers() {\n    return this.subject.observed;\n  }\n\n  /**\n   * Tears down the `ObservableQuery` and stops all active operations by sending a `complete` notification.\n   */\n  public stop() {\n    this.subject.complete();\n    this.initializeObservablesQueue();\n    this.tearDownQuery();\n  }\n\n  private tearDownQuery() {\n    if (this.isTornDown) return;\n\n    this.resetNotifications();\n    this.unsubscribeFromCache?.();\n    if (this.linkSubscription) {\n      this.linkSubscription.unsubscribe();\n      delete this.linkSubscription;\n    }\n\n    this.stopPolling();\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach((sub) => sub.unsubscribe());\n    this.subscriptions.clear();\n    this.queryManager.obsQueries.delete(this);\n    this.isTornDown = true;\n    this.abortActiveOperations();\n    this._lastWrite = undefined;\n  }\n\n  private transformDocument(document: DocumentNode) {\n    return this.queryManager.transform(document);\n  }\n\n  private maskResult<T extends { data: any }>(result: T): T {\n    const masked = this.queryManager.maskOperation({\n      document: this.query,\n      data: result.data,\n      fetchPolicy: this.options.fetchPolicy,\n      cause: this,\n    });\n\n    // Maintain object identity as much as possible\n    return masked === result.data ? result : { ...result, data: masked };\n  }\n\n  private dirty: boolean = false;\n\n  private notifyTimeout?: ReturnType<typeof setTimeout>;\n\n  /** @internal */\n  private resetNotifications() {\n    if (this.notifyTimeout) {\n      clearTimeout(this.notifyTimeout);\n      this.notifyTimeout = void 0;\n    }\n    this.dirty = false;\n  }\n\n  /** @internal */\n  private scheduleNotify() {\n    if (this.dirty) return;\n    this.dirty = true;\n    if (!this.notifyTimeout) {\n      this.notifyTimeout = setTimeout(() => this.notify(true), 0);\n    }\n  }\n\n  /** @internal */\n  public notify(scheduled = false) {\n    if (!scheduled) {\n      // For queries with client exports or forced resolvers, we don't want to\n      // synchronously reobserve the cache on broadcast,\n      // but actually wait for the `scheduleNotify` timeout triggered by the\n      // `cache.watch` callback from `resubscribeCache`.\n      const info = this.queryManager.getDocumentInfo(this.query);\n      if (info.hasClientExports || info.hasForcedResolvers) {\n        return;\n      }\n    }\n\n    const { dirty } = this;\n    this.resetNotifications();\n\n    if (\n      dirty &&\n      (this.options.fetchPolicy == \"cache-only\" ||\n        this.options.fetchPolicy == \"cache-and-network\" ||\n        !this.activeOperations.size)\n    ) {\n      const diff = this.getCacheDiff();\n      if (\n        // `fromOptimisticTransaction` is not avaiable through the `cache.diff`\n        // code path, so we need to check it this way\n        equal(diff.result, this.getCacheDiff({ optimistic: false }).result)\n      ) {\n        //If this diff did not come from an optimistic transaction\n        // make the ObservableQuery \"reobserve\" the latest data\n        // using a temporary fetch policy of \"cache-first\", so complete cache\n        // results have a chance to be delivered without triggering additional\n        // network requests, even when options.fetchPolicy is \"network-only\"\n        // or \"cache-and-network\". All other fetch policies are preserved by\n        // this method, and are handled by calling oq.reobserve(). If this\n        // reobservation is spurious, distinctUntilChanged still has a\n        // chance to catch it before delivery to ObservableQuery subscribers.\n        this.reobserveCacheFirst();\n      } else {\n        // If this diff came from an optimistic transaction, deliver the\n        // current cache data to the ObservableQuery, but don't perform a\n        // reobservation, since oq.reobserveCacheFirst might make a network\n        // request, and we never want to trigger network requests in the\n        // middle of optimistic updates.\n        this.input.next({\n          kind: \"N\",\n          value: {\n            data: diff.result,\n            dataState:\n              diff.complete ? \"complete\"\n              : diff.result ? \"partial\"\n              : \"empty\",\n            networkStatus: NetworkStatus.ready,\n            loading: false,\n            error: undefined,\n            partial: !diff.complete,\n          } as ObservableQuery.Result<TData>,\n          source: \"cache\",\n          query: this.query,\n          variables: this.variables,\n          meta: {},\n        });\n      }\n    }\n  }\n\n  private activeOperations = new Set<TrackedOperation>();\n  private pushOperation(networkStatus: NetworkStatus): {\n    finalize: () => void;\n    pushNotification: (\n      notification: QueryNotification.Value<TData>,\n      additionalMeta?: Omit<Meta, \"query\" | \"variables\">\n    ) => void;\n  } {\n    let aborted = false;\n    // track query and variables from the start of the operation\n    const { query, variables } = this;\n    const finalize = () => {\n      this.activeOperations.delete(operation);\n    };\n    const operation: TrackedOperation = {\n      override: networkStatus,\n      abort: () => {\n        aborted = true;\n        finalize();\n      },\n      query,\n      variables,\n    };\n    this.activeOperations.add(operation);\n    return {\n      finalize,\n      pushNotification: (\n        notification: QueryNotification.Value<TData>,\n        additionalMeta?: Meta\n      ) => {\n        if (!aborted) {\n          this.input.next({\n            ...notification,\n            query,\n            variables,\n            meta: { ...additionalMeta },\n          });\n        }\n      },\n    };\n  }\n\n  private calculateNetworkStatus(baseNetworkStatus: NetworkStatus) {\n    if (baseNetworkStatus === NetworkStatus.streaming) {\n      return baseNetworkStatus;\n    }\n    // in the future, this could be more complex logic, e.g. \"refetch\" and\n    // \"fetchMore\" having priority over \"polling\" or \"loading\" network statuses\n    // as for now we just take the \"latest\" operation that is still active,\n    // as that lines up best with previous behavior[]\n\n    const operation = Array.from(this.activeOperations.values()).findLast(\n      (operation) =>\n        isEqualQuery(operation, this) && operation.override !== undefined\n    );\n    return operation?.override ?? baseNetworkStatus;\n  }\n\n  private abortActiveOperations() {\n    this.activeOperations.forEach((operation) => operation.abort());\n  }\n\n  /**\n   * @internal\n   * Called from `clearStore`.\n   *\n   * - resets the query to its initial state\n   * - cancels all active operations and their subscriptions\n   */\n  public reset() {\n    // exception for cache-only queries - we reset them into a \"ready\" state\n    // as we won't trigger a refetch for them\n    const resetToEmpty = this.options.fetchPolicy === \"cache-only\";\n    this.setResult(resetToEmpty ? empty : uninitialized, {\n      shouldEmit: resetToEmpty ? EmitBehavior.force : EmitBehavior.never,\n    });\n\n    this.abortActiveOperations();\n  }\n\n  /** @internal */\n  private setResult(\n    result: ObservableQuery.Result<TData>,\n    additionalMeta?: Meta\n  ) {\n    this.input.next({\n      source: \"setResult\",\n      kind: \"N\",\n      value: result,\n      query: this.query,\n      variables: this.variables,\n      meta: { ...additionalMeta },\n    });\n  }\n\n  private operator: OperatorFunction<\n    QueryNotification.Value<TData> & {\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n      variables: TVariables;\n      meta: Meta;\n    },\n    SubjectValue<TData, TVariables>\n  > = filterMap((notification) => {\n    const { query, variables, meta } = notification;\n\n    if (notification.source === \"setResult\") {\n      return { query, variables, result: notification.value, meta };\n    }\n\n    if (notification.kind === \"C\" || !isEqualQuery(notification, this)) {\n      return;\n    }\n\n    let result: ObservableQuery.Result<TData>;\n    const previous = this.subject.getValue();\n\n    if (notification.source === \"cache\") {\n      result = notification.value;\n      if (\n        result.networkStatus === NetworkStatus.ready &&\n        result.partial &&\n        (!this.options.returnPartialData ||\n          previous.result.networkStatus === NetworkStatus.error) &&\n        this.options.fetchPolicy !== \"cache-only\"\n      ) {\n        return;\n      }\n    } else if (notification.source === \"network\") {\n      if (this.waitForNetworkResult) {\n        this.waitForNetworkResult = false;\n        this.resubscribeCache();\n      }\n      result =\n        notification.kind === \"E\" ?\n          ({\n            ...(isEqualQuery(previous, notification) ?\n              previous.result\n            : { data: undefined, dataState: \"empty\", partial: true }),\n            error: notification.error,\n            networkStatus: NetworkStatus.error,\n            loading: false,\n          } as ObservableQuery.Result<TData>)\n        : notification.value;\n\n      if (notification.kind === \"E\" && result.dataState === \"streaming\") {\n        result.dataState = \"complete\" as any;\n      }\n\n      if (result.error) {\n        meta.shouldEmit = EmitBehavior.force;\n      }\n    } else if (notification.source === \"newNetworkStatus\") {\n      const baseResult =\n        isEqualQuery(previous, notification) ?\n          previous.result\n        : this.getInitialResult(meta.fetchPolicy);\n      const { resetError } = notification.value;\n      const error = resetError ? undefined : baseResult.error;\n      const networkStatus = error ? NetworkStatus.error : NetworkStatus.ready;\n      result = {\n        ...baseResult,\n        error,\n        networkStatus,\n      };\n    }\n    // every code path until here should have either returned or set a result,\n    // but typescript needs a little help\n    invariant(result!);\n\n    // normalize result shape\n    if (!result.error) delete result.error;\n    result.networkStatus = this.calculateNetworkStatus(result.networkStatus);\n    result.loading = isNetworkRequestInFlight(result.networkStatus);\n    result = this.maskResult(result);\n\n    return { query, variables, result, meta };\n  });\n\n  // Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n  // delivery of any new data from the cache, possibly falling back to the network\n  // if any cache data are missing. This allows _complete_ cache results to be\n  // delivered without also kicking off unnecessary network requests when\n  // this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n  // this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n  // \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\n  private reobserveCacheFirst(): void {\n    const { fetchPolicy, nextFetchPolicy } = this.options;\n\n    if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n      this.reobserve({\n        fetchPolicy: \"cache-first\",\n        // Use a temporary nextFetchPolicy function that replaces itself with the\n        // previous nextFetchPolicy value and returns the original fetchPolicy.\n        nextFetchPolicy(\n          this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n          currentFetchPolicy: WatchQueryFetchPolicy,\n          context: NextFetchPolicyContext<TData, TVariables>\n        ) {\n          // Replace this nextFetchPolicy function in the options object with the\n          // original this.options.nextFetchPolicy value.\n          this.nextFetchPolicy = nextFetchPolicy;\n          // If the original nextFetchPolicy value was a function, give it a\n          // chance to decide what happens here.\n          if (typeof this.nextFetchPolicy === \"function\") {\n            return this.nextFetchPolicy(currentFetchPolicy, context);\n          }\n          // Otherwise go back to the original this.options.fetchPolicy.\n          return fetchPolicy!;\n        },\n      });\n    } else {\n      this.reobserve();\n    }\n  }\n\n  private getVariablesWithDefaults(variables: TVariables | undefined) {\n    return this.queryManager.getVariables(this.query, variables);\n  }\n}\n\nexport function logMissingFieldErrors(\n  missing: MissingFieldError | MissingTree | undefined\n) {\n  if (__DEV__ && missing) {\n    invariant.debug(`Missing cache result fields: %o`, missing);\n  }\n}\n\nfunction isEqualQuery(\n  a?: { query: DocumentNode; variables: OperationVariables },\n  b?: { query: DocumentNode; variables: OperationVariables }\n) {\n  return !!(a && b && a.query === b.query && equal(a.variables, b.variables));\n}\n\nfunction getTrackingOperatorPromise<ObservedValue, ReturnValue = ObservedValue>(\n  filterMapCb: (value: ObservedValue) => ReturnValue | undefined,\n  defaultValue?: ReturnValue\n) {\n  let lastValue = defaultValue,\n    resolve: (value: ReturnValue) => void,\n    reject: (error: unknown) => void;\n  const promise = new Promise<ReturnValue>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  const operator: MonoTypeOperatorFunction<ObservedValue> = tap({\n    next(value) {\n      try {\n        const newValue = filterMapCb(value);\n        if (newValue !== undefined) {\n          lastValue = newValue;\n        }\n      } catch (error) {\n        reject(error);\n      }\n    },\n    finalize: () => {\n      if (lastValue) {\n        resolve(lastValue);\n      } else {\n        const message = \"The operation was aborted.\";\n        const name = \"AbortError\";\n        reject(\n          typeof DOMException !== \"undefined\" ?\n            new DOMException(message, name)\n            // some environments do not have `DOMException`, e.g. node\n            // uses a normal `Error` with a `name` property instead: https://github.com/phryneas/node/blob/d0579b64f0f6b722f8e49bf8a471dd0d0604a21e/lib/internal/errors.js#L964\n            // error.code is a legacy property that is not used anymore,\n            // and also inconsistent across environments (in supporting\n            // browsers it is `20`, in node `'ABORT_ERR'`) so we omit that.\n          : Object.assign(new Error(message), { name })\n        );\n      }\n    },\n  });\n  return { promise, operator };\n}\n", "import { equal } from \"@wry/equality\";\nimport type { DocumentNode, FormattedExecutionResult } from \"graphql\";\n\nimport type { ApolloCache, Cache } from \"@apollo/client/cache\";\nimport type { IgnoreModifier } from \"@apollo/client/cache\";\nimport type { Incremental } from \"@apollo/client/incremental\";\nimport type { ApolloLink } from \"@apollo/client/link\";\nimport type { Unmasked } from \"@apollo/client/masking\";\nimport type { DeepPartial } from \"@apollo/client/utilities\";\nimport {\n  getOperationName,\n  graphQLResultHasError,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\nimport type {\n  DataValue,\n  DefaultContext,\n  InternalRefetchQueriesInclude,\n  MutationQueryReducer,\n  MutationUpdaterFunction,\n  NormalizedExecutionResult,\n  OnQueryUpdated,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type { ErrorPolicy } from \"./watchQueryOptions.js\";\n\ntype UpdateQueries<TData> = ApolloClient.MutateOptions<\n  TData,\n  any,\n  any\n>[\"updateQueries\"];\n\nconst IGNORE = {} as IgnoreModifier;\n\nexport const enum CacheWriteBehavior {\n  FORBID,\n  OVERWRITE,\n  MERGE,\n}\n\ninterface LastWrite {\n  result: FormattedExecutionResult<any>;\n  variables: ApolloClient.WatchQueryOptions[\"variables\"];\n  dmCount: number | undefined;\n}\n\nconst destructiveMethodCounts = new WeakMap<ApolloCache, number>();\n\ninterface OperationInfo<\n  TData,\n  TVariables extends OperationVariables,\n  AllowedCacheWriteBehavior = CacheWriteBehavior,\n> {\n  document: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  variables: TVariables;\n  errorPolicy: ErrorPolicy;\n  cacheWriteBehavior: AllowedCacheWriteBehavior;\n}\n\nfunction wrapDestructiveCacheMethod(\n  cache: ApolloCache,\n  methodName: \"evict\" | \"modify\" | \"reset\"\n) {\n  const original = cache[methodName];\n  if (typeof original === \"function\") {\n    // @ts-expect-error this is just too generic to be typed correctly\n    cache[methodName] = function () {\n      destructiveMethodCounts.set(\n        cache,\n        // The %1e15 allows the count to wrap around to 0 safely every\n        // quadrillion evictions, so there's no risk of overflow. To be\n        // clear, this is more of a pedantic principle than something\n        // that matters in any conceivable practical scenario.\n        (destructiveMethodCounts.get(cache)! + 1) % 1e15\n      );\n      // @ts-expect-error this is just too generic to be typed correctly\n      return original.apply(this, arguments);\n    };\n  }\n}\n\nconst queryInfoIds = new WeakMap<QueryManager, number>();\n\n// A QueryInfo object represents a single network request, either initiated\n// from the QueryManager or from an ObservableQuery.\n// It will only ever be used for a single network call.\n// It is responsible for reporting results to the cache, merging and in a no-cache\n// scenario accumulating the response.\nexport class QueryInfo<\n  TData,\n  TVariables extends OperationVariables = OperationVariables,\n  TCache extends ApolloCache = ApolloCache,\n> {\n  // TODO remove soon - this should be able to be handled by cancelling old operations before starting new ones\n  lastRequestId = 1;\n\n  private cache: TCache;\n  private queryManager: Pick<\n    QueryManager,\n    | \"getObservableQueries\"\n    | \"refetchQueries\"\n    | \"getDocumentInfo\"\n    | \"broadcastQueries\"\n    | \"incrementalHandler\"\n  >;\n  public readonly id: string;\n  private readonly observableQuery?: ObservableQuery<any, any>;\n  private incremental?: Incremental.IncrementalRequest<\n    Record<string, unknown>,\n    DataValue.Complete<TData> | DataValue.Streaming<TData>\n  >;\n\n  constructor(\n    queryManager: QueryManager,\n    observableQuery?: ObservableQuery<any, any>\n  ) {\n    const cache = (this.cache = queryManager.cache as TCache);\n    const id = (queryInfoIds.get(queryManager) || 0) + 1;\n    queryInfoIds.set(queryManager, id);\n    this.id = id + \"\";\n    this.observableQuery = observableQuery;\n    this.queryManager = queryManager;\n\n    // Track how often cache.evict is called, since we want eviction to\n    // override the feud-stopping logic in the markQueryResult method, by\n    // causing shouldWrite to return true. Wrapping the cache.evict method\n    // is a bit of a hack, but it saves us from having to make eviction\n    // counting an official part of the ApolloCache API.\n    if (!destructiveMethodCounts.has(cache)) {\n      destructiveMethodCounts.set(cache, 0);\n      wrapDestructiveCacheMethod(cache, \"evict\");\n      wrapDestructiveCacheMethod(cache, \"modify\");\n      wrapDestructiveCacheMethod(cache, \"reset\");\n    }\n  }\n\n  /**\n   * @internal\n   * For feud-preventing behaviour, `lastWrite` should be shared by all `QueryInfo` instances of an `ObservableQuery`.\n   * In the case of a standalone `QueryInfo`, we will keep a local version.\n   */\n  public _lastWrite?: LastWrite;\n  private get lastWrite(): LastWrite | undefined {\n    return (this.observableQuery || this)._lastWrite as LastWrite | undefined;\n  }\n  private set lastWrite(value: LastWrite | undefined) {\n    (this.observableQuery || this)._lastWrite = value;\n  }\n\n  public resetLastWrite() {\n    this.lastWrite = void 0;\n  }\n\n  private shouldWrite(\n    result: FormattedExecutionResult<any>,\n    variables: ApolloClient.WatchQueryOptions[\"variables\"]\n  ) {\n    const { lastWrite } = this;\n    return !(\n      lastWrite &&\n      // If cache.evict has been called since the last time we wrote this\n      // data into the cache, there's a chance writing this result into\n      // the cache will repair what was evicted.\n      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&\n      equal(variables, lastWrite.variables) &&\n      equal(result.data, lastWrite.result.data)\n    );\n  }\n\n  get hasNext() {\n    return this.incremental ? this.incremental.hasNext : false;\n  }\n\n  private maybeHandleIncrementalResult(\n    cacheData: TData | DeepPartial<TData> | undefined | null,\n    incoming: ApolloLink.Result<TData>,\n    query: DocumentNode\n  ): FormattedExecutionResult<\n    DataValue.Complete<TData> | DataValue.Streaming<TData>\n  > {\n    const { incrementalHandler } = this.queryManager;\n\n    if (incrementalHandler.isIncrementalResult(incoming)) {\n      this.incremental ||= incrementalHandler.startRequest<\n        TData & Record<string, unknown>\n      >({\n        query,\n      }) as Incremental.IncrementalRequest<\n        Record<string, unknown>,\n        DataValue.Complete<TData> | DataValue.Streaming<TData>\n      >;\n\n      return this.incremental.handle(cacheData, incoming);\n    }\n    return incoming;\n  }\n\n  public markQueryResult(\n    incoming: ApolloLink.Result<TData>,\n    {\n      document: query,\n      variables,\n      errorPolicy,\n      cacheWriteBehavior,\n    }: OperationInfo<TData, TVariables>\n  ): FormattedExecutionResult<\n    DataValue.Complete<TData> | DataValue.Streaming<TData>\n  > {\n    const diffOptions = {\n      query,\n      variables,\n      returnPartialData: true,\n      optimistic: true,\n    };\n\n    // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n    // requests. To allow future notify timeouts, diff and dirty are reset as well.\n    this.observableQuery?.[\"resetNotifications\"]();\n\n    const skipCache = cacheWriteBehavior === CacheWriteBehavior.FORBID;\n    const lastDiff =\n      skipCache ? undefined : this.cache.diff<TData>(diffOptions);\n\n    let result = this.maybeHandleIncrementalResult(\n      lastDiff?.result,\n      incoming,\n      query\n    );\n    if (skipCache) {\n      return result;\n    }\n\n    if (shouldWriteResult(result, errorPolicy)) {\n      // Using a transaction here so we have a chance to read the result\n      // back from the cache before the watch callback fires as a result\n      // of writeQuery, so we can store the new diff quietly and ignore\n      // it when we receive it redundantly from the watch callback.\n      this.cache.batch({\n        onWatchUpdated: (\n          // all additional options on ObservableQuery.CacheWatchOptions are\n          // optional so we can use the type here\n          watch: ObservableQuery.CacheWatchOptions,\n          diff\n        ) => {\n          if (watch.watcher === this.observableQuery) {\n            // see comment on `lastOwnDiff` for explanation\n            watch.lastOwnDiff = diff;\n          }\n        },\n        update: (cache) => {\n          if (this.shouldWrite(result, variables)) {\n            cache.writeQuery({\n              query,\n              data: result.data as Unmasked<any>,\n              variables,\n              overwrite: cacheWriteBehavior === CacheWriteBehavior.OVERWRITE,\n            });\n\n            this.lastWrite = {\n              result,\n              variables,\n              dmCount: destructiveMethodCounts.get(this.cache),\n            };\n          } else {\n            // If result is the same as the last result we received from\n            // the network (and the variables match too), avoid writing\n            // result into the cache again. The wisdom of skipping this\n            // cache write is far from obvious, since any cache write\n            // could be the one that puts the cache back into a desired\n            // state, fixing corruption or missing data. However, if we\n            // always write every network result into the cache, we enable\n            // feuds between queries competing to update the same data in\n            // incompatible ways, which can lead to an endless cycle of\n            // cache broadcasts and useless network requests. As with any\n            // feud, eventually one side must step back from the brink,\n            // letting the other side(s) have the last word(s). There may\n            // be other points where we could break this cycle, such as\n            // silencing the broadcast for cache.writeQuery (not a good\n            // idea, since it just delays the feud a bit) or somehow\n            // avoiding the network request that just happened (also bad,\n            // because the server could return useful new data). All\n            // options considered, skipping this cache write seems to be\n            // the least damaging place to break the cycle, because it\n            // reflects the intuition that we recently wrote this exact\n            // result into the cache, so the cache *should* already/still\n            // contain this data. If some other query has clobbered that\n            // data in the meantime, that's too bad, but there will be no\n            // winners if every query blindly reverts to its own version\n            // of the data. This approach also gives the network a chance\n            // to return new data, which will be written into the cache as\n            // usual, notifying only those queries that are directly\n            // affected by the cache updates, as usual. In the future, an\n            // even more sophisticated cache could perhaps prevent or\n            // mitigate the clobbering somehow, but that would make this\n            // particular cache write even less important, and thus\n            // skipping it would be even safer than it is today.\n            if (lastDiff && lastDiff.complete) {\n              // Reuse data from the last good (complete) diff that we\n              // received, when possible.\n              result = { ...result, data: lastDiff.result };\n              return;\n            }\n            // If the previous this.diff was incomplete, fall through to\n            // re-reading the latest data with cache.diff, below.\n          }\n\n          const diff = cache.diff<TData>(diffOptions);\n\n          // If we're allowed to write to the cache, and we can read a\n          // complete result from the cache, update result.data to be the\n          // result from the cache, rather than the raw network result.\n          // Set without setDiff to avoid triggering a notify call, since\n          // we have other ways of notifying for this result.\n          if (diff.complete) {\n            result = { ...result, data: diff.result };\n          }\n        },\n      });\n    } else {\n      this.lastWrite = void 0;\n    }\n\n    return result;\n  }\n\n  public markMutationResult(\n    incoming: ApolloLink.Result<TData>,\n    mutation: OperationInfo<\n      TData,\n      TVariables,\n      CacheWriteBehavior.FORBID | CacheWriteBehavior.MERGE\n    > & {\n      context?: DefaultContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?:\n        | ((\n            result: NormalizedExecutionResult<Unmasked<TData>>\n          ) => InternalRefetchQueriesInclude)\n        | InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache\n  ): Promise<\n    FormattedExecutionResult<\n      DataValue.Complete<TData> | DataValue.Streaming<TData>\n    >\n  > {\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.cacheWriteBehavior === CacheWriteBehavior.FORBID;\n\n    let result = this.maybeHandleIncrementalResult(\n      skipCache ? undefined : (\n        cache.diff<TData>({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.queryManager.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true,\n        }).result\n      ),\n      incoming,\n      mutation.document\n    );\n\n    if (mutation.errorPolicy === \"ignore\") {\n      result = { ...result, errors: [] };\n    }\n\n    if (graphQLResultHasError(result) && mutation.errorPolicy === \"none\") {\n      return Promise.resolve(result);\n    }\n\n    const getResultWithDataState = () =>\n      ({\n        ...result,\n        dataState: this.hasNext ? \"streaming\" : \"complete\",\n      }) as NormalizedExecutionResult<Unmasked<TData>>;\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      cacheWrites.push({\n        result: result.data,\n        dataId: \"ROOT_MUTATION\",\n        query: mutation.document,\n        variables: mutation.variables,\n      });\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queryManager\n          .getObservableQueries(\"all\")\n          .forEach((observableQuery) => {\n            const queryName = observableQuery && observableQuery.queryName;\n            if (\n              !queryName ||\n              !Object.hasOwnProperty.call(updateQueries, queryName)\n            ) {\n              return;\n            }\n            const updater = updateQueries[queryName];\n            const { query: document, variables } = observableQuery;\n\n            // Read the current query result from the store.\n            const { result: currentQueryResult, complete } =\n              observableQuery.getCacheDiff({ optimistic: false });\n\n            if (complete && currentQueryResult) {\n              // Run our reducer using the current query result and the mutation result.\n              const nextQueryResult = (updater as MutationQueryReducer<any>)(\n                currentQueryResult,\n                {\n                  mutationResult: getResultWithDataState(),\n                  queryName: (document && getOperationName(document)) || void 0,\n                  queryVariables: variables!,\n                }\n              );\n\n              // Write the modified result back into the store if we got a new result.\n              if (nextQueryResult) {\n                cacheWrites.push({\n                  result: nextQueryResult,\n                  dataId: \"ROOT_QUERY\",\n                  query: document!,\n                  variables,\n                });\n              }\n            }\n          });\n      }\n    }\n\n    let refetchQueries = mutation.refetchQueries;\n    if (typeof refetchQueries === \"function\") {\n      refetchQueries = refetchQueries(getResultWithDataState());\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      (refetchQueries || \"\").length > 0 ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.queryManager\n        .refetchQueries({\n          updateCache: (cache) => {\n            if (!skipCache) {\n              cacheWrites.forEach((write) => cache.write(write));\n            }\n\n            // If the mutation has some writes associated with it then we need to\n            // apply those writes to the store by running this reducer again with\n            // a write action.\n            const { update } = mutation;\n            // Determine whether result is a SingleExecutionResult,\n            // or the final ExecutionPatchResult.\n\n            if (update) {\n              if (!skipCache) {\n                // Re-read the ROOT_MUTATION data we just wrote into the cache\n                // (the first cache.write call in the cacheWrites.forEach loop\n                // above), so field read functions have a chance to run for\n                // fields within mutation result objects.\n                const diff = cache.diff<TData>({\n                  id: \"ROOT_MUTATION\",\n                  // The cache complains if passed a mutation where it expects a\n                  // query, so we transform mutations and subscriptions to queries\n                  // (only once, thanks to this.transformCache).\n                  query: this.queryManager.getDocumentInfo(mutation.document)\n                    .asQuery,\n                  variables: mutation.variables,\n                  optimistic: false,\n                  returnPartialData: true,\n                });\n\n                if (diff.complete) {\n                  result = {\n                    ...result,\n                    data: diff.result,\n                  };\n                }\n              }\n\n              // If we've received the whole response, call the update function.\n              if (!this.hasNext) {\n                update(\n                  cache as TCache,\n                  result as FormattedExecutionResult<Unmasked<TData>>,\n                  {\n                    context: mutation.context,\n                    variables: mutation.variables,\n                  }\n                );\n              }\n            }\n\n            // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n            // shallow to allow rolling back optimistic evictions.\n            if (!skipCache && !mutation.keepRootFields && !this.hasNext) {\n              cache.modify({\n                id: \"ROOT_MUTATION\",\n                fields(value, { fieldName, DELETE }) {\n                  return fieldName === \"__typename\" ? value : DELETE;\n                },\n              });\n            }\n          },\n\n          include: refetchQueries,\n\n          // Write the final mutation.result to the root layer of the cache.\n          optimistic: false,\n\n          // Remove the corresponding optimistic layer at the same time as we\n          // write the final non-optimistic result.\n          removeOptimistic: mutation.removeOptimistic,\n\n          // Let the caller of client.mutate optionally determine the refetching\n          // behavior for watched queries after the mutation.update function runs.\n          // If no onQueryUpdated function was provided for this mutation, pass\n          // null instead of undefined to disable the default refetching behavior.\n          onQueryUpdated: mutation.onQueryUpdated || null,\n        })\n        .forEach((result) => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic(\n    optimisticResponse: any,\n    mutation: OperationInfo<\n      TData,\n      TVariables,\n      CacheWriteBehavior.FORBID | CacheWriteBehavior.MERGE\n    > & {\n      context?: DefaultContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TCache>;\n      keepRootFields?: boolean;\n    }\n  ) {\n    const data =\n      typeof optimisticResponse === \"function\" ?\n        optimisticResponse(mutation.variables, { IGNORE })\n      : optimisticResponse;\n\n    if (data === IGNORE) {\n      return false;\n    }\n\n    this.cache.recordOptimisticTransaction((cache) => {\n      try {\n        this.markMutationResult({ data }, mutation, cache as TCache);\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, this.id);\n\n    return true;\n  }\n\n  public markSubscriptionResult(\n    result: FormattedExecutionResult<TData>,\n    {\n      document,\n      variables,\n      errorPolicy,\n      cacheWriteBehavior,\n    }: OperationInfo<\n      TData,\n      TVariables,\n      CacheWriteBehavior.FORBID | CacheWriteBehavior.MERGE\n    >\n  ) {\n    if (cacheWriteBehavior !== CacheWriteBehavior.FORBID) {\n      if (shouldWriteResult(result, errorPolicy)) {\n        this.cache.write({\n          query: document,\n          result: result.data as any,\n          dataId: \"ROOT_SUBSCRIPTION\",\n          variables: variables,\n        });\n      }\n\n      this.queryManager.broadcastQueries();\n    }\n  }\n}\n\nfunction shouldWriteResult<T>(\n  result: FormattedExecutionResult<T>,\n  errorPolicy: ErrorPolicy = \"none\"\n) {\n  const ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n  let writeWithErrors = !graphQLResultHasError(result);\n  if (!writeWithErrors && ignoreErrors && result.data) {\n    writeWithErrors = true;\n  }\n  return writeWithErrors;\n}\n", "import { Trie } from \"@wry/trie\";\nimport type {\n  DirectiveNode,\n  DocumentNode,\n  FormattedExecutionResult,\n} from \"graphql\";\nimport { BREAK, Kind, OperationTypeNode, visit } from \"graphql\";\nimport { Observable, throwError } from \"rxjs\";\nimport {\n  catchError,\n  concat,\n  EMPTY,\n  filter,\n  finalize,\n  from,\n  lastValueFrom,\n  map,\n  materialize,\n  mergeMap,\n  of,\n  share,\n  shareReplay,\n  Subject,\n  tap,\n} from \"rxjs\";\n\nimport type { ApolloCache, Cache } from \"@apollo/client/cache\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport {\n  CombinedGraphQLErrors,\n  graphQLResultHasProtocolErrors,\n  registerLinkError,\n  toErrorLike,\n} from \"@apollo/client/errors\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"@apollo/client/errors\";\nimport type { Incremental } from \"@apollo/client/incremental\";\nimport type { ApolloLink } from \"@apollo/client/link\";\nimport { execute } from \"@apollo/client/link\";\nimport type { LocalState } from \"@apollo/client/local-state\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport { maskFragment, maskOperation } from \"@apollo/client/masking\";\nimport type { DeepPartial } from \"@apollo/client/utilities\";\nimport {\n  cacheSizes,\n  DocumentTransform,\n  isNetworkRequestInFlight,\n  print,\n} from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport {\n  AutoCleanedWeakCache,\n  checkDocument,\n  filterMap,\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  graphQLResultHasError,\n  hasDirectives,\n  hasForcedResolvers,\n  isDocumentNode,\n  isNonNullObject,\n  makeUniqueId,\n  removeDirectivesFromDocument,\n  toQueryResult,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  invariant,\n  newInvariantError,\n} from \"@apollo/client/utilities/invariant\";\n\nimport { defaultCacheSizes } from \"../utilities/caching/sizes.js\";\n\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nimport { logMissingFieldErrors, ObservableQuery } from \"./ObservableQuery.js\";\nimport { CacheWriteBehavior, QueryInfo } from \"./QueryInfo.js\";\nimport type {\n  DefaultContext,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesMap,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  OperationVariables,\n  QueryNotification,\n  SubscriptionObservable,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type {\n  ErrorPolicy,\n  MutationFetchPolicy,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ninterface TransformCacheEntry {\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  hasNonreactiveDirective: boolean;\n  hasIncrementalDirective: boolean;\n  nonReactiveQuery: DocumentNode;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n  operationType: OperationTypeNode | undefined;\n  violation?: Error | undefined;\n}\n\ninterface MaskFragmentOptions<TData> {\n  fragment: DocumentNode;\n  data: TData;\n  fragmentName?: string;\n}\n\ninterface MaskOperationOptions<TData> {\n  document: DocumentNode;\n  data: TData;\n  /**\n   * Can be used to identify the cause to prevent warning for the same cause twice.\n   * This would be an object like e.g. an `ObervableQuery`.\n   * If the `cause` is not provided, we will warn every time.\n   */\n  cause?: object;\n  fetchPolicy?: WatchQueryFetchPolicy;\n}\n\ninterface QueryManagerOptions {\n  client: ApolloClient;\n  clientOptions: ApolloClient.Options;\n  defaultOptions: ApolloClient.DefaultOptions;\n  documentTransform: DocumentTransform | null | undefined;\n  queryDeduplication: boolean;\n  onBroadcast: undefined | (() => void);\n  ssrMode: boolean;\n  assumeImmutableResults: boolean;\n  defaultContext: Partial<DefaultContext> | undefined;\n  dataMasking: boolean;\n  localState: LocalState | undefined;\n  incrementalHandler: Incremental.Handler;\n}\n\nexport class QueryManager {\n  public defaultOptions: ApolloClient.DefaultOptions;\n\n  public readonly client: ApolloClient;\n  /**\n   * The options that were passed to the ApolloClient constructor.\n   */\n  public readonly clientOptions: ApolloClient.Options;\n  public readonly assumeImmutableResults: boolean;\n  public readonly documentTransform: DocumentTransform;\n  public readonly ssrMode: boolean;\n  public readonly defaultContext: Partial<DefaultContext>;\n  public readonly dataMasking: boolean;\n  public readonly incrementalHandler: Incremental.Handler;\n  public localState: LocalState | undefined;\n\n  private queryDeduplication: boolean;\n\n  /**\n   * Whether to prioritize cache values over network results when\n   * `fetchObservableWithInfo` is called.\n   * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"`\n   * fetchPolicy into a `\"cache-first\"` fetchPolicy, but without influencing\n   * the `fetchPolicy` of the `ObservableQuery`.\n   *\n   * This can e.g. be used to prioritize the cache during the first render after\n   * SSR.\n   */\n  public prioritizeCacheValues: boolean = false;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  /**\n   * All ObservableQueries that currently have at least one subscriber.\n   */\n  public obsQueries = new Set<ObservableQuery<any, any>>();\n\n  // Maps from queryInfo.id strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor(options: QueryManagerOptions) {\n    const defaultDocumentTransform = new DocumentTransform(\n      (document) => this.cache.transformDocument(document),\n      // Allow the apollo cache to manage its own transform caches\n      { cache: false }\n    );\n\n    this.client = options.client;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientOptions = options.clientOptions;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    this.localState = options.localState;\n    this.incrementalHandler = options.incrementalHandler;\n    const documentTransform = options.documentTransform;\n    this.documentTransform =\n      documentTransform ?\n        defaultDocumentTransform\n          .concat(documentTransform)\n          // The custom document transform may add new fragment spreads or new\n          // field selections, so we want to give the cache a chance to run\n          // again. For example, the InMemoryCache adds __typename to field\n          // selections and fragments from the fragment registry.\n          .concat(defaultDocumentTransform)\n      : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || {};\n\n    if ((this.onBroadcast = options.onBroadcast)) {\n      this.mutationStore = {};\n    }\n  }\n\n  get link() {\n    return this.client.link;\n  }\n\n  get cache() {\n    return this.client.cache;\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.obsQueries.forEach((oq) => oq.stop());\n\n    this.cancelPendingFetches(\n      newInvariantError(\"QueryManager stopped while query was in flight\")\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach((cancel) => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TCache extends ApolloCache,\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy,\n    errorPolicy,\n    keepRootFields,\n    context,\n  }: ApolloClient.MutateOptions<TData, TVariables, TCache> & {\n    errorPolicy: ErrorPolicy;\n    fetchPolicy: MutationFetchPolicy;\n  }): Promise<ApolloClient.MutateResult<MaybeMasked<TData>>> {\n    const queryInfo = new QueryInfo<TData, TVariables, TCache>(this);\n\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const { hasClientExports } = this.getDocumentInfo(mutation);\n\n    variables = this.getVariables(mutation, variables);\n\n    if (hasClientExports) {\n      if (__DEV__) {\n        invariant(\n          this.localState,\n          \"Mutation '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured.\",\n          getOperationName(mutation, \"(anonymous)\")\n        );\n      }\n\n      variables = await this.localState!.getExportedVariables<TVariables>({\n        client: this.client,\n        document: mutation,\n        variables,\n        context,\n      });\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[queryInfo.id] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    const isOptimistic =\n      optimisticResponse &&\n      queryInfo.markMutationOptimistic(optimisticResponse, {\n        document: mutation,\n        variables,\n        cacheWriteBehavior:\n          fetchPolicy === \"no-cache\" ?\n            CacheWriteBehavior.FORBID\n          : CacheWriteBehavior.MERGE,\n        errorPolicy,\n        context,\n        updateQueries,\n        update: updateWithProxyFn,\n        keepRootFields,\n      });\n\n    this.broadcastQueries();\n\n    return new Promise((resolve, reject) => {\n      const cause = {};\n      return this.getObservableFromLink<TData>(\n        mutation,\n        {\n          ...context,\n          optimisticResponse: isOptimistic ? optimisticResponse : void 0,\n        },\n        variables,\n        {},\n        false\n      )\n        .observable.pipe(\n          validateDidEmitValue(),\n          mergeMap((result) => {\n            const storeResult: typeof result = { ...result };\n\n            return from(\n              queryInfo.markMutationResult(storeResult, {\n                document: mutation,\n                variables,\n                cacheWriteBehavior:\n                  fetchPolicy === \"no-cache\" ?\n                    CacheWriteBehavior.FORBID\n                  : CacheWriteBehavior.MERGE,\n                errorPolicy,\n                context,\n                update: updateWithProxyFn,\n                updateQueries,\n                awaitRefetchQueries,\n                refetchQueries,\n                removeOptimistic: isOptimistic ? queryInfo.id : void 0,\n                onQueryUpdated,\n                keepRootFields,\n              })\n            );\n          })\n        )\n        .pipe(\n          map((storeResult) => {\n            const hasErrors = graphQLResultHasError(storeResult);\n            if (hasErrors && errorPolicy === \"none\") {\n              throw new CombinedGraphQLErrors(storeResult);\n            }\n\n            if (mutationStoreValue) {\n              mutationStoreValue.loading = false;\n              mutationStoreValue.error = null;\n            }\n\n            return storeResult;\n          })\n        )\n        .subscribe({\n          next: (storeResult) => {\n            this.broadcastQueries();\n\n            // Since mutations might receive multiple payloads from the\n            // ApolloLink chain (e.g. when used with @defer),\n            // we resolve with a SingleExecutionResult or after the final\n            // ExecutionPatchResult has arrived and we have assembled the\n            // multipart response into a single result.\n            if (!queryInfo.hasNext) {\n              const result: ApolloClient.MutateResult<TData> = {\n                data: this.maskOperation({\n                  document: mutation,\n                  data: storeResult.data,\n                  fetchPolicy,\n                  cause,\n                }) as any,\n              };\n\n              if (graphQLResultHasError(storeResult)) {\n                result.error = new CombinedGraphQLErrors(storeResult);\n              }\n\n              if (Object.keys(storeResult.extensions || {}).length) {\n                result.extensions = storeResult.extensions;\n              }\n\n              resolve(result);\n            }\n          },\n\n          error: (error) => {\n            if (mutationStoreValue) {\n              mutationStoreValue.loading = false;\n              mutationStoreValue.error = error;\n            }\n\n            if (isOptimistic) {\n              this.cache.removeOptimistic(queryInfo.id);\n            }\n\n            this.broadcastQueries();\n\n            if (errorPolicy === \"ignore\") {\n              return resolve({ data: undefined });\n            }\n\n            if (errorPolicy === \"all\") {\n              return resolve({ data: undefined, error });\n            }\n\n            reject(error);\n          },\n        });\n    });\n  }\n\n  public fetchQuery<TData, TVariables extends OperationVariables>(\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>,\n    networkStatus?: NetworkStatus\n  ): Promise<ApolloClient.QueryResult<TData>> {\n    checkDocument(options.query, OperationTypeNode.QUERY);\n\n    // do the rest asynchronously to keep the same rejection timing as\n    // checks further in `.mutate`\n    return (async () =>\n      lastValueFrom(\n        this.fetchObservableWithInfo(options, {\n          networkStatus,\n        }).observable.pipe(\n          filterMap((value) => {\n            switch (value.kind) {\n              case \"E\":\n                throw value.error;\n              case \"N\": {\n                if (value.source !== \"newNetworkStatus\")\n                  return toQueryResult(value.value);\n              }\n            }\n          })\n        ),\n        {\n          // This default is needed when a `standby` fetch policy is used to avoid\n          // an EmptyError from rejecting this promise.\n          defaultValue: { data: undefined },\n        }\n      ))();\n  }\n\n  public transform(document: DocumentNode) {\n    return this.documentTransform.transformDocument(document);\n  }\n\n  private transformCache = new AutoCleanedWeakCache<\n    DocumentNode,\n    TransformCacheEntry\n  >(\n    cacheSizes[\"queryManager.getDocumentInfo\"] ||\n      defaultCacheSizes[\"queryManager.getDocumentInfo\"]\n  );\n\n  public getDocumentInfo(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const operationDefinition = getOperationDefinition(document);\n\n      const cacheEntry: TransformCacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasDirectives([\"client\", \"export\"], document, true),\n        hasForcedResolvers: hasForcedResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        hasIncrementalDirective: hasDirectives([\"defer\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: hasDirectives([\"client\"], document) ? document : null,\n        serverQuery: removeDirectivesFromDocument(\n          [\n            { name: \"client\", remove: true },\n            { name: \"connection\" },\n            { name: \"nonreactive\" },\n            { name: \"unmask\" },\n          ],\n          document\n        ),\n        operationType: operationDefinition?.operation,\n        defaultVars: getDefaultValues(\n          operationDefinition\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map((def) => {\n            if (\n              def.kind === \"OperationDefinition\" &&\n              def.operation !== \"query\"\n            ) {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        },\n      };\n\n      transformCache.set(document, cacheEntry);\n    }\n\n    const entry = transformCache.get(document)!;\n    if (entry.violation) {\n      throw entry.violation;\n    }\n    return entry;\n  }\n\n  public getVariables<TVariables extends OperationVariables>(\n    document: DocumentNode,\n    variables?: TVariables\n  ): TVariables {\n    const defaultVars = this.getDocumentInfo(document).defaultVars;\n    const varsWithDefaults = Object.entries(variables ?? {}).map(\n      ([key, value]) => [key, value === undefined ? defaultVars[key] : value]\n    );\n\n    return {\n      ...defaultVars,\n      ...Object.fromEntries(varsWithDefaults),\n    };\n  }\n\n  public watchQuery<\n    TData,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>\n  ): ObservableQuery<TData, TVariables> {\n    checkDocument(options.query, OperationTypeNode.QUERY);\n\n    const query = this.transform(options.query);\n\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(query, options.variables) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = true;\n    }\n\n    const observable = new ObservableQuery<TData, TVariables>({\n      queryManager: this,\n      options,\n      transformedQuery: query,\n    });\n\n    return observable;\n  }\n\n  public query<\n    TData,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.QueryOptions<TData, TVariables>\n  ): Promise<ApolloClient.QueryResult<MaybeMasked<TData>>> {\n    const query = this.transform(options.query);\n\n    return this.fetchQuery<TData, TVariables>({\n      ...(options as any),\n      query,\n    }).then((value) => ({\n      ...value,\n      data: this.maskOperation({\n        document: query,\n        data: value?.data,\n        fetchPolicy: options.fetchPolicy,\n      }),\n    }));\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  public clearStore(\n    options: Cache.ResetOptions = {\n      discardWatches: true,\n    }\n  ): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(\n      newInvariantError(\n        \"Store reset while query was in flight (not completed in link chain)\"\n      )\n    );\n\n    this.obsQueries.forEach((observableQuery) => {\n      // Set loading to true so listeners don't trigger unless they want\n      // results with partial data.\n      observableQuery.reset();\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = {};\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\"\n  ) {\n    const queries = new Set<ObservableQuery<any>>();\n    const queryNames = new Map<string, string | undefined>();\n    const queryNamesAndQueryStrings = new Map<string, boolean>();\n    const legacyQueryOptions = new Set<ApolloClient.QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach((desc) => {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          const queryString = print(this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.obsQueries.forEach((oq) => {\n      const document = print(this.transform(oq.options.query));\n      if (include === \"all\") {\n        queries.add(oq);\n        return;\n      }\n\n      const {\n        queryName,\n        options: { fetchPolicy },\n      } = oq;\n\n      if (include === \"active\" && fetchPolicy === \"standby\") {\n        return;\n      }\n\n      if (\n        include === \"active\" ||\n        (queryName && queryNamesAndQueryStrings.has(queryName)) ||\n        (document && queryNamesAndQueryStrings.has(document))\n      ) {\n        queries.add(oq);\n        if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n        if (document) queryNamesAndQueryStrings.set(document, true);\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options) => {\n        const oq = new ObservableQuery({\n          queryManager: this,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        queries.add(oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach((included, nameOrQueryString) => {\n        if (!included) {\n          const queryName = queryNames.get(nameOrQueryString);\n\n          if (queryName) {\n            invariant.warn(\n              `Unknown query named \"%s\" requested in refetchQueries options.include array`,\n              queryName\n            );\n          } else {\n            invariant.warn(\n              `Unknown anonymous query requested in refetchQueries options.include array`\n            );\n          }\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public refetchObservableQueries(\n    includeStandby: boolean = false\n  ): Promise<ApolloClient.QueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloClient.QueryResult<any>>[] =\n      [];\n\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(\n      (observableQuery) => {\n        const { fetchPolicy } = observableQuery.options;\n        if (\n          (includeStandby || fetchPolicy !== \"standby\") &&\n          fetchPolicy !== \"cache-only\"\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n      }\n    );\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public startGraphQLSubscription<TData = unknown>(\n    options: ApolloClient.SubscribeOptions<TData>\n  ): SubscriptionObservable<ApolloClient.SubscribeResult<TData>> {\n    let { query, variables } = options;\n    const {\n      fetchPolicy,\n      errorPolicy = \"none\",\n      context = {},\n      extensions = {},\n    } = options;\n\n    checkDocument(query, OperationTypeNode.SUBSCRIPTION);\n\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    let restart: (() => void) | undefined;\n\n    if (__DEV__) {\n      invariant(\n        !this.getDocumentInfo(query).hasClientExports || this.localState,\n        \"Subscription '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured.\",\n        getOperationName(query, \"(anonymous)\")\n      );\n    }\n\n    const observable = (\n      this.getDocumentInfo(query).hasClientExports ?\n        from(\n          this.localState!.getExportedVariables({\n            client: this.client,\n            document: query,\n            variables,\n            context,\n          })\n        )\n      : of(variables)).pipe(\n      mergeMap((variables) => {\n        const { observable, restart: res } = this.getObservableFromLink<TData>(\n          query,\n          context,\n          variables,\n          extensions\n        );\n\n        const queryInfo = new QueryInfo<TData>(this);\n\n        restart = res;\n        return (observable as Observable<FormattedExecutionResult<TData>>).pipe(\n          map((rawResult): ApolloClient.SubscribeResult<TData> => {\n            queryInfo.markSubscriptionResult(rawResult, {\n              document: query,\n              variables,\n              errorPolicy,\n              cacheWriteBehavior:\n                fetchPolicy === \"no-cache\" ?\n                  CacheWriteBehavior.FORBID\n                : CacheWriteBehavior.MERGE,\n            });\n\n            const result: ApolloClient.SubscribeResult<TData> = {\n              data: rawResult.data ?? undefined,\n            };\n\n            if (graphQLResultHasError(rawResult)) {\n              result.error = new CombinedGraphQLErrors(rawResult);\n            } else if (graphQLResultHasProtocolErrors(rawResult)) {\n              result.error = rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n              // Don't emit protocol errors added by HttpLink\n              delete rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n            }\n\n            if (\n              rawResult.extensions &&\n              Object.keys(rawResult.extensions).length\n            ) {\n              result.extensions = rawResult.extensions;\n            }\n\n            if (result.error && errorPolicy === \"none\") {\n              result.data = undefined;\n            }\n\n            if (errorPolicy === \"ignore\") {\n              delete result.error;\n            }\n\n            return result;\n          }),\n          catchError((error) => {\n            if (errorPolicy === \"ignore\") {\n              return of({\n                data: undefined,\n              } as ApolloClient.SubscribeResult<TData>);\n            }\n\n            return of({ data: undefined, error });\n          }),\n          filter((result) => !!(result.data || result.error))\n        );\n      })\n    );\n\n    return Object.assign(observable, { restart: () => restart?.() });\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.obsQueries.forEach((observableQuery) => observableQuery.notify());\n  }\n\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected inFlightLinkObservables = new Trie<{\n    observable?: Observable<ApolloLink.Result<any>>;\n    restart?: () => void;\n  }>(false);\n\n  private getObservableFromLink<TData = unknown>(\n    query: DocumentNode,\n    context: DefaultContext | undefined,\n    variables?: OperationVariables,\n    extensions?: Record<string, any>,\n    // Prefer context.queryDeduplication if specified.\n    deduplication: boolean = context?.queryDeduplication ??\n      this.queryDeduplication\n  ): {\n    restart: () => void;\n    observable: Observable<ApolloLink.Result<TData>>;\n  } {\n    let entry: {\n      observable?: Observable<ApolloLink.Result<TData>>;\n      // The restart function has to be on a mutable object that way if multiple\n      // client.subscribe() calls are made before the first one subscribes to\n      // the observable, the `restart` function can be updated for all\n      // deduplicated client.subscribe() calls.\n      restart?: () => void;\n    } = {};\n\n    const { serverQuery, clientQuery, operationType, hasIncrementalDirective } =\n      this.getDocumentInfo(query);\n\n    const operationName = getOperationName(query);\n    const executeContext: ApolloLink.ExecuteContext = {\n      client: this.client,\n    };\n\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      try {\n        const operation = this.incrementalHandler.prepareRequest({\n          query: serverQuery,\n          variables,\n          context: {\n            ...this.defaultContext,\n            ...context,\n            queryDeduplication: deduplication,\n          },\n          extensions,\n        });\n\n        context = operation.context;\n\n        function withRestart(source: Observable<ApolloLink.Result>) {\n          return new Observable<ApolloLink.Result>((observer) => {\n            function subscribe() {\n              return source.subscribe({\n                next: observer.next.bind(observer),\n                complete: observer.complete.bind(observer),\n                error: observer.error.bind(observer),\n              });\n            }\n            let subscription = subscribe();\n\n            entry.restart ||= () => {\n              subscription.unsubscribe();\n              subscription = subscribe();\n            };\n\n            return () => {\n              subscription.unsubscribe();\n              entry.restart = undefined;\n            };\n          });\n        }\n\n        if (deduplication) {\n          const printedServerQuery = print(serverQuery);\n          const varJson = canonicalStringify(variables);\n\n          entry = inFlightLinkObservables.lookup(printedServerQuery, varJson);\n\n          if (!entry.observable) {\n            entry.observable = execute(link, operation, executeContext).pipe(\n              withRestart,\n              finalize(() => {\n                if (\n                  inFlightLinkObservables.peek(printedServerQuery, varJson) ===\n                  entry\n                ) {\n                  inFlightLinkObservables.remove(printedServerQuery, varJson);\n                }\n              }),\n              // We don't want to replay the last emitted value for\n              // subscriptions and instead opt to wait to receive updates until\n              // the subscription emits new values.\n              operationType === OperationTypeNode.SUBSCRIPTION ?\n                share()\n              : shareReplay({ refCount: true })\n            ) as Observable<ApolloLink.Result<TData>>;\n          }\n        } else {\n          entry.observable = execute(link, operation, executeContext).pipe(\n            withRestart\n          ) as Observable<ApolloLink.Result<TData>>;\n        }\n      } catch (error) {\n        entry.observable = throwError(() => error);\n      }\n    } else {\n      entry.observable = of({ data: {} } as ApolloLink.Result<TData>);\n    }\n\n    if (clientQuery) {\n      const { operation } = getOperationDefinition(query)!;\n      if (__DEV__) {\n        invariant(\n          this.localState,\n          \"%s '%s' contains `@client` fields but local state has not been configured.\",\n          operation[0].toUpperCase() + operation.slice(1),\n          operationName ?? \"(anonymous)\"\n        );\n      }\n\n      invariant(\n        !hasIncrementalDirective,\n        \"%s '%s' contains `@client` and `@defer` directives. These cannot be used together.\",\n        operation[0].toUpperCase() + operation.slice(1),\n        operationName ?? \"(anonymous)\"\n      );\n\n      entry.observable = entry.observable.pipe(\n        mergeMap((result) => {\n          return from(\n            this.localState!.execute<TData>({\n              client: this.client,\n              document: clientQuery,\n              remoteResult: result as FormattedExecutionResult<TData>,\n              context,\n              variables,\n            })\n          );\n        })\n      );\n    }\n\n    return {\n      restart: () => entry.restart?.(),\n      observable: entry.observable.pipe(\n        catchError((error) => {\n          error = toErrorLike(error);\n          registerLinkError(error);\n          throw error;\n        })\n      ),\n    };\n  }\n\n  private getResultsFromLink<TData, TVariables extends OperationVariables>(\n    options: {\n      query: DocumentNode;\n      variables: TVariables;\n      context: DefaultContext | undefined;\n      fetchPolicy: WatchQueryFetchPolicy;\n      errorPolicy: ErrorPolicy;\n    },\n    {\n      queryInfo,\n      cacheWriteBehavior,\n      observableQuery,\n    }: {\n      queryInfo: QueryInfo<TData, TVariables>;\n      cacheWriteBehavior: CacheWriteBehavior;\n      observableQuery: ObservableQuery<TData, TVariables> | undefined;\n    }\n  ): Observable<ObservableQuery.Result<TData>> {\n    const requestId = (queryInfo.lastRequestId = this.generateRequestId());\n    const { errorPolicy } = options;\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n\n    return this.getObservableFromLink<TData>(\n      linkDocument,\n      options.context,\n      options.variables\n    ).observable.pipe(\n      map((incoming) => {\n        // Use linkDocument rather than queryInfo.document so the\n        // operation/fragments used to write the result are the same as the\n        // ones used to obtain it from the link.\n        const result = queryInfo.markQueryResult(incoming, {\n          ...options,\n          document: linkDocument,\n          cacheWriteBehavior,\n        });\n        const hasErrors = graphQLResultHasError(result);\n\n        if (hasErrors && errorPolicy === \"none\") {\n          queryInfo.resetLastWrite();\n          observableQuery?.[\"resetNotifications\"]();\n          throw new CombinedGraphQLErrors(result);\n        }\n\n        const aqr = {\n          data: result.data as TData,\n          ...(queryInfo.hasNext ?\n            {\n              loading: true,\n              networkStatus: NetworkStatus.streaming,\n              dataState: \"streaming\",\n              partial: true,\n            }\n          : {\n              dataState: result.data ? \"complete\" : \"empty\",\n              loading: false,\n              networkStatus: NetworkStatus.ready,\n              partial: !result.data,\n            }),\n        } as ObservableQuery.Result<TData>;\n\n        // In the case we start multiple network requests simulatenously, we\n        // want to ensure we properly set `data` if we're reporting on an old\n        // result which will not be caught by the conditional above that ends up\n        // throwing the markError result.\n        if (hasErrors) {\n          if (errorPolicy === \"none\") {\n            aqr.data = void 0 as TData;\n            aqr.dataState = \"empty\";\n          }\n          if (errorPolicy !== \"ignore\") {\n            aqr.error = new CombinedGraphQLErrors(result);\n            if (aqr.dataState !== \"streaming\") {\n              aqr.networkStatus = NetworkStatus.error;\n            }\n          }\n        }\n\n        return aqr;\n      }),\n      catchError((error) => {\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId && errorPolicy === \"none\") {\n          queryInfo.resetLastWrite();\n          observableQuery?.[\"resetNotifications\"]();\n          throw error;\n        }\n\n        const aqr: ObservableQuery.Result<TData> = {\n          data: undefined,\n          dataState: \"empty\",\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n          partial: true,\n        };\n\n        if (errorPolicy !== \"ignore\") {\n          aqr.error = error;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return of(aqr);\n      })\n    );\n  }\n\n  public fetchObservableWithInfo<TData, TVariables extends OperationVariables>(\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>,\n    {\n      // The initial networkStatus for this fetch, most often\n      // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n      // or setVariables.\n      networkStatus = NetworkStatus.loading,\n      query = options.query,\n      fetchQueryOperator = (x) => x,\n      onCacheHit = () => {},\n      observableQuery,\n    }: {\n      networkStatus?: NetworkStatus;\n      query?: DocumentNode;\n      fetchQueryOperator?: <T>(source: Observable<T>) => Observable<T>;\n      onCacheHit?: () => void;\n      observableQuery?: ObservableQuery<TData, TVariables> | undefined;\n    }\n  ): ObservableAndInfo<TData> {\n    const variables = this.getVariables(query, options.variables) as TVariables;\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = (defaults && defaults.fetchPolicy) || \"cache-first\",\n      errorPolicy = (defaults && defaults.errorPolicy) || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = true,\n      context = {},\n    } = options;\n\n    if (\n      this.prioritizeCacheValues &&\n      (fetchPolicy === \"network-only\" || fetchPolicy === \"cache-and-network\")\n    ) {\n      fetchPolicy = \"cache-first\";\n    }\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const queryInfo = new QueryInfo<TData, TVariables>(this, observableQuery);\n\n    const fromVariables = (variables: TVariables) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const cacheWriteBehavior =\n        fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID\n          // Watched queries must opt into overwriting existing data on refetch,\n          // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n        : (\n          networkStatus === NetworkStatus.refetch &&\n          normalized.refetchWritePolicy !== \"merge\"\n        ) ?\n          CacheWriteBehavior.OVERWRITE\n        : CacheWriteBehavior.MERGE;\n      const observableWithInfo = this.fetchQueryByPolicy<TData, TVariables>(\n        normalized,\n        { queryInfo, cacheWriteBehavior, onCacheHit, observableQuery }\n      );\n      observableWithInfo.observable =\n        observableWithInfo.observable.pipe(fetchQueryOperator);\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\"\n      ) {\n        observableQuery?.[\"applyNextFetchPolicy\"](\n          \"after-fetch\",\n          options as any\n        );\n      }\n\n      return observableWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => {\n      this.fetchCancelFns.delete(queryInfo.id);\n    };\n    this.fetchCancelFns.set(queryInfo.id, (error) => {\n      fetchCancelSubject.next({\n        kind: \"E\",\n        error,\n        source: \"network\",\n      });\n    });\n\n    const fetchCancelSubject = new Subject<QueryNotification.Value<TData>>();\n    let observable: Observable<QueryNotification.Value<TData>>,\n      containsDataFromLink: boolean;\n\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      if (__DEV__) {\n        invariant(\n          this.localState,\n          \"Query '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured.\",\n          getOperationName(normalized.query, \"(anonymous)\")\n        );\n      }\n\n      observable = from(\n        this.localState!.getExportedVariables({\n          client: this.client,\n          document: normalized.query,\n          variables: normalized.variables,\n          context: normalized.context,\n        })\n      ).pipe(mergeMap((variables) => fromVariables(variables).observable));\n\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      observable = sourcesWithInfo.observable;\n    }\n\n    return {\n      // Merge `observable` with `fetchCancelSubject`, in a way that completing or\n      // erroring either of them will complete the merged obserable.\n      observable: new Observable<QueryNotification.Value<TData>>((observer) => {\n        observer.add(cleanupCancelFn);\n        observable.subscribe(observer);\n        fetchCancelSubject.subscribe(observer);\n      }).pipe(share()),\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<\n    ApolloCache,\n    TResult\n  >): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesByOq = new Map<\n      ObservableQuery<any>,\n      {\n        oq: ObservableQuery<any>;\n        lastDiff?: Cache.DiffResult<any>;\n        diff?: Cache.DiffResult<any>;\n      }\n    >();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq) => {\n        if (oq.options.fetchPolicy === \"cache-only\") {\n          return;\n        }\n\n        const current = oq.getCurrentResult();\n        includedQueriesByOq.set(oq, {\n          oq,\n          lastDiff: {\n            result: current?.data,\n            complete: !current?.partial,\n          },\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map();\n\n    if (updateCache) {\n      const handled = new Set<ObservableQuery<any>>();\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: (optimistic && removeOptimistic) || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq = watch.watcher;\n\n          if (oq instanceof ObservableQuery && !handled.has(oq)) {\n            handled.add(oq);\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesByOq.delete(oq);\n\n              let result:\n                | TResult\n                | boolean\n                | Promise<ApolloClient.QueryResult<any>> = onQueryUpdated(\n                oq,\n                diff,\n                lastDiff\n              );\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq\n                  .refetch()\n                  .retain(/* create a persistent subscription on the query */);\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(\n                  oq,\n                  result as InternalRefetchQueriesResult<TResult>\n                );\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (\n              onQueryUpdated !== null &&\n              oq.options.fetchPolicy !== \"cache-only\"\n            ) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesByOq.set(oq, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesByOq.size) {\n      includedQueriesByOq.forEach(({ oq, lastDiff, diff }) => {\n        let result:\n          | TResult\n          | boolean\n          | Promise<ApolloClient.QueryResult<any>>\n          | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            diff = oq.getCacheDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq\n            .refetch()\n            .retain(/* create a persistent subscription on the query */);\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private noCacheWarningsByCause = new WeakSet<object>();\n\n  public maskOperation<TData = unknown>(\n    options: MaskOperationOptions<TData>\n  ): MaybeMasked<TData> {\n    const { document, data } = options;\n\n    if (__DEV__) {\n      const { fetchPolicy, cause = {} } = options;\n      const operationType = getOperationDefinition(document)?.operation;\n\n      if (\n        this.dataMasking &&\n        fetchPolicy === \"no-cache\" &&\n        !isFullyUnmaskedOperation(document) &&\n        !this.noCacheWarningsByCause.has(cause)\n      ) {\n        this.noCacheWarningsByCause.add(cause);\n\n        invariant.warn(\n          '[%s]: Fragments masked by data masking are inaccessible when using fetch policy \"no-cache\". Please add `@unmask` to each fragment spread to access the data.',\n          getOperationName(document, `Unnamed ${operationType ?? \"operation\"}`)\n        );\n      }\n    }\n\n    return (\n      this.dataMasking ?\n        maskOperation(data, document, this.cache)\n      : data) as MaybeMasked<TData>;\n  }\n\n  public maskFragment<TData = unknown>(options: MaskFragmentOptions<TData>) {\n    const { data, fragment, fragmentName } = options;\n\n    return this.dataMasking ?\n        maskFragment(data, fragment, this.cache, fragmentName)\n      : data;\n  }\n\n  private fetchQueryByPolicy<TData, TVariables extends OperationVariables>(\n    {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n    }: {\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n      variables: TVariables;\n      fetchPolicy: WatchQueryFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      returnPartialData?: boolean;\n      context?: DefaultContext;\n    },\n    {\n      cacheWriteBehavior,\n      onCacheHit,\n      queryInfo,\n      observableQuery,\n    }: {\n      cacheWriteBehavior: CacheWriteBehavior;\n      onCacheHit: () => void;\n      queryInfo: QueryInfo<TData, TVariables>;\n      observableQuery: ObservableQuery<TData, TVariables> | undefined;\n    }\n  ): ObservableAndInfo<TData> {\n    const readCache = () =>\n      this.cache.diff<any>({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: true,\n      });\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus: NetworkStatus\n    ): Observable<QueryNotification.FromCache<TData>> => {\n      const data = diff.result;\n\n      if (__DEV__ && !returnPartialData && data !== null) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const toResult = (\n        data: TData | DeepPartial<TData> | undefined\n      ): ObservableQuery.Result<TData> => {\n        // TODO: Eventually we should move this handling into\n        // queryInfo.getDiff() directly. Since getDiff is updated to return null\n        // on returnPartialData: false, we should take advantage of that instead\n        // of having to patch it elsewhere.\n        if (!diff.complete && !returnPartialData) {\n          data = undefined;\n        }\n\n        return {\n          // TODO: Handle partial data\n          data: data as TData | undefined,\n          dataState:\n            diff.complete ? \"complete\"\n            : data ? \"partial\"\n            : \"empty\",\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          partial: !diff.complete,\n        } as ObservableQuery.Result<TData>;\n      };\n\n      const fromData = (\n        data: TData | DeepPartial<TData> | undefined\n      ): Observable<QueryNotification.FromCache<TData>> => {\n        return of({\n          kind: \"N\",\n          value: toResult(data),\n          source: \"cache\",\n        });\n      };\n\n      if (\n        // Don't attempt to run forced resolvers if we have incomplete cache\n        // data and partial isn't allowed since this result would get set to\n        // `undefined` anyways in `toResult`.\n        (diff.complete || returnPartialData) &&\n        this.getDocumentInfo(query).hasForcedResolvers\n      ) {\n        if (__DEV__) {\n          invariant(\n            this.localState,\n            \"Query '%s' contains `@client` fields but local state has not been configured.\",\n            getOperationName(query, \"(anonymous)\")\n          );\n        }\n        onCacheHit();\n\n        return from(\n          this.localState!.execute<TData>({\n            client: this.client,\n            document: query,\n            remoteResult: data ? { data } : undefined,\n            context,\n            variables,\n            onlyRunForcedResolvers: true,\n            returnPartialData: true,\n          }).then(\n            (resolved): QueryNotification.FromCache<TData> => ({\n              kind: \"N\",\n              value: toResult(resolved.data || void 0),\n              source: \"cache\",\n            })\n          )\n        );\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === \"none\" &&\n        networkStatus === NetworkStatus.refetch &&\n        diff.missing\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data || undefined);\n    };\n\n    const resultsFromLink = () =>\n      this.getResultsFromLink<TData, TVariables>(\n        {\n          query,\n          variables,\n          context,\n          fetchPolicy,\n          errorPolicy,\n        },\n        {\n          cacheWriteBehavior,\n          queryInfo,\n          observableQuery,\n        }\n      ).pipe(\n        validateDidEmitValue(),\n        materialize(),\n        map(\n          (result): QueryNotification.FromNetwork<TData> => ({\n            ...result,\n            source: \"network\",\n          })\n        )\n      );\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return {\n            fromLink: false,\n            observable: resultsFromCache(diff, NetworkStatus.ready),\n          };\n        }\n\n        if (returnPartialData) {\n          return {\n            fromLink: true,\n            observable: concat(\n              resultsFromCache(diff, NetworkStatus.loading),\n              resultsFromLink()\n            ),\n          };\n        }\n\n        return { fromLink: true, observable: resultsFromLink() };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData) {\n          return {\n            fromLink: true,\n            observable: concat(\n              resultsFromCache(diff, NetworkStatus.loading),\n              resultsFromLink()\n            ),\n          };\n        }\n\n        return { fromLink: true, observable: resultsFromLink() };\n      }\n\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          observable: concat(\n            resultsFromCache(readCache(), NetworkStatus.ready)\n          ),\n        };\n\n      case \"network-only\":\n        return { fromLink: true, observable: resultsFromLink() };\n\n      case \"no-cache\":\n        return { fromLink: true, observable: resultsFromLink() };\n\n      case \"standby\":\n        return { fromLink: false, observable: EMPTY };\n    }\n  }\n}\n\nfunction validateDidEmitValue<T>() {\n  let didEmitValue = false;\n\n  return tap<T>({\n    next() {\n      didEmitValue = true;\n    },\n    complete() {\n      invariant(\n        didEmitValue,\n        \"The link chain completed without emitting a value. This is likely unintentional and should be updated to emit a value before completing.\"\n      );\n    },\n  });\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface ObservableAndInfo<TData> {\n  // Metadata properties that can be returned in addition to the Observable.\n  fromLink: boolean;\n  observable: Observable<QueryNotification.Value<TData>>;\n}\n\nfunction isFullyUnmaskedOperation(document: DocumentNode) {\n  let isUnmasked = true;\n\n  visit(document, {\n    FragmentSpread: (node) => {\n      isUnmasked =\n        !!node.directives &&\n        node.directives.some((directive) => directive.name.value === \"unmask\");\n\n      if (!isUnmasked) {\n        return BREAK;\n      }\n    },\n  });\n\n  return isUnmasked;\n}\n\nfunction addNonReactiveToNamedFragments(document: DocumentNode) {\n  return visit(document, {\n    FragmentSpread: (node) => {\n      // Do not add `@nonreactive` if the fragment is marked with `@unmask`\n      // since we want to react to changes in this fragment.\n      if (\n        node.directives?.some((directive) => directive.name.value === \"unmask\")\n      ) {\n        return;\n      }\n\n      return {\n        ...node,\n        directives: [\n          ...(node.directives || []),\n          {\n            kind: Kind.DIRECTIVE,\n            name: { kind: Kind.NAME, value: \"nonreactive\" },\n          } satisfies DirectiveNode,\n        ],\n      };\n    },\n  });\n}\n", "import type { DocumentNode } from \"graphql\";\nimport { OperationTypeNode } from \"graphql\";\nimport type { Observable } from \"rxjs\";\nimport { map } from \"rxjs\";\n\nimport type {\n  ApolloCache,\n  IgnoreModifier,\n  Reference,\n} from \"@apollo/client/cache\";\nimport type { Incremental } from \"@apollo/client/incremental\";\nimport { NotImplementedHandler } from \"@apollo/client/incremental\";\nimport type { ApolloLink } from \"@apollo/client/link\";\nimport { execute } from \"@apollo/client/link\";\nimport type { ClientAwarenessLink } from \"@apollo/client/link/client-awareness\";\nimport type { LocalState } from \"@apollo/client/local-state\";\nimport type { MaybeMasked, Unmasked } from \"@apollo/client/masking\";\nimport { DocumentTransform } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type { VariablesOption } from \"@apollo/client/utilities/internal\";\nimport {\n  checkDocument,\n  compact,\n  getApolloClientMemoryInternals,\n  mergeOptions,\n  removeMaskedFragmentSpreads,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { version } from \"../version.js\";\n\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nimport type {\n  DefaultContext,\n  ErrorLike,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesResult,\n  MutationQueryReducersMap,\n  MutationUpdaterFunction,\n  NormalizedExecutionResult,\n  OnQueryUpdated,\n  OperationVariables,\n  RefetchQueriesInclude,\n  RefetchQueriesPromiseResults,\n  SubscriptionObservable,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type {\n  ErrorPolicy,\n  FetchPolicy,\n  MutationFetchPolicy,\n  NextFetchPolicyContext,\n  RefetchWritePolicy,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nlet hasSuggestedDevtools = false;\n\nexport declare namespace ApolloClient {\n  export interface DefaultOptions {\n    watchQuery?: Partial<ApolloClient.WatchQueryOptions<any, any>>;\n    query?: Partial<ApolloClient.QueryOptions<any, any>>;\n    mutate?: Partial<ApolloClient.MutateOptions<any, any, any>>;\n  }\n\n  export interface Options {\n    /**\n     * An `ApolloLink` instance to serve as Apollo Client's network layer. For more information, see [Advanced HTTP networking](https://www.apollographql.com/docs/react/networking/advanced-http-networking/).\n     */\n    link: ApolloLink;\n    /**\n     * The cache that Apollo Client should use to store query results locally. The recommended cache is `InMemoryCache`, which is provided by the `@apollo/client` package.\n     *\n     * For more information, see [Configuring the cache](https://www.apollographql.com/docs/react/caching/cache-configuration/).\n     */\n    cache: ApolloCache;\n    /**\n     * The time interval (in milliseconds) before Apollo Client force-fetches queries after a server-side render.\n     *\n     * @defaultValue `0` (no delay)\n     */\n    ssrForceFetchDelay?: number;\n    /**\n     * When using Apollo Client for [server-side rendering](https://www.apollographql.com/docs/react/performance/server-side-rendering/), set this to `true` so that the [`getDataFromTree` function](../react/ssr/#getdatafromtree) can work effectively.\n     *\n     * @defaultValue `false`\n     */\n    ssrMode?: boolean;\n    /**\n     * If `false`, Apollo Client sends every created query to the server, even if a _completely_ identical query (identical in terms of query string, variable values, and operationName) is already in flight.\n     *\n     * @defaultValue `true`\n     */\n    queryDeduplication?: boolean;\n    /**\n     * Provide this object to set application-wide default values for options you can provide to the `watchQuery`, `query`, and `mutate` functions. See below for an example object.\n     *\n     * See this [example object](https://www.apollographql.com/docs/react/api/core/ApolloClient#example-defaultoptions-object).\n     */\n    defaultOptions?: ApolloClient.DefaultOptions;\n    defaultContext?: Partial<DefaultContext>;\n    /**\n     * If `true`, Apollo Client will assume results read from the cache are never mutated by application code, which enables substantial performance optimizations.\n     *\n     * @defaultValue `false`\n     */\n    assumeImmutableResults?: boolean;\n    localState?: LocalState;\n    /** {@inheritDoc @apollo/client/link/client-awareness!ClientAwarenessLink.ClientAwarenessOptions:interface} */\n    clientAwareness?: ClientAwarenessLink.ClientAwarenessOptions;\n    /** {@inheritDoc @apollo/client/link/client-awareness!ClientAwarenessLink.EnhancedClientAwarenessOptions:interface} */\n    enhancedClientAwareness?: ClientAwarenessLink.EnhancedClientAwarenessOptions;\n    documentTransform?: DocumentTransform;\n\n    /**\n     * Configuration used by the [Apollo Client Devtools extension](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) for this client.\n     *\n     * @since 3.11.0\n     */\n    devtools?: ApolloClient.DevtoolsOptions;\n\n    /**\n     * Determines if data masking is enabled for the client.\n     *\n     * @defaultValue false\n     */\n    dataMasking?: boolean;\n\n    /**\n     * Determines the strategy used to parse incremental chunks from `@defer`\n     * queries.\n     */\n    incrementalHandler?: Incremental.Handler<any>;\n  }\n\n  interface DevtoolsOptions {\n    /**\n     * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to this `ApolloClient` instance.\n     *\n     * The default value is `false` in production and `true` in development if there is a `window` object.\n     */\n    enabled?: boolean;\n\n    /**\n     * Optional name for this `ApolloClient` instance in the devtools. This is\n     * useful when you instantiate multiple clients and want to be able to\n     * identify them by name.\n     */\n    name?: string;\n  }\n\n  export type MutateOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TCache extends ApolloCache = ApolloCache,\n  > = {\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#optimisticResponse:member} */\n    optimisticResponse?:\n      | Unmasked<NoInfer<TData>>\n      | ((\n          vars: TVariables,\n          { IGNORE }: { IGNORE: IgnoreModifier }\n        ) => Unmasked<NoInfer<TData>> | IgnoreModifier);\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#updateQueries:member} */\n    updateQueries?: MutationQueryReducersMap<TData>;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#refetchQueries:member} */\n    refetchQueries?:\n      | ((\n          result: NormalizedExecutionResult<Unmasked<TData>>\n        ) => InternalRefetchQueriesInclude)\n      | InternalRefetchQueriesInclude;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#awaitRefetchQueries:member} */\n    awaitRefetchQueries?: boolean;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#update:member} */\n    update?: MutationUpdaterFunction<TData, TVariables, TCache>;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#onQueryUpdated:member} */\n    onQueryUpdated?: OnQueryUpdated<any>;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: MutationFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#keepRootFields:member} */\n    keepRootFields?: boolean;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#mutation:member} */\n    mutation: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  } & VariablesOption<NoInfer<TVariables>>;\n\n  export interface MutateResult<TData = unknown> {\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#data:member} */\n    data: TData | undefined;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#error:member} */\n    error?: ErrorLike;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#extensions:member} */\n    extensions?: Record<string, unknown>;\n  }\n\n  /**\n   * Query options.\n   */\n  export type QueryOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#query:member} */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: FetchPolicy;\n  } & VariablesOption<NoInfer<TVariables>>;\n\n  export interface QueryResult<TData = unknown> {\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#data:member} */\n    data: TData | undefined;\n\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n    error?: ErrorLike;\n  }\n\n  /**\n   * Options object for the `client.refetchQueries` method.\n   */\n  export interface RefetchQueriesOptions<TCache extends ApolloCache, TResult> {\n    /**\n     * Optional function that updates cached fields to trigger refetches of queries that include those fields.\n     */\n    updateCache?: (cache: TCache) => void;\n\n    /**\n     * Optional array specifying queries to refetch. Each element can be either a query's string name or a `DocumentNode` object.\n     *\n     * Pass `\"active\"` as a shorthand to refetch all active queries, or `\"all\"` to refetch all active and inactive queries.\n     *\n     * Analogous to the [`options.refetchQueries`](https://www.apollographql.com/docs/react/data/mutations/#options) array for mutations.\n     */\n    include?: RefetchQueriesInclude;\n\n    /**\n     * If `true`, the `options.updateCache` function is executed on a temporary optimistic layer of `InMemoryCache`, so its modifications can be discarded from the cache after observing which fields it invalidated.\n     *\n     * Defaults to `false`, meaning `options.updateCache` updates the cache in a lasting way.\n     */\n    optimistic?: boolean;\n\n    /**\n     * Optional callback function that's called once for each `ObservableQuery` that's either affected by `options.updateCache` or listed in `options.include` (or both).\n     *\n     * If `onQueryUpdated` is not provided, the default implementation returns the result of calling `observableQuery.refetch()`. When `onQueryUpdated` is provided, it can dynamically decide whether (and how) each query should be refetched.\n     *\n     * Returning `false` from `onQueryUpdated` prevents the associated query from being refetched.\n     */\n    onQueryUpdated?: OnQueryUpdated<TResult> | null;\n  }\n\n  /**\n   * The result of client.refetchQueries is thenable/awaitable, if you just want\n   * an array of fully resolved results, but you can also access the raw results\n   * immediately by examining the additional `queries` and `results` properties of\n   * the `RefetchQueriesResult<TResult> object`.\n   */\n  export interface RefetchQueriesResult<TResult>\n    extends Promise<RefetchQueriesPromiseResults<TResult>>,\n      RefetchQueriesResult.AdditionalProperties<TResult> {}\n\n  export namespace RefetchQueriesResult {\n    export interface AdditionalProperties<TResult> {\n      /**\n       * An array of ObservableQuery objects corresponding 1:1 to TResult values\n       * in the results arrays (both the `result` property and the resolved value).\n       */\n      queries: ObservableQuery<any>[];\n      /**\n       * An array of results that were either returned by `onQueryUpdated`, or provided by default in the absence of `onQueryUpdated`, including pending promises.\n       *\n       * If `onQueryUpdated` returns `false` for a given query, no result is provided for that query.\n       *\n       * If `onQueryUpdated` returns `true`, the resulting `Promise<ApolloQueryResult<any>>` is included in the `results` array instead of `true`.\n       */\n      results: InternalRefetchQueriesResult<TResult>[];\n    }\n  }\n\n  export type SubscribeOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#query:member} */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: FetchPolicy;\n\n    /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#extensions:member} */\n    extensions?: Record<string, any>;\n  } & VariablesOption<NoInfer<TVariables>>;\n\n  export interface SubscribeResult<TData = unknown> {\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#data:member} */\n    data: TData | undefined;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#error:member} */\n    error?: ErrorLike;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#extensions:member} */\n    extensions?: Record<string, unknown>;\n  }\n\n  export type WatchFragmentOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = ApolloCache.WatchFragmentOptions<TData, TVariables>;\n\n  export type WatchFragmentResult<TData = unknown> =\n    ApolloCache.WatchFragmentResult<TData>;\n\n  /**\n   * Watched query options.\n   */\n  export type WatchQueryOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#nextFetchPolicy:member} */\n    nextFetchPolicy?:\n      | WatchQueryFetchPolicy\n      | ((\n          this: WatchQueryOptions<TData, TVariables>,\n          currentFetchPolicy: WatchQueryFetchPolicy,\n          context: NextFetchPolicyContext<TData, TVariables>\n        ) => WatchQueryFetchPolicy);\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#initialFetchPolicy:member} */\n    initialFetchPolicy?: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n    refetchWritePolicy?: RefetchWritePolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#pollInterval:member} */\n    pollInterval?: number;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n    notifyOnNetworkStatusChange?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n    returnPartialData?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skipPollAttempt:member} */\n    skipPollAttempt?: () => boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#query:member} */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  } & VariablesOption<NoInfer<TVariables>>;\n\n  namespace Base {\n    export interface ReadQueryOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > {\n      /**\n       * The GraphQL query shape to be used constructed using the `gql` template\n       * string tag. The query will be used to determine the\n       * shape of the data to be read.\n       */\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n      /**\n       * The root id to be used. Defaults to \"ROOT_QUERY\", which is the ID of the\n       * root query object. This property makes `readQuery` capable of reading data\n       * from any object in the cache.\n       */\n      id?: string;\n\n      /**\n       * Whether to return incomplete data rather than null.\n       * @defaultValue false\n       */\n      returnPartialData?: boolean;\n\n      /**\n       * Whether to read from optimistic or non-optimistic cache data.\n       * This option should be preferred over the `optimistic` parameter of the\n       * `readQuery` method.\n       * @defaultValue false\n       */\n      optimistic?: boolean;\n    }\n  }\n  export type ReadQueryOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > = Base.ReadQueryOptions<TData, TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    export interface ReadQueryOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > extends Base.ReadQueryOptions<TData, TVariables> {\n      /**\n       * Any variables that the GraphQL query may depend on.\n       */\n      variables?: TVariables;\n    }\n  }\n\n  namespace Base {\n    export interface ReadFragmentOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > {\n      /**\n       * The root id to be used. This id should take the same form as the\n       * value returned by the `cache.identify` function. If a value with your\n       * id does not exist in the store, `null` will be returned.\n       */\n      id?: string;\n\n      /**\n       * A GraphQL document created using the `gql` template string tag\n       * with one or more fragments which will be used to determine\n       * the shape of data to read. If you provide more than one fragment in this\n       * document then you must also specify `fragmentName` to specify which\n       * fragment is the root fragment.\n       */\n      fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n      /**\n       * The name of the fragment in your GraphQL document to be used. If you do\n       * not provide a `fragmentName` and there is only one fragment in your\n       * `fragment` document then that fragment will be used.\n       */\n      fragmentName?: string;\n\n      /**\n       * Whether to return incomplete data rather than null.\n       * @defaultValue false\n       */\n      returnPartialData?: boolean;\n      /**\n       * Whether to read from optimistic or non-optimistic cache data.\n       * This option should be preferred over the `optimistic` parameter of the\n       * `readFragment` method.\n       * @defaultValue false\n       */\n      optimistic?: boolean;\n    }\n  }\n  export type ReadFragmentOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > = Base.ReadFragmentOptions<TData, TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    export interface WriteQueryOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > extends Base.WriteQueryOptions<TData, TVariables> {\n      /**\n       * Any variables that your GraphQL fragments depend on.\n       */\n      variables?: TVariables;\n    }\n  }\n\n  namespace Base {\n    export interface WriteQueryOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > {\n      /**\n       * The GraphQL query shape to be used constructed using the `gql` template\n       * string tag. The query will be used to determine the\n       * shape of the data to be read.\n       */\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n      /**\n       * The root id to be used. Defaults to \"ROOT_QUERY\", which is the ID of the\n       * root query object. This property makes writeQuery capable of writing data\n       * to any object in the cache.\n       */\n      id?: string;\n      /**\n       * The data to write to the store.\n       */\n      data: Unmasked<TData>;\n      /**\n       * Whether to notify query watchers.\n       * @defaultValue true\n       */\n      broadcast?: boolean;\n      /**\n       * When true, ignore existing field data rather than merging it with\n       * incoming data.\n       * @defaultValue false\n       */\n      overwrite?: boolean;\n    }\n  }\n  export type WriteQueryOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > = Base.WriteQueryOptions<TData, TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    export interface WriteQueryOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > extends Base.WriteQueryOptions<TData, TVariables> {\n      /**\n       * Any variables that the GraphQL query may depend on.\n       */\n      variables?: TVariables;\n    }\n  }\n\n  namespace Base {\n    export interface WriteFragmentOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > {\n      /**\n       * The root id to be used. This id should take the same form as the\n       * value returned by the `cache.identify` function. If a value with your\n       * id does not exist in the store, `null` will be returned.\n       */\n      id?: string;\n\n      /**\n       * A GraphQL document created using the `gql` template string tag from\n       * `graphql-tag` with one or more fragments which will be used to determine\n       * the shape of data to read. If you provide more than one fragment in this\n       * document then you must also specify `fragmentName` to specify which\n       * fragment is the root fragment.\n       */\n      fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n      /**\n       * The name of the fragment in your GraphQL document to be used. If you do\n       * not provide a `fragmentName` and there is only one fragment in your\n       * `fragment` document then that fragment will be used.\n       */\n      fragmentName?: string;\n\n      /**\n       * The data to write to the store.\n       */\n      data: Unmasked<TData>;\n      /**\n       * Whether to notify query watchers.\n       * @defaultValue true\n       */\n      broadcast?: boolean;\n      /**\n       * When true, ignore existing field data rather than merging it with\n       * incoming data.\n       * @defaultValue false\n       */\n      overwrite?: boolean;\n    }\n  }\n  export type WriteFragmentOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > = Base.WriteFragmentOptions<TData, TVariables> &\n    VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    export interface WriteFragmentOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > extends Base.WriteFragmentOptions<TData, TVariables> {\n      /**\n       * Any variables that your GraphQL fragments depend on.\n       */\n      variables?: TVariables;\n    }\n  }\n}\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nexport class ApolloClient {\n  public link: ApolloLink;\n  public cache: ApolloCache;\n  /**\n   * @deprecated `disableNetworkFetches` has been renamed to `prioritizeCacheValues`.\n   */\n  public disableNetworkFetches!: never;\n\n  public set prioritizeCacheValues(value: boolean) {\n    this.queryManager.prioritizeCacheValues = value;\n  }\n\n  /**\n   * Whether to prioritize cache values over network results when `query` or `watchQuery` is called.\n   * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"` fetchPolicy into a `\"cache-first\"` fetchPolicy,\n   * but without influencing the `fetchPolicy` of the created `ObservableQuery` long-term.\n   *\n   * This can e.g. be used to prioritize the cache during the first render after SSR.\n   */\n  public get prioritizeCacheValues() {\n    return this.queryManager.prioritizeCacheValues;\n  }\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: ApolloClient.DefaultOptions;\n  public readonly devtoolsConfig: ApolloClient.DevtoolsOptions;\n\n  private queryManager: QueryManager;\n  private devToolsHookCb?: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   *\n   * ```js\n   * import { ApolloClient, InMemoryCache } from \"@apollo/client\";\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: \"http://localhost:4000/\",\n   *\n   *   // Provide some optional constructor fields\n   *   name: \"react-web-client\",\n   *   version: \"1.3\",\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: \"cache-and-network\",\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  constructor(options: ApolloClient.Options) {\n    if (__DEV__) {\n      invariant(\n        options.cache,\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n\n      invariant(\n        options.link,\n        \"To initialize Apollo Client, you must specify a 'link' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    const {\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      queryDeduplication = true,\n      defaultOptions,\n      defaultContext,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      localState,\n      devtools,\n      dataMasking,\n      link,\n      incrementalHandler = new NotImplementedHandler(),\n    } = options;\n\n    this.link = link;\n    this.cache = cache;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.devtoolsConfig = {\n      ...devtools,\n      enabled: devtools?.enabled ?? __DEV__,\n    };\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.refetchObservableQueries =\n      this.refetchObservableQueries.bind(this);\n\n    this.version = version;\n\n    this.queryManager = new QueryManager({\n      client: this,\n      defaultOptions: this.defaultOptions,\n      defaultContext,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      dataMasking: !!dataMasking,\n      clientOptions: options,\n      incrementalHandler,\n      assumeImmutableResults,\n      onBroadcast:\n        this.devtoolsConfig.enabled ?\n          () => {\n            if (this.devToolsHookCb) {\n              this.devToolsHookCb();\n            }\n          }\n        : void 0,\n      localState,\n    });\n\n    this.prioritizeCacheValues = ssrMode || ssrForceFetchDelay > 0;\n    if (ssrForceFetchDelay) {\n      setTimeout(() => {\n        this.prioritizeCacheValues = false;\n      }, ssrForceFetchDelay);\n    }\n\n    if (this.devtoolsConfig.enabled) this.connectToDevTools();\n  }\n\n  private connectToDevTools() {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    type DevToolsConnector = {\n      push(client: ApolloClient): void;\n    };\n    const windowWithDevTools = window as Window & {\n      [devtoolsSymbol]?: DevToolsConnector;\n      __APOLLO_CLIENT__?: ApolloClient;\n    };\n    const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n    (windowWithDevTools[devtoolsSymbol] =\n      windowWithDevTools[devtoolsSymbol] || ([] as DevToolsConnector)).push(\n      this\n    );\n    windowWithDevTools.__APOLLO_CLIENT__ = this;\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      if (\n        window.document &&\n        window.top === window.self &&\n        /^(https?|file):$/.test(window.location.protocol)\n      ) {\n        setTimeout(() => {\n          if (!(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n            const nav = window.navigator;\n            const ua = nav && nav.userAgent;\n            let url: string | undefined;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url =\n                  \"https://chrome.google.com/webstore/detail/\" +\n                  \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url =\n                  \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              invariant.log(\n                \"Download the Apollo DevTools for a better development \" +\n                  \"experience: %s\",\n                url\n              );\n            }\n          }\n        }, 10000);\n      }\n    }\n  }\n\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n\n  /**\n   * The configured `LocalState` instance used to enable the use of `@client`\n   * fields.\n   */\n  get localState(): LocalState | undefined {\n    return this.queryManager.localState;\n  }\n\n  set localState(localState: LocalState) {\n    this.queryManager.localState = localState;\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   *\n   * This method performs aggressive cleanup to prevent memory leaks:\n   *\n   * - Unsubscribes all active `ObservableQuery` instances by emitting a `completed` event\n   * - Rejects all currently running queries with \"QueryManager stopped while query was in flight\"\n   * - Removes all queryRefs from the suspense cache\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * `cache.identify`. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will _not_ be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>\n  ): ObservableQuery<TData, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(\n        this.defaultOptions.watchQuery as Partial<\n          ApolloClient.WatchQueryOptions<TData, TVariables>\n        >,\n        options\n      );\n    }\n\n    return this.queryManager.watchQuery<TData, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.QueryOptions<TData, TVariables>\n  ): Promise<ApolloClient.QueryResult<MaybeMasked<TData>>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    if (__DEV__) {\n      invariant(\n        (options.fetchPolicy as WatchQueryFetchPolicy) !== \"cache-and-network\",\n        \"The cache-and-network fetchPolicy does not work with client.query, because \" +\n          \"client.query can only return a single result. Please use client.watchQuery \" +\n          \"to receive multiple results from the cache and the network, or consider \" +\n          \"using a different fetchPolicy, such as cache-first or network-only.\"\n      );\n\n      invariant(\n        (options.fetchPolicy as WatchQueryFetchPolicy) !== \"standby\",\n        \"The standby fetchPolicy does not work with client.query, because \" +\n          \"standby does not fetch. Consider using a different fetchPolicy, such \" +\n          \"as cache-first or network-only.\"\n      );\n\n      invariant(\n        options.query,\n        \"query option is required. You must specify your GraphQL document \" +\n          \"in the query option.\"\n      );\n\n      invariant(\n        options.query.kind === \"Document\",\n        'You must wrap the query string in a \"gql\" tag.'\n      );\n\n      invariant(\n        !(options as any).returnPartialData,\n        \"returnPartialData option only supported on watchQuery.\"\n      );\n\n      invariant(\n        !(options as any).pollInterval,\n        \"pollInterval option only supported on watchQuery.\"\n      );\n\n      invariant(\n        !(options as any).notifyOnNetworkStatusChange,\n        \"notifyOnNetworkStatusChange option only supported on watchQuery.\"\n      );\n    }\n\n    return this.queryManager.query<TData, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TCache extends ApolloCache = ApolloCache,\n  >(\n    options: ApolloClient.MutateOptions<TData, TVariables, TCache>\n  ): Promise<ApolloClient.MutateResult<MaybeMasked<TData>>> {\n    const optionsWithDefaults = mergeOptions(\n      compact(\n        {\n          fetchPolicy: \"network-only\" as MutationFetchPolicy,\n          errorPolicy: \"none\" as ErrorPolicy,\n        },\n        this.defaultOptions.mutate\n      ),\n      options\n    ) as ApolloClient.MutateOptions<TData, TVariables, TCache> & {\n      fetchPolicy: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n    };\n\n    if (__DEV__) {\n      invariant(\n        optionsWithDefaults.mutation,\n        \"The `mutation` option is required. Please provide a GraphQL document in the `mutation` option.\"\n      );\n\n      invariant(\n        optionsWithDefaults.fetchPolicy === \"network-only\" ||\n          optionsWithDefaults.fetchPolicy === \"no-cache\",\n        \"Mutations only support 'network-only' or 'no-cache' fetch policies. The default 'network-only' behavior automatically writes mutation results to the cache. Passing 'no-cache' skips the cache write.\"\n      );\n    }\n\n    checkDocument(optionsWithDefaults.mutation, OperationTypeNode.MUTATION);\n\n    return this.queryManager.mutate<TData, TVariables, TCache>(\n      optionsWithDefaults\n    );\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  public subscribe<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.SubscribeOptions<TData, TVariables>\n  ): SubscriptionObservable<ApolloClient.SubscribeResult<MaybeMasked<TData>>> {\n    const cause = {};\n\n    const observable =\n      this.queryManager.startGraphQLSubscription<TData>(options);\n\n    const mapped = observable.pipe(\n      map((result) => ({\n        ...result,\n        data: this.queryManager.maskOperation({\n          document: options.query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          cause,\n        }),\n      }))\n    );\n\n    return Object.assign(mapped, { restart: observable.restart });\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `cache.identify`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadQueryOptions<TData, TVariables>\n  ): Unmasked<TData> | null;\n\n  /**\n   * {@inheritDoc @apollo/client!ApolloClient#readQuery:member(1)}\n   *\n   * @deprecated Pass the `optimistic` argument as part of the first argument\n   * instead of passing it as a separate option.\n   */\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadQueryOptions<TData, TVariables>,\n    /**\n     * @deprecated Pass the `optimistic` argument as part of the first argument\n     * instead of passing it as a separate option.\n     */\n    optimistic: boolean\n  ): Unmasked<TData> | null;\n\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadQueryOptions<TData, TVariables>,\n    optimistic: boolean = false\n  ): Unmasked<TData> | null {\n    return this.cache.readQuery<TData, TVariables>(\n      { ...options, query: this.transform(options.query) },\n      optimistic\n    );\n  }\n\n  /**\n   * Watches the cache store of the fragment according to the options specified\n   * and returns an `Observable`. We can subscribe to this\n   * `Observable` and receive updated results through an\n   * observer when the cache store changes.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @since 3.10.0\n   * @param options - An object of type `WatchFragmentOptions` that allows\n   * the cache to identify the fragment and optionally specify whether to react\n   * to optimistic updates.\n   */\n\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables>\n  ): Observable<ApolloClient.WatchFragmentResult<MaybeMasked<TData>>> {\n    const dataMasking = this.queryManager.dataMasking;\n\n    return this.cache\n      .watchFragment({\n        ...options,\n        fragment: this.transform(options.fragment, dataMasking),\n      })\n      .pipe(\n        map((result) => {\n          // The transform will remove fragment spreads from the fragment\n          // document when dataMasking is enabled. The `maskFragment` function\n          // remains to apply warnings to fragments marked as\n          // `@unmask(mode: \"migrate\")`. Since these warnings are only applied\n          // in dev, we can skip the masking algorithm entirely for production.\n          if (__DEV__) {\n            if (dataMasking) {\n              const data = this.queryManager.maskFragment({\n                ...options,\n                data: result.data,\n              });\n              return { ...result, data } as ApolloClient.WatchFragmentResult<\n                MaybeMasked<TData>\n              >;\n            }\n          }\n\n          return result as ApolloClient.WatchFragmentResult<MaybeMasked<TData>>;\n        })\n      );\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadFragmentOptions<TData, TVariables>\n  ): Unmasked<TData> | null;\n  /**\n   * {@inheritDoc @apollo/client!ApolloClient#readFragment:member(1)}\n   *\n   * @deprecated Pass the `optimistic` argument as part of the first argument\n   * instead of passing it as a separate option.\n   */\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadFragmentOptions<TData, TVariables>,\n    optimistic: boolean\n  ): Unmasked<TData> | null;\n\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadFragmentOptions<TData, TVariables>,\n    optimistic: boolean = false\n  ): Unmasked<TData> | null {\n    return this.cache.readFragment<TData, TVariables>(\n      { ...options, fragment: this.transform(options.fragment) },\n      optimistic\n    );\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `cache.identify` then use `writeFragment`.\n   */\n  public writeQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WriteQueryOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeQuery<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WriteFragmentOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeFragment<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(\n    request: ApolloLink.Request\n  ): Observable<ApolloLink.Result<unknown>> {\n    return execute(this.link, request, { client: this });\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. You’ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` _will_ refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloClient.QueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: false,\n        })\n      )\n      .then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn())))\n      .then(() => this.refetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: true,\n        })\n      )\n      .then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` _will_ refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   *\n   * Note: `cache-only` queries are not refetched by this function.\n   *\n   * @deprecated Please use `refetchObservableQueries` instead.\n   */\n  public reFetchObservableQueries: (\n    includeStandby?: boolean\n  ) => Promise<ApolloClient.QueryResult<any>[]>;\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `refetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `refetchObservableQueries()` _will_ refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   *\n   * Note: `cache-only` queries are not refetched by this function.\n   */\n  public refetchObservableQueries(\n    includeStandby?: boolean\n  ): Promise<ApolloClient.QueryResult<any>[]> {\n    return this.queryManager.refetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"refetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` _will_ refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache = ApolloCache,\n    TResult = Promise<ApolloClient.QueryResult<any>>,\n  >(\n    options: ApolloClient.RefetchQueriesOptions<TCache, TResult>\n  ): ApolloClient.RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(\n      options as ApolloClient.RefetchQueriesOptions<ApolloCache, TResult>\n    );\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as ApolloClient.RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch((error) => {\n      invariant.debug(\n        `In client.refetchQueries, Promise.all promise rejected with error %o`,\n        error\n      );\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Set`.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   *\n   * Note: This method only returns queries that have active subscribers. Queries\n   * without subscribers are not tracked by the client.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\"\n  ): Set<ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   *\n   * @remarks\n   *\n   * This can be useful for debugging in order to inspect the full state of the\n   * cache.\n   *\n   * @param optimistic - Determines whether the result contains data from the\n   * optimistic layer\n   */\n  public extract(optimistic?: boolean) {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: unknown) {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = newLink;\n  }\n\n  public get defaultContext() {\n    return this.queryManager.defaultContext;\n  }\n\n  private maskedFragmentTransform = new DocumentTransform(\n    removeMaskedFragmentSpreads\n  );\n\n  private transform(document: DocumentNode, dataMasking = false) {\n    const transformed = this.queryManager.transform(document);\n    return dataMasking ?\n        this.maskedFragmentTransform.transformDocument(transformed)\n      : transformed;\n  }\n\n  /**\n   * @experimental\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   * For more details, see [Memory Management](https://www.apollographql.com/docs/react/caching/memory-management/#measuring-cache-usage)\n   *\n   * @example\n   *\n   * ```ts\n   * console.log(client.getMemoryInternals());\n   * ```\n   *\n   * Logs output in the following JSON format:\n   * @example\n   *\n   * ```json\n   * {\n   *   \"limits\": {\n   *     \"canonicalStringify\": 1000,\n   *     \"print\": 2000,\n   *     \"documentTransform.cache\": 2000,\n   *     \"queryManager.getDocumentInfo\": 2000,\n   *     \"PersistedQueryLink.persistedQueryHashes\": 2000,\n   *     \"fragmentRegistry.transform\": 2000,\n   *     \"fragmentRegistry.lookup\": 1000,\n   *     \"fragmentRegistry.findFragmentSpreads\": 4000,\n   *     \"cache.fragmentQueryDocuments\": 1000,\n   *     \"removeTypenameFromVariables.getVariableDefinitions\": 2000,\n   *     \"inMemoryCache.maybeBroadcastWatch\": 5000,\n   *     \"inMemoryCache.executeSelectionSet\": 10000,\n   *     \"inMemoryCache.executeSubSelectedArray\": 5000\n   *   },\n   *   \"sizes\": {\n   *     \"canonicalStringify\": 4,\n   *     \"print\": 14,\n   *     \"addTypenameDocumentTransform\": [\n   *       {\n   *         \"cache\": 14\n   *       }\n   *     ],\n   *     \"queryManager\": {\n   *       \"getDocumentInfo\": 14,\n   *       \"documentTransforms\": [\n   *         {\n   *           \"cache\": 14\n   *         },\n   *         {\n   *           \"cache\": 14\n   *         }\n   *       ]\n   *     },\n   *     \"fragmentRegistry\": {\n   *       \"findFragmentSpreads\": 34,\n   *       \"lookup\": 20,\n   *       \"transform\": 14\n   *     },\n   *     \"cache\": {\n   *       \"fragmentQueryDocuments\": 22\n   *     },\n   *     \"inMemoryCache\": {\n   *       \"executeSelectionSet\": 4345,\n   *       \"executeSubSelectedArray\": 1206,\n   *       \"maybeBroadcastWatch\": 32\n   *     },\n   *     \"links\": [\n   *       {\n   *         \"PersistedQueryLink\": {\n   *           \"persistedQueryHashes\": 14\n   *         }\n   *       },\n   *       {\n   *         \"removeTypenameFromVariables\": {\n   *           \"getVariableDefinitions\": 14\n   *         }\n   *       }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  public declare getMemoryInternals?: typeof getApolloClientMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n", "import {\n  CombinedProtocolErrors,\n  PROTOCOL_ERRORS_SYMBOL,\n  ServerError,\n  ServerParseError,\n} from \"@apollo/client/errors\";\nimport type { ApolloLink, ApolloPayloadResult } from \"@apollo/client/link\";\nimport { isNonNullObject } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n * This function detects an Apollo payload result before it is transformed\n * into a FetchResult via HttpLink; it cannot detect an ApolloPayloadResult\n * once it leaves the link chain.\n */\nfunction isApolloPayloadResult(value: unknown): value is ApolloPayloadResult {\n  return isNonNullObject(value) && \"payload\" in value;\n}\n\nasync function* consumeMultipartBody(\n  response: Response\n): AsyncGenerator<string, void, void> {\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const match = contentType?.match(\n    /*\n      ;\\s*boundary=                # Match the boundary parameter\n      (?:                          # either\n        '([^']*)'                  # a string starting with ' doesn't contain ', ends with '\n        |                          # or\n        \"([^\"]*)\"                  # a string starting with \" doesn't contain \", ends with \"\n        |                          # or\n        ([^\"'].*?)                 # a string that doesn't start with ' or \", parsed non-greedily\n        )                          # end of the group\n      \\s*                          # optional whitespace\n      (?:;|$)                        # match a semicolon or end of string\n    */\n    /;\\s*boundary=(?:'([^']+)'|\"([^\"]+)\"|([^\"'].+?))\\s*(?:;|$)/i\n  );\n  const boundary = \"\\r\\n--\" + (match?.findLast((val) => !!val) || \"-\");\n  let buffer = \"\";\n  invariant(\n    response.body && typeof response.body.getReader === \"function\",\n    \"Unknown type for `response.body`. Please use a `fetch` implementation that is WhatWG-compliant and that uses WhatWG ReadableStreams for `body`.\"\n  );\n\n  const stream = response.body;\n  const reader = stream.getReader();\n  let done = false;\n  let encounteredBoundary = false;\n  let value: Uint8Array<ArrayBufferLike> | string | undefined;\n\n  // check to see if we received the final boundary, which is a normal boundary followed by \"--\"\n  // as described in https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1\n  const passedFinalBoundary = () =>\n    encounteredBoundary && buffer[0] == \"-\" && buffer[1] == \"-\";\n\n  try {\n    while (!done) {\n      ({ value, done } = await reader.read());\n      const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n      const searchFrom = buffer.length - boundary.length + 1;\n      buffer += chunk;\n      let bi = buffer.indexOf(boundary, searchFrom);\n      while (bi > -1 && !passedFinalBoundary()) {\n        encounteredBoundary = true;\n        let message: string;\n        [message, buffer] = [\n          buffer.slice(0, bi),\n          buffer.slice(bi + boundary.length),\n        ];\n        const i = message.indexOf(\"\\r\\n\\r\\n\");\n        const headers = parseHeaders(message.slice(0, i));\n        const contentType = headers[\"content-type\"];\n        if (\n          contentType &&\n          contentType.toLowerCase().indexOf(\"application/json\") === -1\n        ) {\n          throw new Error(\n            \"Unsupported patch content type: application/json is required.\"\n          );\n        }\n        // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n        // this is going to be `JSON.parse`d there is no need.\n        const body = message.slice(i);\n\n        if (body) {\n          yield body;\n        }\n        bi = buffer.indexOf(boundary);\n      }\n      if (passedFinalBoundary()) {\n        return;\n      }\n    }\n    throw new Error(\"premature end of multipart body\");\n  } finally {\n    reader.cancel();\n  }\n}\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>,\n>(response: Response, nextValue: (value: T) => void) {\n  for await (const body of consumeMultipartBody(response)) {\n    const result = parseJsonEncoding(response, body);\n    if (Object.keys(result).length == 0) continue;\n    if (isApolloPayloadResult(result)) {\n      if (Object.keys(result).length === 1 && result.payload === null) {\n        return;\n      }\n      let next = { ...result.payload };\n      if (\"errors\" in result) {\n        next.extensions = {\n          ...next.extensions,\n          [PROTOCOL_ERRORS_SYMBOL]: new CombinedProtocolErrors(\n            result.errors ?? []\n          ),\n        };\n      }\n      nextValue(next as T);\n    } else {\n      nextValue(result);\n    }\n  }\n}\n\nfunction parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nfunction parseJsonEncoding(response: Response, bodyText: string) {\n  if (response.status >= 300) {\n    throw new ServerError(\n      `Response not successful: Received status code ${response.status}`,\n      { response, bodyText }\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText);\n  } catch (err) {\n    throw new ServerParseError(err, { response, bodyText });\n  }\n}\n\nfunction parseGraphQLResponseJsonEncoding(\n  response: Response,\n  bodyText: string\n) {\n  try {\n    return JSON.parse(bodyText);\n  } catch (err) {\n    throw new ServerParseError(err, { response, bodyText });\n  }\n}\n\nfunction parseResponse(response: Response, bodyText: string) {\n  const contentType = response.headers.get(\"content-type\");\n\n  if (contentType?.includes(\"application/graphql-response+json\")) {\n    return parseGraphQLResponseJsonEncoding(response, bodyText);\n  }\n\n  return parseJsonEncoding(response, bodyText);\n}\n\nexport function parseAndCheckHttpResponse(\n  operations: ApolloLink.Operation | ApolloLink.Operation[]\n) {\n  return (response: Response) =>\n    response.text().then((bodyText) => {\n      const result = parseResponse(response, bodyText);\n\n      if (\n        !Array.isArray(result) &&\n        !hasOwnProperty.call(result, \"data\") &&\n        !hasOwnProperty.call(result, \"errors\")\n      ) {\n        throw new ServerError(\n          `Server response was malformed for query '${\n            Array.isArray(operations) ?\n              operations.map((op) => op.operationName)\n            : operations.operationName\n          }'.`,\n          { response, bodyText }\n        );\n      }\n      return result;\n    });\n}\n", "import type { ApolloLink } from \"@apollo/client/link\";\nimport { print } from \"@apollo/client/utilities\";\n\nimport type { BaseHttpLink } from \"./BaseHttpLink.js\";\n\ninterface HttpConfig {\n  http?: BaseHttpLink.HttpOptions;\n  options?: any;\n  headers?: Record<string, string>;\n  credentials?: any;\n}\n\nconst defaultHttpOptions: BaseHttpLink.HttpOptions = {\n  includeQuery: true,\n  includeExtensions: true,\n  preserveHeaderCase: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: \"application/graphql-response+json,application/json;q=0.9\",\n  // The content-type header describes the type of the body of the request, and\n  // so it typically only is sent with requests that actually have bodies. One\n  // could imagine that Apollo Client would remove this header when constructing\n  // a GET request (which has no body), but we historically have not done that.\n  // This means that browsers will preflight all Apollo Client requests (even\n  // GET requests). Apollo Server's CSRF prevention feature (introduced in\n  // AS3.7) takes advantage of this fact and does not block requests with this\n  // header. If you want to drop this header from GET requests, then you should\n  // probably replace it with a `apollo-require-preflight` header, or servers\n  // with CSRF prevention enabled might block your GET request. See\n  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n  // for more details.\n  \"content-type\": \"application/json\",\n};\n\nconst defaultOptions = {\n  method: \"POST\",\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const defaultPrinter: BaseHttpLink.Printer = (ast, printer) =>\n  printer(ast);\n\nexport function selectHttpOptionsAndBody(\n  operation: ApolloLink.Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) {\n  configs.unshift(fallbackConfig);\n  return selectHttpOptionsAndBodyInternal(\n    operation,\n    defaultPrinter,\n    ...configs\n  );\n}\n\nexport function selectHttpOptionsAndBodyInternal(\n  operation: ApolloLink.Operation,\n  printer: BaseHttpLink.Printer,\n  ...configs: HttpConfig[]\n) {\n  let options = {} as HttpConfig & Record<string, any>;\n  let http = {} as BaseHttpLink.HttpOptions;\n\n  configs.forEach((config) => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n\n    if (config.credentials) {\n      options.credentials = config.credentials;\n    }\n\n    options.headers!.accept = (config.http?.accept || [])\n      .concat(options.headers!.accept)\n      .join(\",\");\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  options.headers = removeDuplicateHeaders(\n    options.headers!,\n    http.preserveHeaderCase\n  );\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: BaseHttpLink.Body = { operationName, variables };\n\n  if (http.includeExtensions && Object.keys(extensions || {}).length)\n    (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = printer(query, print);\n\n  return {\n    options,\n    body,\n  };\n}\n\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(\n  headers: Record<string, string>,\n  preserveHeaderCase: boolean | undefined\n): typeof headers {\n  // If we're not preserving the case, just remove duplicates w/ normalization.\n  if (!preserveHeaderCase) {\n    const normalizedHeaders: Record<string, string> = {};\n    Object.keys(Object(headers)).forEach((name) => {\n      normalizedHeaders[name.toLowerCase()] = headers[name];\n    });\n    return normalizedHeaders;\n  }\n\n  // If we are preserving the case, remove duplicates w/ normalization,\n  // preserving the original name.\n  // This allows for non-http-spec-compliant servers that expect intentionally\n  // capitalized header names (See #6741).\n  const headerData: Record<string, { originalName: string; value: string }> =\n    {};\n  Object.keys(Object(headers)).forEach((name) => {\n    headerData[name.toLowerCase()] = {\n      originalName: name,\n      value: headers[name],\n    };\n  });\n\n  const normalizedHeaders: Record<string, string> = {};\n  Object.keys(headerData).forEach((name) => {\n    normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n  });\n  return normalizedHeaders;\n}\n", "import { invariant } from \"@apollo/client/utilities/invariant\";\n\nexport const checkFetcher = (fetcher: typeof fetch | undefined) => {\n  invariant(\n    fetcher || typeof fetch !== \"undefined\",\n    `\n\"fetch\" has not been found globally and no fetcher has been \\\nconfigured. To fix this, install a fetch package (like \\\nhttps://www.npmjs.com/package/cross-fetch), instantiate the \\\nfetcher, and pass it into your HttpLink constructor. For example:\n\nimport fetch from 'cross-fetch';\nimport { ApolloClient, HttpLink } from '@apollo/client';\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: '/graphql', fetch })\n});\n    `\n  );\n};\n", "/**\n * @deprecated\n * This is not used internally any more and will be removed in\n * the next major version of Apollo Client.\n */\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === \"undefined\")\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n", "import type { ApolloLink } from \"@apollo/client/link\";\n\nexport const selectURI = (\n  operation: ApolloLink.Operation,\n  fallbackURI?: string | ((operation: ApolloLink.Operation) => string)\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === \"function\") {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || \"/graphql\";\n  }\n};\n", "import type { BaseHttpLink } from \"./BaseHttpLink.js\";\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI: string, body: BaseHttpLink.Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams: string[] = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if (\"query\" in body) {\n    addQueryParam(\"query\", body.query!);\n  }\n  if (body.operationName) {\n    addQueryParam(\"operationName\", body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = JSON.stringify(body.variables);\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"variables\", serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = JSON.stringify(body.extensions);\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"extensions\", serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = \"\",\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf(\"#\");\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n  return { newURI };\n}\n", "import type { ASTNode, print } from \"graphql\";\nimport { Observable } from \"rxjs\";\n\nimport { ApolloLink } from \"@apollo/client/link\";\nimport { filterOperationVariables } from \"@apollo/client/link/utils\";\nimport {\n  isMutationOperation,\n  isSubscriptionOperation,\n} from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { compact } from \"@apollo/client/utilities/internal\";\nimport { maybe } from \"@apollo/client/utilities/internal/globals\";\n\nimport { checkFetcher } from \"./checkFetcher.js\";\nimport {\n  parseAndCheckHttpResponse,\n  readMultipartBody,\n} from \"./parseAndCheckHttpResponse.js\";\nimport { rewriteURIForGET } from \"./rewriteURIForGET.js\";\nimport {\n  defaultPrinter,\n  fallbackHttpConfig,\n  selectHttpOptionsAndBodyInternal,\n} from \"./selectHttpOptionsAndBody.js\";\nimport { selectURI } from \"./selectURI.js\";\n\nconst backupFetch = maybe(() => fetch);\nfunction noop() {}\n\nexport declare namespace BaseHttpLink {\n  /**\n   * Options passed to `BaseHttpLink` through [request context](https://apollographql.com/docs/react/api/link/introduction#managing-context). Previous\n   * non-terminating links in the link chain also can set these values to\n   * customize the behavior of `BaseHttpLink` for each operation.\n   *\n   * > [!NOTE]\n   * > Some of these values can also be provided to the `HttpLink` constructor.\n   * > If a value is provided to both, the value in `context` takes precedence.\n   */\n  interface ContextOptions {\n    /** {@inheritDoc @apollo/client/link/http!BaseHttpLink.Shared.Options#uri:member} */\n    uri?: string | BaseHttpLink.UriFunction;\n\n    /** {@inheritDoc @apollo/client/link/http!BaseHttpLink.Shared.Options#headers:member} */\n    headers?: Record<string, string>;\n\n    /** {@inheritDoc @apollo/client/link/http!BaseHttpLink.Shared.Options#credentials:member} */\n    credentials?: RequestCredentials;\n\n    /** {@inheritDoc @apollo/client/link/http!BaseHttpLink.Shared.Options#fetchOptions:member} */\n    fetchOptions?: RequestInit;\n\n    /**\n     * An object that configures advanced functionality, such as support for\n     * persisted queries.\n     */\n    http?: BaseHttpLink.HttpOptions;\n  }\n\n  /**\n   * Options passed to `BaseHttpLink` through the `http` property of a request\n   * context.\n   */\n  export interface HttpOptions {\n    /** {@inheritDoc @apollo/client/link/http!BaseHttpLink.Shared.Options#includeExtensions:member} */\n    includeExtensions?: boolean;\n\n    /**\n     * If `false`, the GraphQL query string is not included in the request. Set\n     * this option if you're sending a request that uses a [persisted query](https://www.apollographql.com/docs/react/api/link/persisted-queries/).\n     *\n     * @defaultValue `true`\n     */\n    includeQuery?: boolean;\n\n    /** {@inheritDoc @apollo/client/link/http!BaseHttpLink.Shared.Options#preserveHeaderCase:member} */\n    preserveHeaderCase?: boolean;\n\n    /**\n     * A list of additional `accept` headers to include in the request,\n     * as defined in https://datatracker.ietf.org/doc/html/rfc7231#section-5.3.2\n     *\n     * @example\n     *\n     * ```json\n     * [\"application/custom+json;q=1.0\"]\n     * ```\n     */\n    accept?: string[];\n  }\n\n  export namespace Shared {\n    /** These options are shared between `BaseHttpLink` and `BaseBatchHttpLink` */\n    export interface Options {\n      /**\n       * The URL of the GraphQL endpoint to send requests to. Can also be a\n       * function that accepts an `ApolloLink.Operation` object and returns the\n       * string URL to use for that operation.\n       *\n       * @defaultValue \"/graphql\"\n       */\n      uri?: string | BaseHttpLink.UriFunction;\n\n      /**\n       * If `true`, includes the `extensions` field in operations sent to your\n       * GraphQL endpoint.\n       *\n       * @defaultValue true\n       */\n      includeExtensions?: boolean;\n\n      /**\n       * A function to use instead of calling the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) directly\n       * when sending HTTP requests to your GraphQL endpoint. The function must\n       * conform to the signature of `fetch`.\n       *\n       * By default, the Fetch API is used unless it isn't available in your\n       * runtime environment.\n       *\n       * See [Customizing `fetch`](https://apollographql.com/docs/react/api/link/introduction#customizing-fetch).\n       */\n      fetch?: typeof fetch;\n\n      /**\n       * An object representing headers to include in every HTTP request.\n       *\n       * @example\n       *\n       * ```json\n       * {\n       *   \"Authorization\": \"Bearer 1234\"\n       * }\n       * ```\n       */\n      headers?: Record<string, string>;\n\n      /**\n       * If `true`, header names won't be automatically normalized to lowercase.\n       * This allows for non-http-spec-compliant servers that might expect\n       * capitalized header names.\n       *\n       * @defaultValue false\n       */\n      preserveHeaderCase?: boolean;\n\n      /**\n       * The credentials policy to use for each `fetch` call.\n       */\n      credentials?: RequestCredentials;\n\n      /**\n       * Any overrides of the fetch options argument to pass to the fetch call.\n       *\n       * An object containing options to use for each call to `fetch`. If a\n       * particular option is not included in this object, the default value of\n       * that option is used.\n       *\n       * > [!NOTE]\n       * > If you set `fetchOptions.method` to `GET`, `HttpLink` follows [standard\n       * > GraphQL HTTP GET encoding](http://graphql.org/learn/serving-over-http/#get-request).\n       *\n       * See [available options](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n       */\n      fetchOptions?: RequestInit;\n\n      /**\n       * If `true`, unused variables from the operation will not be stripped from\n       * the request and will instead be sent to the GraphQL endpoint.\n       *\n       * @remarks\n       * Unused variables are likely to trigger server-side validation errors,\n       * per https://spec.graphql.org/draft/#sec-All-Variables-Used.\n       * `includeUnusedVariables` can be useful if your server deviates\n       * from the GraphQL specification by not strictly enforcing that rule.\n       *\n       * @defaultValue false\n       */\n      includeUnusedVariables?: boolean;\n      /**\n       * A function to use when transforming a GraphQL document into a string. It\n       * accepts an `ASTNode` (typically a `DocumentNode`) and the original `print`\n       * function as arguments, and is expected to return a string. This option\n       * enables you to, for example, use `stripIgnoredCharacters` to remove\n       * whitespace from queries.\n       *\n       * By default the [GraphQL `print` function](https://graphql.org/graphql-js/language/#print) is used.\n       *\n       * @example\n       *\n       * ```ts\n       * import { stripIgnoredCharacters } from \"graphql\";\n       *\n       * const httpLink = new HttpLink({\n       *   uri: \"/graphql\",\n       *   print: (ast, originalPrint) => stripIgnoredCharacters(originalPrint(ast)),\n       * });\n       * ```\n       */\n      print?: BaseHttpLink.Printer;\n    }\n  }\n\n  /**\n   * Options provided to the `BaseHttpLink` constructor.\n   *\n   * > [!NOTE]\n   * > Some of these options are also available to override in [request context](https://apollographql.com/docs/react/api/link/introduction#managing-context).\n   * > Context options override the options passed to the constructor. Treat\n   * > these options as default values that are used when the request context\n   * > does not override the value.\n   */\n  interface Options extends Shared.Options {\n    /**\n     * If `true`, the link uses an HTTP `GET` request when sending query\n     * operations to your GraphQL endpoint. Mutation operations continue to use\n     * `POST` requests. If you want all operations to use `GET` requests,\n     * set `fetchOptions.method` instead.\n     *\n     * @defaultValue false\n     */\n    useGETForQueries?: boolean;\n  }\n\n  interface Body {\n    query?: string;\n    operationName?: string;\n    variables?: Record<string, any>;\n    extensions?: Record<string, any>;\n  }\n\n  type Printer = (node: ASTNode, originalPrint: typeof print) => string;\n  type UriFunction = (operation: ApolloLink.Operation) => string;\n}\n\n/**\n * `BaseHttpLink` is a terminating link that sends a GraphQL operation to a\n * remote endpoint over HTTP. It serves as a base link to `HttpLink`.\n *\n * @remarks\n *\n * `BaseHttpLink` supports both POST and GET requests, and you can configure\n * HTTP options on a per-operation basis. You can use these options for\n * authentication, persisted queries, dynamic URIs, and other granular updates.\n *\n * > [!NOTE]\n * > Prefer using `HttpLink` over `BaseHttpLink`. Use `BaseHttpLink` when you\n * > need to disable client awareness features and would like to tree-shake\n * > the implementation of `ClientAwarenessLink` out of your app bundle.\n *\n * @example\n *\n * ```ts\n * import { BaseHttpLink } from \"@apollo/client/link/http\";\n *\n * const link = new BaseHttpLink({\n *   uri: \"http://localhost:4000/graphql\",\n *   headers: {\n *     authorization: `Bearer ${token}`,\n *   },\n * });\n * ```\n */\nexport class BaseHttpLink extends ApolloLink {\n  constructor(options: BaseHttpLink.Options = {}) {\n    let {\n      uri = \"/graphql\",\n      // use default global fetch if nothing passed in\n      fetch: preferredFetch,\n      print = defaultPrinter,\n      includeExtensions,\n      preserveHeaderCase,\n      useGETForQueries,\n      includeUnusedVariables = false,\n      ...requestOptions\n    } = options;\n\n    if (__DEV__) {\n      // Make sure at least one of preferredFetch, window.fetch, or backupFetch is\n      // defined, so requests won't fail at runtime.\n      checkFetcher(preferredFetch || backupFetch);\n    }\n\n    const linkConfig = {\n      http: compact({ includeExtensions, preserveHeaderCase }),\n      options: requestOptions.fetchOptions,\n      credentials: requestOptions.credentials,\n      headers: requestOptions.headers,\n    };\n\n    super((operation) => {\n      let chosenURI = selectURI(operation, uri);\n\n      const context = operation.getContext();\n\n      const http = { ...context.http };\n      if (isSubscriptionOperation(operation.query)) {\n        http.accept = [\n          \"multipart/mixed;boundary=graphql;subscriptionSpec=1.0\",\n          ...(http.accept || []),\n        ];\n      }\n\n      const contextConfig = {\n        http,\n        options: context.fetchOptions,\n        credentials: context.credentials,\n        headers: context.headers,\n      };\n\n      //uses fallback, link, and then context to build options\n      const { options, body } = selectHttpOptionsAndBodyInternal(\n        operation,\n        print,\n        fallbackHttpConfig,\n        linkConfig,\n        contextConfig\n      );\n\n      if (body.variables && !includeUnusedVariables) {\n        body.variables = filterOperationVariables(\n          body.variables,\n          operation.query\n        );\n      }\n\n      let controller: AbortController | undefined = new AbortController();\n      let cleanupController = () => {\n        controller = undefined;\n      };\n      if (options.signal) {\n        const externalSignal: AbortSignal = options.signal;\n        // in an ideal world we could use `AbortSignal.any` here, but\n        // React Native uses https://github.com/mysticatea/abort-controller as\n        // a polyfill for `AbortController`, and it does not support `AbortSignal.any`.\n\n        const listener = () => {\n          controller?.abort(externalSignal.reason);\n        };\n        externalSignal.addEventListener(\"abort\", listener, { once: true });\n        cleanupController = () => {\n          controller?.signal.removeEventListener(\"abort\", cleanupController);\n          controller = undefined;\n          // on cleanup, we need to stop listening to `options.signal` to avoid memory leaks\n          externalSignal.removeEventListener(\"abort\", listener);\n          cleanupController = noop;\n        };\n        // react native also does not support the addEventListener `signal` option\n        // so we have to simulate that ourself\n        controller.signal.addEventListener(\"abort\", cleanupController, {\n          once: true,\n        });\n      }\n      options.signal = controller.signal;\n\n      if (useGETForQueries && !isMutationOperation(operation.query)) {\n        options.method = \"GET\";\n      }\n\n      return new Observable((observer) => {\n        if (options.method === \"GET\") {\n          const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n          if (parseError) {\n            throw parseError;\n          }\n          chosenURI = newURI;\n        } else {\n          options.body = JSON.stringify(body);\n        }\n        // Prefer linkOptions.fetch (preferredFetch) if provided, and otherwise\n        // fall back to the *current* global window.fetch function (see issue\n        // #7832), or (if all else fails) the backupFetch function we saved when\n        // this module was first evaluated. This last option protects against the\n        // removal of window.fetch, which is unlikely but not impossible.\n        const currentFetch =\n          preferredFetch || maybe(() => fetch) || backupFetch;\n\n        const observerNext = observer.next.bind(observer);\n        currentFetch!(chosenURI, options)\n          .then((response) => {\n            operation.setContext({ response });\n            const ctype = response.headers?.get(\"content-type\");\n\n            if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n              return readMultipartBody(response, observerNext);\n            } else {\n              return parseAndCheckHttpResponse(operation)(response).then(\n                observerNext\n              );\n            }\n          })\n          .then(() => {\n            cleanupController();\n            observer.complete();\n          })\n          .catch((err) => {\n            cleanupController();\n            observer.error(err);\n          });\n\n        return () => {\n          // XXX support canceling this request\n          // https://developers.google.com/web/updates/2017/09/abortable-fetch\n          if (controller) controller.abort();\n        };\n      });\n    });\n  }\n}\n", "import { ApolloLink } from \"@apollo/client/link\";\nimport { compact } from \"@apollo/client/utilities/internal\";\n\nexport declare namespace ClientAwarenessLink {\n  /**\n   * Options passed to `ClientAwarenessLink` through [request context](https://apollographql.com/docs/react/api/link/introduction#managing-context). Previous\n   * non-terminating links in the link chain also can set these values to\n   * customize the behavior of `ClientAwarenessLink` for each operation.\n   *\n   * > [!NOTE]\n   * > Some of these values can also be provided to the `ClientAwarenessLink`\n   * > constructor. If a value is provided to both, the value in `context` takes\n   * > precedence.\n   */\n  export interface ContextOptions {\n    /** {@inheritDoc @apollo/client/link/client-awareness!ClientAwarenessLink.Options#clientAwareness:member} */\n    clientAwareness?: ClientAwarenessLink.ClientAwarenessOptions;\n  }\n\n  export interface ClientAwarenessOptions {\n    /**\n     * A custom name (e.g., `iOS`) that identifies this particular client among your set of clients. Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n     *\n     * This option can either be set as part of the Apollo Client constructor call or when manually constructing a `HttpLink`, `BatchHttpLink` or `ClientAwarenessLink`.\n     */\n    name?: string;\n    /**\n     * A custom version that identifies the current version of this particular client (e.g., `1.2`). Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n     *\n     * This is **not** the version of Apollo Client that you are using, but rather any version string that helps you differentiate between versions of your client.\n     *\n     * This option can either be set as part of the Apollo Client constructor call or when manually constructing a `HttpLink`, `BatchHttpLink` or `ClientAwarenessLink`.\n     */\n    version?: string;\n    /**\n     * Determines how `name` and `version` are sent in outgoing requests.\n     *\n     * If `name` and `version` are not provided, this option will be ignored.\n     * (These options can either be set as part of the Apollo Client constructor call or when manually constructing a `HttpLink`, `BatchHttpLink` or `ClientAwarenessLink`.)\n     *\n     * - If set to `\"headers\"`, `name` and `version` will be sent in the request headers as `apollographql-client-name` and `apollographql-client-version`, respectively.\n     * - If set to `false`, `name` and `version` will not be included in outgoing requests.\n     *\n     * @defaultValue \"headers\"\n     */\n    transport?: \"headers\" | false;\n  }\n  export interface EnhancedClientAwarenessOptions {\n    /**\n     * Determines how the the version information of Apollo Client is sent in outgoing requests.\n     *\n     * - If set to `\"extensions\"`, library `name` and `version` will be sent in an object in the request extensions as `clientLibrary`.\n     * - If set to `false`, library name and version will not be included in outgoing requests.\n     *\n     * @defaultValue \"extensions\"\n     */\n    transport?: \"extensions\" | false;\n  }\n\n  export interface Options {\n    /**\n     * Configures the \"client awareness\" feature.\n     * This feature allows you to identify distinct applications in Apollo Studio\n     * and Apollo Server logs (and other monitoring or analytics tools) by adding\n     * information about the your application to outgoing requests.\n     */\n    clientAwareness?: ClientAwarenessLink.ClientAwarenessOptions;\n    /**\n     * Configures the \"enhanced client awareness\" feature.\n     * This feature allows you to identify the version of the Apollo Client library\n     * used in your application in Apollo Studio (and other monitoring or analytics tools)\n     * by adding information about the Apollo Client library to outgoing requests.\n     */\n    enhancedClientAwareness?: ClientAwarenessLink.EnhancedClientAwarenessOptions;\n  }\n}\n\n/**\n * `ClientAwarenessLink` provides support for providing client awareness\n * features.\n *\n * @remarks\n *\n * Client awareness adds identifying information about the client to HTTP\n * requests for use with metrics reporting tools, such as [Apollo GraphOS](https://apollographql.com/docs/graphos/platform).\n * It is included in the functionality of [`HttpLink`](https://apollographql.com/docs/react/api/link/apollo-link-http) by default.\n *\n * Client awareness distinguishes between user-provided client awareness\n * (provided by the `clientAwareness` option) and enhanced client awareness\n * (provided by the `enhancedClientAwareness` option). User-provided client\n * awareness enables you to set a customized client name and version for\n * identification in metrics reporting tools. Enhanced client awareness enables\n * the identification of the Apollo Client package name and version.\n *\n * @example\n *\n * ```ts\n * import { ClientAwarenessLink } from \"@apollo/client/link/client-awareness\";\n *\n * const link = new ClientAwarenessLink({\n *   clientAwareness: {\n *     name: \"My Client\",\n *     version: \"1\",\n *   },\n *   enhancedClientAwareness: {\n *     transport: \"extensions\",\n *   },\n * });\n * ```\n */\nexport class ClientAwarenessLink extends ApolloLink {\n  constructor(options: ClientAwarenessLink.Options = {}) {\n    super((operation, forward) => {\n      const client = operation.client;\n\n      const clientOptions = client[\"queryManager\"].clientOptions;\n      const context = operation.getContext();\n      {\n        const {\n          name,\n          version,\n          transport = \"headers\",\n        } = compact(\n          {},\n          clientOptions.clientAwareness,\n          options.clientAwareness,\n          context.clientAwareness\n        );\n\n        if (transport === \"headers\") {\n          operation.setContext(({ headers, extensions }) => {\n            return {\n              headers: compact(\n                // setting these first so that they can be overridden by user-provided headers\n                {\n                  \"apollographql-client-name\": name,\n                  \"apollographql-client-version\": version,\n                },\n                headers\n              ),\n            };\n          });\n        }\n      }\n      {\n        const { transport = \"extensions\" } = compact(\n          {},\n          clientOptions.enhancedClientAwareness,\n          options.enhancedClientAwareness\n        );\n        if (transport === \"extensions\") {\n          operation.extensions = compact(\n            // setting these first so that it can be overridden by user-provided extensions\n            {\n              clientLibrary: {\n                name: \"@apollo/client\",\n                version: client.version,\n              },\n            },\n            operation.extensions\n          );\n        }\n      }\n\n      return forward(operation);\n    });\n  }\n}\n", "import { ApolloLink } from \"@apollo/client/link\";\nimport { ClientAwarenessLink } from \"@apollo/client/link/client-awareness\";\n\nimport { BaseHttpLink } from \"./BaseHttpLink.js\";\n\nexport declare namespace HttpLink {\n  /**\n   * Options passed to `HttpLink` through [request context](https://apollographql.com/docs/react/api/link/introduction#managing-context). Previous\n   * non-terminating links in the link chain also can set these values to\n   * customize the behavior of `HttpLink` for each operation.\n   *\n   * > [!NOTE]\n   * > Some of these values can also be provided to the `HttpLink` constructor.\n   * > If a value is provided to both, the value in `context` takes precedence.\n   */\n  interface ContextOptions\n    extends BaseHttpLink.ContextOptions,\n      ClientAwarenessLink.ContextOptions {}\n\n  /**\n   * Options provided to the `HttpLink` constructor.\n   *\n   * > [!NOTE]\n   * > Some of these options are also available to override in [request context](https://apollographql.com/docs/react/api/link/introduction#managing-context).\n   * > Context options override the options passed to the constructor. Treat\n   * > these options as default values that are used when the request context\n   * > does not override the value.\n   */\n  interface Options extends BaseHttpLink.Options, ClientAwarenessLink.Options {}\n}\n\n/**\n * `HttpLink` is a terminating link that sends a GraphQL operation to a remote\n * endpoint over HTTP. It combines the functionality of `BaseHttpLink` and\n * `ClientAwarenessLink` into a single link.\n *\n * @remarks\n *\n * `HttpLink` supports both POST and GET requests, and you can configure HTTP\n * options on a per-operation basis. You can use these options for\n * authentication, persisted queries, dynamic URIs, and other granular updates.\n *\n * @example\n *\n * ```ts\n * import { HttpLink } from \"@apollo/client\";\n *\n * const link = new HttpLink({\n *   uri: \"http://localhost:4000/graphql\",\n *   // Additional options\n * });\n * ```\n */\nexport class HttpLink extends ApolloLink {\n  constructor(options: HttpLink.Options = {}) {\n    const { left, right, request } = ApolloLink.from([\n      new ClientAwarenessLink(options),\n      new BaseHttpLink(options),\n    ]);\n    super(request);\n    Object.assign(this, { left, right });\n  }\n}\n\n/**\n * @deprecated\n * Use `HttpLink` from `@apollo/client/link/http` instead.\n */\nexport const createHttpLink = (options: HttpLink.Options = {}) =>\n  new HttpLink(options);\n", "import { parse } from 'graphql';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  Location,\n} from 'graphql/language/ast';\n\n// A map docString -> graphql document\nconst docCache = new Map<string, DocumentNode>();\n\n// A map fragmentName -> [normalized source]\nconst fragmentSourceMap = new Map<string, Set<string>>();\n\nlet printFragmentWarnings = true;\nlet experimentalFragmentVariables = false;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string: string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc: Location) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nfunction processFragments(ast: DocumentNode) {\n  const seenKeys = new Set<string>();\n  const definitions: DefinitionNode[] = [];\n\n  ast.definitions.forEach(fragmentDefinition => {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc!);\n\n      // We know something about this fragment\n      let sourceKeySet = fragmentSourceMap.get(fragmentName)!;\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n\n  return {\n    ...ast,\n    definitions,\n  };\n}\n\nfunction stripLoc(doc: DocumentNode) {\n  const workSet = new Set<Record<string, any>>(doc.definitions);\n\n  workSet.forEach(node => {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(key => {\n      const value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n\n  const loc = doc.loc as Record<string, any>;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source: string) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    const parsed = parse(source, {\n      experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables,\n    } as any);\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(\n      cacheKey,\n      // check that all \"new\" fragments inside the documents are consistent with\n      // existing fragments of the same name\n      stripLoc(processFragments(parsed)),\n    );\n  }\n  return docCache.get(cacheKey)!;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nexport function gql(\n  literals: string | readonly string[],\n  ...args: any[]\n) {\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  let result = literals[0];\n\n  args.forEach((arg, i) => {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n\n  return parseDocument(result);\n}\n\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\n\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\nconst extras = {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n};\n\nexport namespace gql {\n  export const {\n    gql,\n    resetCaches,\n    disableFragmentWarnings,\n    enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables,\n  } = extras;\n}\n\ngql.default = gql;\n\nexport default gql;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA,IAAa,wBAAb,MAAA;EAAA;AAcE;;;EAbA,oBAAoB,GAAtB;AACI,WAAO;EACT;EACA,eAAe,SAAjB;AACI,cACE,CAAC,cAAc,CAAC,OAAO,GAAG,QAAQ,KAAK,GAAA,EAAA;AAIzC,WAAO;EACT;EACA,gBAAF;EAAmB;AAGnB;;;ACMA,SAAS,SAAS,UAAlB;AACE,SAAO;AACT;AAqBA,IAAa,oBAAb,MAAa,mBAAb;EAoEE,YAAY,WAAwB,UAAoC,CAA1E,GAAA;AAnEmB;AACT;AAES,uCAAc,oBAAI,QAArC;AAsLW;;;;;;;AAKA;;;;;;;AA1HP,SAAK,YAAY;AAEjB,QAAI,QAAQ,aAAa;AAEvB,WAAK,cAAc,QAAQ;IAC7B;AACA,SAAK,SAAS,QAAQ,UAAU;AAEhC,SAAK,WAAT;EACE;;;;;;EAnEQ,YACN,UADJ;AAGI,WAAO,CAAC,QAAQ;EAClB;;;;;;EAOA,OAAO,WAAT;AAII,WAAO,IAAI,mBAAkB,UAAU,EAAE,OAAO,MAApD,CAA2D;EACzD;;;;;;;;;;;;;;;;;;;;;EAsBA,OAAO,MACL,WACA,MACA,QAA2B,mBAAkB,SAHjD,GAAA;AAKI,WAAO,OAAO,OACZ,IAAI;MACF,CAAC,aAFT;AAGU,cAAM,oBAAoB,UAAU,QAAQ,IAAI,OAAO;AAEvD,eAAO,kBAAkB,kBAAkB,QAAQ;MACrD;;MAEA,EAAE,OAAO,MAAjB;IAAwB,GAElB,EAAE,MAAM,MAFd,CAEqB;EAEnB;;;;EAiBA,aAAF;AACI,QAAI,KAAK,QAAQ;AACf,YAAM,kBAAkB,IAAI,KAAlC;AACM,WAAK,cAAc,KACjB,mBAAkB,UAAU,YAAY,KAAK,IAAI,GACjD;QACE,cAAc,CAAC,aAAzB;AACY,gBAAM,YAAY,KAAK,YAAY,QAAQ;AAC3C,cAAI,WAAW;AACb,sBACE,MAAM,QAAQ,SAAS,GAAA,EAAA;AAGzB,mBAAO,gBAAgB,YAAY,SAAS;UAC9C;QACF;QACA,KAAK,WAAW,yBAAyB;QACzC,OAAO;MACjB,CAAS;IAEL;EACF;EAEQ,YAAY,UAAtB;AACI,kBAAc,QAAQ;AACtB,WAAO,KAAK,UAAU,QAAQ;EAChC;;;;;;;;;;;;;;;;;;;;;;;;EAyBA,kBAAkB,UAApB;AAGI,QAAI,KAAK,YAAY,IAAI,QAAQ,GAAG;AAClC,aAAO;IACT;AAEA,UAAM,sBAAsB,KAAK,YAAY,QAAQ;AAErD,SAAK,YAAY,IAAI,mBAAmB;AAExC,WAAO;EACT;;;;;;;;;;;;;;;;;EAkBA,OAAO,gBAAT;AACI,WAAO,OAAO,OACZ,IAAI;MACF,CAAC,aAFT;AAGU,eAAO,eAAe,kBACpB,KAAK,kBAAkB,QAAQ,CAAC;MAEpC;;MAEA,EAAE,OAAO,MAAjB;IAAwB,GAElB;MACE,MAAM;MACN,OAAO;IACf,CAAO;EAEL;AAYF;;;ACnPA,IAAI;AAUG,IAAMA,SAAQ,OAAO,OAC1B,CAAC,QAAgB;AACf,MAAI,SAAS,WAAW,IAAI,GAAG;AAE/B,MAAI,CAAC,QAAQ;AACX,aAAS,MAAU,GAAG;AACtB,eAAW,IAAI,KAAK,MAAM;EAC5B;AACA,SAAO;AACT,GACA;EACE,QAAK;AACH,iBAAa,IAAI;MACf,WAAW,SAAK;;IAA2B;EAE/C;CACD;AAEHA,OAAM,MAAK;AAEX,IAAI,SAAS;AACX,sBAAoB,SAAS,MAAO,aAAa,WAAW,OAAO,CAAE;AACvE;;;ACtBM,SAAU,YAAY,KAAQ;AAClC,SAAO,QACL,OAAO,OAAO,QAAQ,YAAY,OAAO,IAAI,UAAU,QAAQ;AAEnE;;;ACtBA,IAAM,iBAA4B;EAChC,MAAM,KAAK;EACX,MAAM;IACJ,MAAM,KAAK;IACX,OAAO;;;AAoBJ,IAAM,wBAAwB,OAAO,OAC1C,SAAiC,KAAU;AACzC,SAAO,MAAM,KAAK;IAChB,cAAc;MACZ,MAAM,MAAM,MAAM,QAAM;AAEtB,YACE,UACC,OAAmC,SAClC,KAAK,sBACP;AACA;QACF;AAGA,cAAM,EAAE,WAAU,IAAK;AACvB,YAAI,CAAC,YAAY;AACf;QACF;AAIA,cAAM,OAAO,WAAW,KAAK,CAAC,cAAa;AACzC,iBACE,UAAU,SAAS,KAAK,UACvB,UAAU,KAAK,UAAU,gBACxB,UAAU,KAAK,MAAM,YAAY,MAAM,CAAC,MAAM;QAEpD,CAAC;AACD,YAAI,MAAM;AACR;QACF;AAIA,cAAM,QAAQ;AACd,YACE,MAAM,SAAS,KAAK,SACpB,MAAM,cACN,MAAM,WAAW,KAAK,CAAC,MAAM,EAAE,KAAK,UAAU,QAAQ,GACtD;AACA;QACF;AAGA,eAAO;UACL,GAAG;UACH,YAAY,CAAC,GAAG,YAAY,cAAc;;MAE9C;;GAEH;AACH,GACA;EACE,MAAM,OAAgB;AACpB,WAAO,UAAU;EACnB;CACD;;;ACjFH,SAAS,YACP,UACA,WAAgD;AAJlD,MAAAC;AAME,WAAOA,MAAA,uBAAuB,QAAQ,MAA/B,gBAAAA,IAAkC,eAAc;AACzD;AA0BM,SAAU,oBAAoB,UAAsB;AACxD,SAAO,YAAY,UAAU,UAAU;AACzC;AAsDM,SAAU,wBAAwB,UAAsB;AAC5D,SAAO,YAAY,UAAU,cAAc;AAC7C;;;ACtFM,SAAU,wBACd,eAA6B;AAE7B,SAAO,kBAAkB,KAAK,kBAAkB;AAClD;;;ACFM,SAAU,yBACd,eAA6B;AAE7B,SAAO,CAAC,wBAAwB,aAAa;AAC/C;;;ACqFA,IAAsB,cAAtB,MAAA;EAAA;AACkB,kDAAkC;AA4R1C;;0CAAiB,KAAK,0BAA0B;MACtD,KACE,WAAW,8BAA8B,KAC/C;MACI,OAAO;IACX,CAAG;;;;;EAnNM,eAAe,cAAxB;AACI,WAAO;EACT;;;;;;;EASO,MAAS,SAAlB;AACI,UAAM,eACJ,OAAO,QAAQ,eAAe,WAAW,QAAQ,aAC/C,QAAQ,eAAe,QAAQ,OAC/B;AACJ,QAAI;AACJ,SAAK,mBACH,MAAO,eAAe,QAAQ,OAAO,IAAI,GACzC,YAAY;AAEd,WAAO;EACT;EAcO,4BACL,aACA,cAFJ;AAII,SAAK,mBAAmB,aAAa,YAAY;EACnD;;;;EAMO,kBAAkB,UAA3B;AACI,WAAO;EACT;;;EAIO,iBAAiB,UAA1B;AACI,WAAO;EACT;EAEO,SAAS,QAAlB;AACI;EACF;EAEO,KAAT;AACI,WAAO,CAAX;EACE;EAEO,OACL,SADJ;AAGI,WAAO;EACT;EA8BO,UAIL,SACA,aAAa,CAAC,CAAC,QAAQ,YAL3B;AAOI,WAAO,KAAK,KAAK;MACf,GAAG;MACH,QAAQ,QAAQ,MAAM;MACtB;IACN,CAAK;EACH;;;;;;;;;;;;;;;;;EAGO,cAIL,SAJJ;AAMI,UAAM,EACJ,UACA,cACA,MAAAC,OACA,aAAa,MACb,GAAG,aALT,IAMQ;AACJ,UAAM,QAAQ,KAAK,eAAe,UAAU,YAAY;AAOxD,UAAM,KACJ,OAAOA,UAAS,eAAe,OAAOA,UAAS,WAC7CA,QACA,KAAK,SAASA,KAAI;AAEtB,QAAI,SAAS;AACX,YAAM,qBACJ,gBAAgB,sBAAsB,QAAQ,EAAE,KAAK;AAEvD,UAAI,CAAC,IAAI;mBACP,UAAU,KAAlB,KAEU,kBAFV;MAIM;IACF;AAEA,UAAM,cAAoD;MACxD,GAAG;MACH,mBAAmB;MACnB;MACA;MACA;IACN;AAEI,QAAI;AAEJ,WAAO,IAAI,WAAW,CAAC,aAA3B;AACM,aAAO,KAAK,MAAyB;QACnC,GAAG;QACH,WAAW;QACX,UAAU,CAAC,SAAnB;AACU,cAAI,OAAO,KAAK;AAIhB,cAAI,SAAS,MAAM;AACjB,mBAAO,CAAnB;UACU;AAEA;;YAEE,cACA,aACE,OACA,EAAE,MAAM,WAAW,OAFjC,GAGc,EAAE,KAHhB,GAIc,QAAQ,SAAS;YAEnB;AACA;UACF;AAEA,gBAAM,SAAS;YACb;YACA,WAAW,KAAK,WAAW,aAAa;YACxC,UAAU,CAAC,CAAC,KAAK;UAC7B;AAEU,cAAI,KAAK,SAAS;AAChB,mBAAO,UAAU,KAAK,QAAQ;UAChC;AAEA,uBAAa,EAAE,GAAG,MAAM,QAAQ,KAA1C;AACU,mBAAS,KAAK,MAAM;QACtB;MACR,CAAO;IACH,CAAC;EACH;EAqCO,aAIL,SACA,aAAa,CAAC,CAAC,QAAQ,YAL3B;AAOI,WAAO,KAAK,KAAK;MACf,GAAG;MACH,OAAO,KAAK,eAAe,QAAQ,UAAU,QAAQ,YAAY;MACjE,QAAQ,QAAQ;MAChB;IACN,CAAK;EACH;EAmBO,WAGL,EACA,IACA,MACA,GAAG,QANP,GAAA;AAQI,WAAO,KAAK,MACV,OAAO,OAAO,SAAS;MACrB,QAAQ,MAAM;MACd,QAAQ;IAChB,CAAO,CAAC;EAEN;EAoBO,cAGL,EACA,IACA,MACA,UACA,cACA,GAAG,QARP,GAAA;AAUI,WAAO,KAAK,MACV,OAAO,OAAO,SAAS;MACrB,OAAO,KAAK,eAAe,UAAU,YAAY;MACjD,QAAQ;MACR,QAAQ;IAChB,CAAO,CAAC;EAEN;EAEO,YAIL,SACA,QALJ;AAOI,WAAO,KAAK,MAAM;MAChB,OAAO,OAAb;AACQ,cAAM,QAAQ,MAAM,UAA6B,OAAO;AACxD,cAAM,OAAO,OAAO,KAAK;AACzB,YAAI,SAAS,UAAU,SAAS;AAAM,iBAAO;AAC7C,cAAM,WAA8B,EAAE,GAAG,SAAS,KAA1D,CAAgE;AACxD,eAAO;MACT;IACN,CAAK;EACH;EAEO,eAIL,SACA,QALJ;AAOI,WAAO,KAAK,MAAM;MAChB,OAAO,OAAb;AACQ,cAAM,QAAQ,MAAM,aAAgC,OAAO;AAC3D,cAAM,OAAO,OAAO,KAAK;AACzB,YAAI,SAAS,UAAU,SAAS;AAAM,iBAAO;AAC7C,cAAM,cAAiC,EAAE,GAAG,SAAS,KAA7D,CAAmE;AAC3D,eAAO;MACT;IACN,CAAK;EACH;AAUF;AAEA,IAAI,SAAS;AACX,cAAY,UAAU,qBAAqB;AAC7C;;;ACxgBM,IAAO,oBAAP,MAAO,2BAA0B,MAAK;EAC1C,YACkB,SACA,MACA,OACA,WAA+B;AAG/C,UAAM,OAAO;AANG;AACA;AACA;AACA;AAoBF;AAvBE,SAAA,UAAA;AACA,SAAA,OAAA;AACA,SAAA,QAAA;AACA,SAAA,YAAA;AAIhB,SAAK,OAAO;AAEZ,QAAI,MAAM,QAAQ,KAAK,IAAI,GAAG;AAC5B,WAAK,UAAU,KAAK;AACpB,eAAS,IAAI,KAAK,KAAK,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AAC9C,aAAK,UAAU,EAAE,CAAC,KAAK,KAAK,CAAC,CAAC,GAAG,KAAK,QAAO;MAC/C;IACF,OAAO;AACL,WAAK,UAAU,KAAK;IACtB;AAIC,SAAa,YAAY,mBAAkB;EAC9C;;;;ACnBK,IAAM,EAAE,gBAAgB,OAAM,IAAK,OAAO;AAE3C,SAAU,wBACd,EAAE,YAAY,IAAI,IAAG,GACrB,SAA0B;AAE1B,MAAI,OAAO,eAAe,UAAU;AAClC,QAAI,SAAS;AACX,cAAQ,YACN,MAAM,OAAO,EAAE,GAAE,IACf,OAAO,OAAO,EAAE,IAAG,IACnB;IACN;AAGA,QAAI,MAAM,QAAQ,OAAO,MAAM;AAC7B,WAAK;IACP;AAEA,QAAI,MAAM,MAAM;AACd,aAAO,GAAG,UAAU,IAClB,OAAO,OAAO,YAAY,OAAO,OAAO,WACtC,KACA,KAAK,UAAU,EAAE,CACrB;IACF;EACF;AACF;AAEA,IAAM,gBAAqC;EACzC,kBAAkB;EAClB,eAAe;;AAGX,SAAU,gBAAgB,QAA2B;AACzD,SAAO,QAAQ,eAAe,MAAM;AACtC;AAEM,SAAU,2BACd,OACA,mBAA0C;AAE1C,SAAO,YAAY,iBAAiB,IAC/B,MAAM,IAAI,kBAAkB,OAAO,YAAY,IAChD,qBAAqB,kBAAkB;AAC7C;AAEO,IAAM,wBAAwB;AAE/B,SAAU,uBAAuB,gBAAsB;AAC3D,QAAM,QAAQ,eAAe,MAAM,qBAAqB;AACxD,SAAO,QAAQ,MAAM,CAAC,IAAI;AAC5B;AAEM,SAAU,0BACd,cACA,QACA,WAA+B;AAE/B,MAAI,gBAAgB,MAAM,GAAG;AAC3B,WAAO,QAAQ,MAAM,IACjB,OAAO,MAAM,CAAC,SACZ,0BAA0B,cAAc,MAAM,SAAS,CAAC,IAE1D,aAAa,WAAW,MAAM,CAAC,UAAS;AACtC,UAAI,QAAQ,KAAK,KAAK,cAAc,OAAO,SAAS,GAAG;AACrD,cAAM,MAAM,uBAAuB,KAAK;AACxC,eACE,OAAO,KAAK,QAAQ,GAAG,MACtB,CAAC,MAAM,gBACN,0BACE,MAAM,cACN,OAAO,GAAG,GACV,SAAS;MAGjB;AAMA,aAAO;IACT,CAAC;EACP;AACA,SAAO;AACT;AAEM,SAAU,wBACd,OAAiB;AAEjB,SAAO,gBAAgB,KAAK,KAAK,CAAC,YAAY,KAAK,KAAK,CAAC,QAAQ,KAAK;AACxE;AAEM,SAAU,4BAAyB;AACvC,SAAO,IAAI,WAAU;AACvB;AAEM,SAAU,uBACd,UACA,WAA+B;AAO/B,QAAM,cAAc,kBAAkB,uBAAuB,QAAQ,CAAC;AACtE,SAAO;IACL;IACA,eAAe,MAAI;AACjB,UAAI,MAAqC,YAAY,IAAI;AACzD,UAAI,CAAC,OAAO,WAAW;AACrB,cAAM,UAAU,OAAO,IAAI;MAC7B;AACA,aAAO,OAAO;IAChB;;AAEJ;;;AChHA,IAAM,SAAS,CAAf;AACA,IAAM,cAA6B,MAAM;AACzC,IAAM,aAAa,CAAnB;AAEA,IAAsB,cAAtB,MAAA;EAKE,YACkB,UACA,OAFpB;AACoB;AACA;AAJR,gCAA8B,CAA1C;AAkYU;;;mCAEJ,CAFN;AA4DU;gCAEJ,CAFN;AAqES;;yCAAgB,CACrB,mBACA,mBAEA,gBACE,YAAY,iBAAiB,IAC3B,KAAK,IAAI,kBAAkB,OAAO,cAAc,IAChD,qBAAqB,kBAAkB,cAAc,CAAC;AAMrD;;;mCAA2B,CAAC,aAArC;AACI,aAAO,YAAY,QAAQ,IACvB,KAAK,IAAI,SAAS,KAAK,IACvB,OAAO,aAAa;IAC1B;AAMO;;;;uCAAmC,CAAC,cAAc,mBAA3D;AACI,UAAI,OAAO,iBAAiB,UAAU;AACpC,eAAO,cAAc,YAAY;MACnC;AAEA,UAAI,YAAY,YAAY,GAAG;AAC7B,eAAO;MACT;AAEA,YAAM,CAAC,EAAE,IAAI,KAAK,SAAS,SAAS,YAAY;AAEhD,UAAI,IAAI;AACN,cAAM,MAAM,cAAc,EAAE;AAC5B,YAAI,gBAAgB;AAClB,eAAK,MAAM,IAAI,YAAY;QAC7B;AACA,eAAO;MACT;IACF;AAziBkB,SAApB,WAAoB;AACA,SAApB,QAAoB;EACf;;;;EAaI,WAAT;AACI,WAAO,EAAE,GAAG,KAAK,KAArB;EACE;EAEO,IAAI,QAAb;AACI,WAAO,KAAK,OAAO,QAAQ,IAAI,MAAM;EACvC;EAEO,IAAI,QAAgB,WAA7B;AACI,SAAK,MAAM,OAAO,QAAQ,SAAS;AACnC,QAAI,OAAO,KAAK,KAAK,MAAM,MAAM,GAAG;AAClC,YAAM,cAAc,KAAK,KAAK,MAAM;AACpC,UAAI,eAAe,OAAO,KAAK,aAAa,SAAS,GAAG;AACtD,eAAO,YAAY,SAAS;MAC9B;IACF;AACA,QACE,cAAc,gBACd,OAAO,KAAK,KAAK,SAAS,mBAAmB,MAAM,GACnD;AACA,aAAO,KAAK,SAAS,kBAAkB,MAAM;IAC/C;AACA,QAAI,gBAAgB,OAAO;AACzB,aAAO,KAAK,OAAO,IAAI,QAAQ,SAAS;IAC1C;EACF;EAEU,OACR,QACA,mBAFJ;AASI,QAAI;AAAmB,WAAK,MAAM,OAAO,QAAQ,UAAU;AAE3D,QAAI,OAAO,KAAK,KAAK,MAAM,MAAM,GAAG;AAClC,aAAO,KAAK,KAAK,MAAM;IACzB;AAEA,QAAI,gBAAgB,OAAO;AACzB,aAAO,KAAK,OAAO,OAAO,QAAQ,iBAAiB;IACrD;AAEA,QAAI,KAAK,SAAS,kBAAkB,MAAM,GAAG;AAC3C,aAAO,CAAb;IACI;EACF;EAEO,MAAM,OAA6B,OAA5C;AACI,QAAI;AAGJ,QAAI,YAAY,KAAK;AAAG,cAAQ,MAAM;AACtC,QAAI,YAAY,KAAK;AAAG,cAAQ,MAAM;AAEtC,UAAM,WACJ,OAAO,UAAU,WAAW,KAAK,OAAQ,SAAS,KAAM,IAAI;AAE9D,UAAM,WACJ,OAAO,UAAU,WAAW,KAAK,OAAQ,SAAS,KAAM,IAAI;AAI9D,QAAI,CAAC;AAAU;AAEf,cAAU,OAAO,WAAW,UAAhC,EAAA;AAEI,UAAM,SAAsB,IAAI,WAAW,qBAAqB,EAAE,MAChE,UACA,QAAQ;AAKV,SAAK,KAAK,MAAM,IAAI;AAEpB,QAAI,WAAW,UAAU;AACvB,aAAO,KAAK,KAAK,MAAM;AACvB,UAAI,KAAK,MAAM,SAAS;AACtB,cAAM,gBAAmC,CAAjD;AAKQ,YAAI,CAAC;AAAU,wBAAc,WAAW;AAIxC,eAAO,KAAK,QAAQ,EAAE,QAAQ,CAAC,mBAAvC;AACU,cACE,CAAC,YACD,SAAS,cAAc,MAAM,OAAO,cAAc,GAClD;AAGA,0BAAc,cAAc,IAAI;AAShC,kBAAM,YAAY,uBAAuB,cAAc;AACvD,gBACE,cAAc,kBACd,CAAC,KAAK,SAAS,WAAW,OAAO,YAAY,SAAS,GACtD;AACA,4BAAc,SAAS,IAAI;YAC7B;AAKA,gBAAI,OAAO,cAAc,MAAM,UAAU,EAAE,gBAAgB,QAAQ;AACjE,qBAAO,OAAO,cAAc;YAC9B;UACF;QACF,CAAC;AAED,YACE,cAAc,cACd,EAAE,YAAY,SAAS;;;;QAKvB,KAAK,SAAS,kBAAkB,MAAM,MAAM,OAAO,YACnD;AACA,iBAAO,cAAc;QACvB;AAEA,eAAO,KAAK,aAAa,EAAE,QAAQ,CAAC,cAClC,KAAK,MAAM,MAAM,QAAkB,SAAS,CAAC;MAEjD;IACF;EACF;EAEO,OACL,QACA,QACA,OAHJ;AAKI,UAAM,cAAc,KAAK,OAAO,MAAM;AAEtC,QAAI,aAAa;AACf,YAAM,gBAAqC,CAAjD;AACM,UAAI,cAAc;AAClB,UAAI,aAAa;AAEjB,YAAM,gBAAgB;QACpB;QACA;QACA;QACA,aAAa,KAAK;QAClB,SAAS,KAAK;QACd,WAAW,CACT,oBACAC,UAEA,KAAK,SAAS,UACZ,OAAO,uBAAuB,WAC5B;UACE,WAAW;UACX,MAAMA,SAAQ,cAAc,MAAM;QAClD,IACc,oBACF,EAAE,OAAO,KADrB,CAC2B;MAE3B;AAEM,aAAO,KAAK,WAAW,EAAE,QAAQ,CAAC,mBAAxC;AACQ,cAAM,YAAY,uBAAuB,cAAc;AACvD,YAAI,aAAa,YAAY,cAAc;AAC3C,YAAI,eAAe;AAAQ;AAC3B,cAAM,SACJ,OAAO,WAAW,aAAa,SAC7B,OAAO,cAAc,MAAM,QAAQ,SAAY,OAAO,SAAS;AAEnE,YAAI,QAAQ;AACV,cAAI,WACF,WAAW,cAAc,SACvB,OAAO,gBAAgB,UAAU,GAAG;YAClC,GAAG;YACH;YACA;YACA,SAAS,KAAK,WAAW,QAAQ,cAAc;UAC/D,CAAe;AAEL,cAAI,aAAa,YAAY;AAC3B,iBAAK,MAAM,MAAM,QAAQ,cAAc;UACzC,OAAO;AACL,gBAAI,aAAa;AAAQ,yBAAW;AACpC,gBAAI,aAAa,YAAY;AAC3B,4BAAc,cAAc,IAAI;AAChC,4BAAc;AACd,2BAAa;AAEb,kBAAI,SAAS;AACX,sBAAM,iBAAiB,CAAC,QAAxC;AACkB,sBAAI,KAAK,OAAO,IAAI,KAAK,MAAM,QAAW;+BACxC,UAAU,KAA9B,IAIsB,GADtB;AAGoB,2BAAO;kBACT;gBACF;AACA,oBAAI,YAAY,QAAQ,GAAG;AACzB,iCAAe,QAAQ;gBACzB,WAAW,MAAM,QAAQ,QAAQ,GAAG;AAElC,sBAAI,gBAAyB;AAC7B,sBAAI;AACJ,6BAAW,SAAS,UAAU;AAC5B,wBAAI,YAAY,KAAK,GAAG;AACtB,sCAAgB;AAChB,0BAAI,eAAe,KAAK;AAAG;oBAC7B,OAAO;AAGL,0BAAI,OAAO,UAAU,YAAY,CAAC,CAAC,OAAO;AACxC,8BAAM,CAAC,EAAE,IAAI,KAAK,SAAS,SAAS,KAAK;AAEzC,4BAAI,IAAI;AACN,6CAAmB;wBACrB;sBACF;oBACF;AACA,wBAAI,iBAAiB,qBAAqB,QAAW;iCACnD,UAAU,KAAhC,IAGwB,gBADxB;AAGsB;oBACF;kBACF;gBACF;cACF;YACF;UACF;QACF;AACA,YAAI,eAAe,QAAQ;AACzB,uBAAa;QACf;MACF,CAAC;AAED,UAAI,aAAa;AACf,aAAK,MAAM,QAAQ,aAAa;AAEhC,YAAI,YAAY;AACd,cAAI,gBAAgB,OAAO;AACzB,iBAAK,KAAK,MAAM,IAAI;UACtB,OAAO;AACL,mBAAO,KAAK,KAAK,MAAM;UACzB;AACA,eAAK,MAAM,MAAM,QAAQ,UAAU;QACrC;AAEA,eAAO;MACT;IACF;AAEA,WAAO;EACT;;;;;;;EAQO,OACL,QACA,WACA,MAHJ;AAKI,UAAM,cAAc,KAAK,OAAO,MAAM;AACtC,QAAI,aAAa;AACf,YAAM,WAAW,KAAK,cAAsB,aAAa,YAAY;AACrE,YAAM,iBACJ,aAAa,OACX,KAAK,SAAS,kBAAkB,EAAE,UAAU,WAAW,KAAjE,CAAuE,IAC7D;AACJ,aAAO,KAAK,OACV,QACA,iBACE;QACE,CAAC,cAAc,GAAG;MAC9B,IACU,aACF,CAAC,CAAC,IAAI;IAEV;AACA,WAAO;EACT;EAEO,MAAM,SAA6B,OAA5C;AACI,QAAI,UAAU;AACd,QAAI,QAAQ,IAAI;AACd,UAAI,OAAO,KAAK,KAAK,MAAM,QAAQ,EAAE,GAAG;AACtC,kBAAU,KAAK,OAAO,QAAQ,IAAI,QAAQ,WAAW,QAAQ,IAAI;MACnE;AACA,UAAI,gBAAgB,SAAS,SAAS,OAAO;AAC3C,kBAAU,KAAK,OAAO,MAAM,SAAS,KAAK,KAAK;MACjD;AAKA,UAAI,QAAQ,aAAa,SAAS;AAChC,aAAK,MAAM,MAAM,QAAQ,IAAI,QAAQ,aAAa,UAAU;MAC9D;IACF;AACA,WAAO;EACT;EAEO,QAAT;AACI,SAAK,QAAQ,IAAI;EACnB;EAEO,UAAT;AACI,UAAM,MAAM,KAAK,SAArB;AACI,UAAM,eAAyB,CAAnC;AACI,SAAK,aAAT,EAAwB,QAAQ,CAAC,OAAjC;AACM,UAAI,CAAC,OAAO,KAAK,KAAK,SAAS,mBAAmB,EAAE,GAAG;AACrD,qBAAa,KAAK,EAAE;MACtB;IACF,CAAC;AACD,QAAI,aAAa,QAAQ;AACvB,UAAI,SAAS,EAAE,cAAc,aAAa,KAAhD,EAAA;IACI;AACA,WAAO;EACT;EAEO,QAAQ,SAAjB;AACI,WAAO,KAAK,KAAK,IAAI,EAAE,QAAQ,CAAC,WAApC;AACM,UAAI,EAAE,WAAW,OAAO,KAAK,SAAS,MAAM,IAAI;AAC9C,aAAK,OAAO,MAAM;MACpB;IACF,CAAC;AACD,QAAI,SAAS;AACX,YAAM,EAAE,QAAQ,GAAG,KAAzB,IAAkC;AAC5B,aAAO,KAAK,IAAI,EAAE,QAAQ,CAAC,WAAjC;AACQ,aAAK,MAAM,QAAQ,KAAK,MAAM,CAAgB;MAChD,CAAC;AACD,UAAI,QAAQ;AACV,eAAO,aAAa,QAAQ,KAAK,QAAQ,IAAI;MAC/C;IACF;EACF;EAcO,OAAO,QAAhB;AACI,WAAQ,KAAK,QAAQ,MAAM,KAAK,KAAK,QAAQ,MAAM,KAAK,KAAK;EAC/D;EAEO,QAAQ,QAAjB;AACI,QAAI,KAAK,QAAQ,MAAM,IAAI,GAAG;AAC5B,YAAM,QAAQ,EAAE,KAAK,QAAQ,MAAM;AACnC,UAAI,CAAC;AAAO,eAAO,KAAK,QAAQ,MAAM;AACtC,aAAO;IACT;AACA,WAAO;EACT;;;EAIO,aAAa,MAAM,oBAAI,IAAhC,GAAA;AACI,WAAO,KAAK,KAAK,OAAO,EAAE,QAAQ,IAAI,KAAK,GAAG;AAC9C,QAAI,gBAAgB,OAAO;AACzB,WAAK,OAAO,aAAa,GAAG;IAC9B,OAAO;AAIL,aAAO,KAAK,KAAK,SAAS,iBAAiB,EAAE,QAAQ,IAAI,KAAK,GAAG;IACnE;AACA,WAAO;EACT;;;;;EAMO,KAAT;AACI,UAAM,MAAM,KAAK,aAArB;AACI,UAAM,WAAW,KAAK,SAA1B;AACI,QAAI,QAAQ,CAAC,OAAjB;AACM,UAAI,OAAO,KAAK,UAAU,EAAE,GAAG;AAI7B,eAAO,KAAK,KAAK,gBAAgB,EAAE,CAAC,EAAE,QAAQ,IAAI,KAAK,GAAG;AAG1D,eAAO,SAAS,EAAE;MACpB;IACF,CAAC;AACD,UAAM,cAAc,OAAO,KAAK,QAAQ;AACxC,QAAI,YAAY,QAAQ;AACtB,UAAI,OAAoB;AACxB,aAAO,gBAAgB;AAAO,eAAO,KAAK;AAC1C,kBAAY,QAAQ,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;IAC7C;AACA,WAAO;EACT;EAOO,gBAAgB,QAAzB;AACI,QAAI,CAAC,OAAO,KAAK,KAAK,MAAM,MAAM,GAAG;AACnC,YAAM,QAAS,KAAK,KAAK,MAAM,IAAI,CAAzC;AACM,YAAM,OAAO,KAAK,KAAK,MAAM;AAC7B,UAAI,CAAC;AAAM,eAAO;AAElB,YAAM,UAAU,oBAAI,IAAkC,CAAC,IAAI,CAAC;AAG5D,cAAQ,QAAQ,CAAC,QAAvB;AACQ,YAAI,YAAY,GAAG,GAAG;AACpB,gBAAM,IAAI,KAAK,IAAI;QAQrB;AACA,YAAI,gBAAgB,GAAG,GAAG;AACxB,iBAAO,KAAK,GAAG,EAAE,QAAQ,CAAC,QAApC;AACY,kBAAM,QAAQ,IAAI,GAAG;AAGrB,gBAAI,gBAAgB,KAAK,GAAG;AAC1B,sBAAQ,IAAI,KAAK;YACnB;UACF,CAAC;QACH;MACF,CAAC;IACH;AACA,WAAO,KAAK,KAAK,MAAM;EACzB;EA0BO,eAAT;AACI,WAAO,KAAK,MAAM,SAAS,YAAY,SAAS;EAClD;EA+CA,IAAW,wBAAb;AACI,WAAO,KAAK,MAAM;EACpB;AACF;AAiBA,IAAM,aAAN,MAAA;EAOE,YACkB,SACR,SAA4B,MAFxC;AACoB;AACR;AARF,6BAAiD;AAIlD;;;AAGW,SAApB,UAAoB;AACR,SAAZ,SAAY;AAER,SAAK,aAAT;EACE;EAEO,eAAT;AACI,SAAK,IAAI,KAAK,UAAU,IAA5B,IAA4C;AACxC,SAAK,WAAW,IAAI,KAAxB;EACE;EAEO,OAAO,QAAgB,gBAAhC;AACI,QAAI,KAAK,GAAG;AACV,WAAK,EAAE,WAAW,QAAQ,cAAc,CAAC;AACzC,YAAM,YAAY,uBAAuB,cAAc;AACvD,UAAI,cAAc,gBAAgB;AAMhC,aAAK,EAAE,WAAW,QAAQ,SAAS,CAAC;MACtC;AACA,UAAI,KAAK,QAAQ;AACf,aAAK,OAAO,OAAO,QAAQ,cAAc;MAC3C;IACF;EACF;EAEO,MAAM,QAAgB,gBAA/B;AACI,QAAI,KAAK,GAAG;AACV,WAAK,EAAE;QACL,WAAW,QAAQ,cAAc;;;;;;;;QAQjC,mBAAmB,aAAa,WAAW;MAAU;IAEzD;EACF;AACF;AAEA,SAAS,WAAW,QAAgB,gBAApC;AAIE,SAAO,iBAAiB,MAAM;AAChC;AAEA,SAAgB,+BACd,OACA,UAFF;AAIE,MAAI,sBAAsB,KAAK,GAAG;AAShC,UAAM,MAAM,OAAO,UAAU,UAAU;EACzC;AACF;AAEA,IAAM,OAAN,cAAmB,YAAnB;EACE,YAAY,EACV,UACA,gBAAgB,MAChB,KAHJ,GAAA;AASI,UAAM,UAAU,IAAI,WAAW,aAAa,CAAC;AAI/B,iCAAQ,IAAI,MAAM,IAAI;AActB,uCAAc,IAAI,KAApC;AAjBI,QAAI;AAAM,WAAK,QAAQ,IAAI;EAC7B;EAIO,SAAS,SAAiB,QAAnC;AAII,WAAO,KAAK,MAAM,SAAS,SAAS,MAAM;EAC5C;EAEO,cAAT;AAEI,WAAO;EACT;EAGO,aAAT;AACI,WAAO,KAAK,YAAY,YAAY,SAAS;EAC/C;AACF;AACA,YAAY,OAAO;AAInB,IAAM,QAAN,MAAM,eAAc,YAApB;EACE,YACkB,IACA,QACA,QACA,OAJpB;AAMI,UAAM,OAAO,UAAU,KAAK;AALZ;AACA;AACA;AACA;AAHA,SAApB,KAAoB;AACA,SAApB,SAAoB;AACA,SAApB,SAAoB;AACA,SAApB,QAAoB;AAGhB,WAAO,IAAI;EACb;EAEO,SAAS,SAAiB,QAAnC;AACI,WAAO,IAAI,OAAM,SAAS,MAAM,QAAQ,KAAK,KAAK;EACpD;EAEO,YAAY,SAArB;AAEI,UAAM,SAAS,KAAK,OAAO,YAAY,OAAO;AAE9C,QAAI,YAAY,KAAK,IAAI;AACvB,UAAI,KAAK,MAAM,SAAS;AAKtB,eAAO,KAAK,KAAK,IAAI,EAAE,QAAQ,CAAC,WAAxC;AACU,gBAAM,iBAAiB,KAAK,KAAK,MAAM;AACvC,gBAAM,oBAAoB,OAAO,QAAQ,EAAE,MAAM;AACjD,cAAI,CAAC,mBAAmB;AAMtB,iBAAK,OAAO,MAAM;UACpB,WAAW,CAAC,gBAAgB;AAK1B,iBAAK,MAAM,MAAM,QAAQ,UAAU;AACnC,mBAAO,KAAK,iBAAiB,EAAE,QAAQ,CAAC,mBAApD;AACc,mBAAK,MAAM,MAAM,QAAQ,cAAc;YACzC,CAAC;UACH,WAAW,mBAAmB,mBAAmB;AAI/C,mBAAO,KAAK,cAAc,EAAE,QAAQ,CAAC,mBAAjD;AACc,kBACE,CAAC,MACC,eAAe,cAAc,GAC7B,kBAAkB,cAAc,CAAC,GAEnC;AACA,qBAAK,MAAM,MAAM,QAAQ,cAAc;cACzC;YACF,CAAC;UACH;QACF,CAAC;MACH;AAEA,aAAO;IACT;AAGA,QAAI,WAAW,KAAK;AAAQ,aAAO;AAGnC,WAAO,OAAO,SAAS,KAAK,IAAI,KAAK,MAAM;EAC7C;EAEO,WAAT;AACI,WAAO;MACL,GAAG,KAAK,OAAO,SAArB;MACM,GAAG,KAAK;IACd;EACE;EAEO,gBAAgB,QAAzB;AACI,UAAM,aAAa,KAAK,OAAO,gBAAgB,MAAM;AACrD,WAAO,OAAO,KAAK,KAAK,MAAM,MAAM,IAChC;MACE,GAAG;MACH,GAAG,MAAM,gBAAgB,MAAM;IACzC,IACQ;EACN;EAEO,cACF,MADP;AAGI,QAAI,IAAiB,KAAK;AAC1B,WAAQ,EAAY;AAAQ,UAAK,EAAY;AAC7C,WAAO,EAAE,WAAW,GAAG,IAAI;EAC7B;AACF;AAMA,IAAM,QAAN,cAAoB,MAApB;EACE,YAAY,MAAd;AACI,UACE,qBACA,MACA,MAHN;IAGa,GACP,IAAI,WAAW,KAAK,MAAM,SAAS,KAAK,KAAK,CAAC;EAElD;EAEO,cAAT;AAEI,WAAO;EACT;EAEO,MAAM,OAA6B,OAA5C;AAMI,WAAO,KAAK,OAAO,MAAM,OAAO,KAAK;EACvC;AACF;AAEA,SAAS,sBACP,gBACA,gBACA,UAHF;AAKE,QAAM,gBAAgB,eAAe,QAAQ;AAC7C,QAAM,gBAAgB,eAAe,QAAQ;AAM7C,SAAO,MAAM,eAAe,aAAa,IAAI,gBAAgB;AAC/D;AAEA,SAAgB,sBAAsB,OAAtC;AAEE,SAAO,CAAC,EAAE,SAAS,MAAM;AAC3B;;;ACz2BO,IAAM,sBAAsB,IAAI,KAAvC;AAEA,SAAgB,oBACd,UADF;AAXA,MAAAC,KAAA;AAcE,QAAM,aAAYA,MAAA,SAAS,eAAT,gBAAAA,IAAqB,KACrC,CAAC,EAAE,KADP,MACkB,KAAK,UAAU;AAG/B,MAAI,CAAC,WAAW;AACd,WAAO;EACT;AAEA,QAAM,WAAU,eAAU,cAAV,mBAAqB,KACnC,CAAC,EAAE,KADP,MACkB,KAAK,UAAU;AAG/B,MAAI,SAAS;AACX,QAAI,SAAS;AACX,UAAI,QAAQ,MAAM,SAAS,KAAK,UAAU;mBACxC,UAAU,KAAlB,EAAA;MACM,WAAW,QAAQ,MAAM,SAAS,KAAK,QAAQ;mBAC7C,UAAU,KAAlB,EAAA;MACM,WAAW,QAAQ,MAAM,UAAU,WAAW;mBAC5C,UAAU,KAAlB,IAEU,QAAQ,MAAM,KAFxB;MAIM;IACF;EACF;AAEA,MACE,WACA,WAAW,QAAQ,SACnB,QAAQ,MAAM,UAAU,WACxB;AACA,WAAO;EACT;AAEA,SAAO;AACT;;;AC5BA,SAAgB,eACd,MACA,cACA,SAHF;AAKE,SAAO,oBAAoB,UAAU,MAAM,MAA7C;AACI,UAAM,SAAS,iBAAiB,MAAM,cAAc,SAAS,KAAK;AAElE,QAAI,OAAO,SAAS,IAAI,GAAG;AACzB,sBAAgB,MAAM;IACxB;AACA,WAAO;EACT,CAAC;AACH;AAEA,SAAS,iBACP,MACA,gBAFF;AAIE,MAAI,eAAe,IAAI,IAAI,GAAG;AAC5B,WAAO,eAAe,IAAI,IAAI;EAChC;AAEA,QAAM,gBAAgB,MAAM,QAAQ,IAAI,IAAI,CAA9C,IAAmD,CAAnD;AACE,iBAAe,IAAI,MAAM,aAAa;AACtC,SAAO;AACT;AAEA,SAAS,iBACP,MACA,cACA,SACA,WACA,MALF;AAlDA,MAAAC;AAyDE,QAAM,EAAE,aAAV,IAA2B;AACzB,QAAM,OAAO,iBAAiB,MAAM,QAAQ,cAAc;AAE1D,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,eAAW,CAAC,OAAO,IAAI,KAAK,MAAM,KAAK,KAAK,QAAhD,CAAyD,GAAG;AACtD,UAAI,SAAS,MAAM;AACjB,aAAK,KAAK,IAAI;AACd;MACF;AAEA,YAAM,SAAS,iBACb,MACA,cACA,SACA,WACA,UAAU,GAAG,QAAQ,EAAE,IAAI,KAAK,MAAM,MAAM;AAE9C,UAAI,aAAa,IAAI,MAAM,GAAG;AAC5B,qBAAa,IAAI,IAAI;MACvB;AAEA,WAAK,KAAK,IAAI;IAChB;AAEA,WAAO,aAAa,IAAI,IAAI,IAAI,OAAO;EACzC;AAEA,aAAW,aAAa,aAAa,YAAY;AAC/C,QAAI;AAIJ,QAAI,WAAW;AACb,mBAAa,IAAI,IAAI;IACvB;AAEA,QAAI,UAAU,SAAS,KAAK,OAAO;AACjC,YAAM,UAAU,uBAAuB,SAAS;AAChD,YAAM,oBAAoB,UAAU;AAEpC,cAAQ,KAAK,OAAO,KAAK,KAAK,OAAO;AAErC,UAAI,UAAU,QAAQ;AACpB;MACF;AAEA,UAAI,qBAAqB,UAAU,MAAM;AACvC,cAAM,SAAS,iBACb,KAAK,OAAO,GACZ,mBACA,SACA,WACA,UAAU,GAAG,QAAQ,EAAE,IAAI,OAAO,KAAK,MAAM;AAG/C,YAAI,aAAa,IAAI,MAAM,GAAG;AAC5B,kBAAQ;QACV;MACF;AAEA,UAAI,CAAC,SAAS;AACZ,aAAK,OAAO,IAAI;MAClB;AACA,UAAI,SAAS;AACX,YACE,aACA,YAAY;;;;QAKZ,GAACA,MAAA,OAAO,yBAAyB,MAAM,OAAO,MAA7C,gBAAAA,IAAgD,QACjD;AACA,iBAAO,eACL,MACA,SACA,6BACE,SACA,OACA,QAAQ,IACR,QAAQ,eACR,QAAQ,aAAa,CACtB;QAEL,OAAO;AACL,iBAAO,KAAK,OAAO;AACnB,eAAK,OAAO,IAAI;QAClB;MACF;IACF;AAEA,QACE,UAAU,SAAS,KAAK,oBACvB,CAAC,UAAU,iBACV,QAAQ,MAAM,gBAAgB,WAAW,KAAK,UAAU,IAC1D;AACA,cAAQ,iBACN,MACA,UAAU,cACV,SACA,WACA,IAAI;IAER;AAEA,QAAI,UAAU,SAAS,KAAK,iBAAiB;AAC3C,YAAM,eAAe,UAAU,KAAK;AACpC,YAAM,WACJ,QAAQ,YAAY,YAAY,MAC/B,QAAQ,YAAY,YAAY,IAC/B,QAAQ,MAAM,eAAe,YAAY;AAC7C,gBACE,UADR,IAGQ,YAHR;AAMM,YAAM,OAAO,oBAAoB,SAAS;AAE1C,UAAI,SAAS,QAAQ;AACnB,gBAAQ,iBACN,MACA,SAAS,cACT,SACA,SAAS,WACT,IAAI;MAER;IACF;AAEA,QAAI,aAAa,IAAI,KAAK,GAAG;AAC3B,mBAAa,IAAI,IAAI;IACvB;EACF;AAEA,MAAI,gBAAgB,QAAQ,EAAE,gBAAgB,OAAO;AACnD,SAAK,aAAa,KAAK;EACzB;AAKA,MAAI,OAAO,KAAK,IAAI,EAAE,WAAW,OAAO,KAAK,IAAI,EAAE,QAAQ;AACzD,iBAAa,IAAI,IAAI;EACvB;AAEA,SAAO,aAAa,IAAI,IAAI,IAAI,OAAO;AACzC;AAEA,SAAS,6BACP,WACA,OACA,MACA,eACA,eALF;AAOE,MAAI,WAAW,MAAjB;AACI,QAAI,oBAAoB,SAA5B,GAAwC;AAClC,aAAO;IACT;eAEA,UAAU,KAAd,IAEM,gBACE,GAAG,aAAa,KAAK,aAAa,MAClC,aAAa,aAAa,IAC5B,GAAG,IAAI,IAAI,SAAS,GAAG,QAAO,OAAQ,EAAE,CAAA;AAG1C,eAAW,MAAM;AAEjB,WAAO;EACT;AAEA,SAAO;IACL,MAAJ;AACM,aAAO,SAAb;IACI;IACA,IAAI,UAAR;AACM,iBAAW,MAAM;IACnB;IACA,YAAY;IACZ,cAAc;EAClB;AACA;;;AC/NA,SAAgB,aACd,MACA,UACA,OACA,cAJF;AAME,QAAM,YAAY,SAAS,YAAY,OACrC,CAAC,SACC,KAAK,SAAS,KAAK,mBAAmB;AAG1C,MAAI,OAAO,iBAAiB,aAAa;AACvC,cACE,UAAU,WAAW,GAAA,IAErB,UAAU,MAHhB;AAKI,mBAAe,UAAU,CAAC,EAAE,KAAK;EACnC;AAEA,QAAM,WAAW,UAAU,KACzB,CAACC,cAAaA,UAAS,KAAK,UAAU,YAAY;AAGpD,YACE,CAAC,CAAC,UADN,IAGI,YAHJ;AAME,MAAI,QAAQ,MAAM;AAEhB,WAAO;EACT;AAEA,MAAI,MAAM,MAAM,CAAlB,CAAoB,GAAG;AAInB,WAAO;EACT;AAEA,SAAO,eAAe,MAAM,SAAS,cAAc;IACjD,eAAe;IACf,eAAe,SAAS,KAAK;IAC7B,aAAa,kBAAkB,uBAAuB,QAAQ,CAAC;IAC/D;IACA,gBAAgB,oBAAI,QAAxB;IACI,cAAc,oBAAI,QAAtB;EACA,CAAG;AACH;;;ACrDA,SAAgB,cACd,MACA,UACA,OAHF;AAVA,MAAAC;AAeE,QAAM,aAAa,uBAAuB,QAAQ;AAElD,YACE,YADJ,EAAA;AAKE,MAAI,QAAQ,MAAM;AAEhB,WAAO;EACT;AAEA,SAAO,eAAe,MAAM,WAAW,cAAc;IACnD,eAAe,WAAW;IAC1B,gBAAeA,MAAA,WAAW,SAAX,gBAAAA,IAAiB;IAChC,aAAa,kBAAkB,uBAAuB,QAAQ,CAAC;IAC/D;IACA,gBAAgB,oBAAI,QAAxB;IACI,cAAc,oBAAI,QAAtB;EACA,CAAG;AACH;;;ACxBA,IAAM,qBAOF,CAPJ;AASA,SAAS,oBAAoB,MAA7B;AAIE,QAAM,WAAW,KAAK,UAAU,IAAI;AACpC,SAAO,mBAAmB,QAAQ,MAAM,mBAAmB,QAAQ,IAAI,CAAzE;AACA;AAEA,SAAgB,yBACd,WADF;AAGE,QAAM,OAAO,oBAAoB,SAAS;SAGxC,KAAK,gBACJ,KAAK,cAAc,CAAC,QAAQ,YAAjC;AACM,UAAM,UAA6B,CAACC,OAAM,QACxC,QAAQ,UAAU,KAAKA,KAAI;AAE7B,UAAM,YAAa,QAAQ,YAAY,sBACrC,WACA,CAAC,kBAFT;AAGU,UAAI,YAAY;QACd,QAAQ;QACR;;;;QAIA;MAAO;AAGT,UACE,cAAc,UACd,WAAW,QAAQ,eACnB,OAAO,KAAK,QAAQ,cAAc,CAAC,CAAC,GACpC;AAUA,oBAAY,eAAe,QAAQ,eAAe,UAAU;MAC9D;AAEA,gBACE,cAAc,QAAK,IAEnB,cAAc,KAAK,GAAG,GACtB,MAJZ;AAOU,aAAO;IACT,CAAC;AAGH,WAAO,GAAG,QAAQ,QAAQ,IAAI,KAAK,UAAU,SAAS,CAAC;EACzD;AAEJ;AASA,SAAgB,uBACd,WADF;AAGE,QAAM,OAAO,oBAAoB,SAAS;AAE1C,SACE,KAAK,cACJ,KAAK,YAAY,CAAC,MAAM,EAAE,OAAO,WAAW,UAAjD,MAAA;AACM,UAAM,YAAY,sBAAsB,WAAW,CAAC,YAA1D;AACQ,YAAM,WAAW,QAAQ,CAAC;AAC1B,YAAM,YAAY,SAAS,OAAO,CAAC;AAEnC,UAAI,cAAc,KAAK;AACrB,YAAI,SAAS,gBAAgB,MAAM,UAAU,GAAG;AAC9C,gBAAM,gBAAgB,SAAS,MAAM,CAAC;AAItC,gBAAM,IAAI,MAAM,WAAW,KACzB,CAACC,OAAMA,GAAE,KAAK,UAAU,aAAa;AAGvC,gBAAM,gBAAgB,KAAK,yBAAyB,GAAG,SAAS;AAQhE,iBACE,iBACA;YACE;;;;YAIA,QAAQ,MAAM,CAAC;UAAC;QAGtB;AAIA;MACF;AAEA,UAAI,cAAc,KAAK;AACrB,cAAM,eAAe,SAAS,MAAM,CAAC;AACrC,YAAI,aAAa,OAAO,KAAK,WAAW,YAAY,GAAG;AACrD,gBAAM,aAAa,QAAQ,MAAM,CAAC;AAClC,qBAAW,CAAC,IAAI;AAChB,iBAAO,eAAe,WAAW,UAAU;QAC7C;AAIA;MACF;AAEA,UAAI,MAAM;AACR,eAAO,eAAe,MAAM,OAAO;MACrC;IACF,CAAC;AAED,UAAM,SAAS,KAAK,UAAU,SAAS;AAOvC,QAAI,QAAQ,WAAW,MAAM;AAC3B,mBAAa,MAAM;IACrB;AAEA,WAAO;EACT;AAEJ;AAEA,SAAgB,sBACd,WACA,WAFF;AAME,QAAM,SAAS,IAAI,WAArB;AACE,SAAO,kBAAkB,SAAS,EAAE,OAAO,CAAC,WAAW,SAAzD;AACI,QAAI,UAAU,UAAU,IAAI;AAC5B,QAAI,YAAY,QAAQ;AAGtB,eAAS,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACzC,kBAAU,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG,QAA/B;MACM;AACA,kBAAY,OAAO,MAAM,WAAW,OAAO;IAC7C;AACA,WAAO;EACT,GAAG,CAAL,CAAO;AACP;AAEA,SAAgB,kBAAkB,MAAlC;AACE,QAAM,OAAO,oBAAoB,IAAI;AAErC,MAAI,CAAC,KAAK,OAAO;AACf,UAAM,QAAqB,KAAK,QAAQ,CAA5C;AACI,UAAM,cAAwB,CAAlC;AAEI,SAAK,QAAQ,CAAC,GAAG,MAArB;AACM,UAAI,QAAQ,CAAC,GAAG;AACd,0BAAkB,CAAC,EAAE,QAAQ,CAAC,MAAM,MAAM,KAAK,YAAY,OAAO,CAAC,CAAC,CAAC;AACrE,oBAAY,SAAS;MACvB,OAAO;AACL,oBAAY,KAAK,CAAC;AAClB,YAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,CAAC,GAAG;AACzB,gBAAM,KAAK,YAAY,MAAM,CAAC,CAAC;AAC/B,sBAAY,SAAS;QACvB;MACF;IACF,CAAC;EACH;AAEA,SAAO,KAAK;AACd;AAEA,SAAS,WACP,QACA,KAFF;AAIE,SAAO,OAAO,GAAG;AACnB;AAEA,SAAgB,eACd,QACA,MACA,SAHF;AAgBE,YAAU,WAAW;AACrB,SAAO,UACL,KAAK,OAAO,SAAS,QAAQ,KAAK,KADtC;AAEM,WAAO,QAAQ,GAAG,IACd,IAAI,IAAI,CAAC,UAAU,QAAQ,OAAO,GAAG,CAAC,IACtC,OAAO,QAAS,KAAK,GAAG;EAC9B,GAAG,MAAM,CAAC;AAEd;AAEA,SAAS,UAAa,OAAtB;AAIE,MAAI,gBAAgB,KAAK,GAAG;AAC1B,QAAI,QAAQ,KAAK,GAAG;AAClB,aAAO,MAAM,IAAI,SAAS;IAC5B;AACA,WAAO,sBAAsB,OAAO,KAAK,KAAK,EAAE,KAApD,GAA4D,CAAC,SACvD,eAAe,OAAO,IAAI,CAAC;EAE/B;AACA,SAAO;AACT;;;AC3PO,IAAM,YAAY,IAAI,KAAI;AAEjC,IAAM,eAAe,oBAAI,QAAO;AAQhC,SAAS,aAAa,OAAkB;AACtC,MAAI,OAAO,aAAa,IAAI,KAAK;AACjC,MAAI,CAAC,MAAM;AACT,iBAAa,IACX,OACC,OAAO;MACN,MAAM,oBAAI,IAAG;MACb,KAAK,IAAG;KACR;EAEN;AACA,SAAO;AACT;AAEM,SAAU,YAAY,OAAkB;AAC5C,eAAa,KAAK,EAAE,KAAK,QAAQ,CAAC,OAAO,GAAG,YAAY,KAAK,CAAC;AAChE;AAUM,SAAU,YAAY,OAAkB;AAC5C,eAAa,KAAK,EAAE,KAAK,QAAQ,CAAC,OAAO,GAAG,YAAY,KAAK,CAAC;AAChE;AAEM,SAAU,QAAW,OAAQ;AACjC,QAAM,SAAS,oBAAI,IAAG;AACtB,QAAM,YAAY,oBAAI,IAAG;AAEzB,QAAM,KAAqB,SAAU,UAAQ;AAC3C,QAAI,UAAU,SAAS,GAAG;AACxB,UAAI,UAAU,UAAU;AACtB,gBAAQ;AACR,eAAO,QAAQ,CAAC,UAAS;AAIvB,uBAAa,KAAK,EAAE,IAAI,MAAM,EAAE;AAGhC,oBAAU,KAAK;QACjB,CAAC;AAED,cAAM,eAAe,MAAM,KAAK,SAAS;AACzC,kBAAU,MAAK;AACf,qBAAa,QAAQ,CAAC,aAAa,SAAS,KAAK,CAAC;MACpD;IACF,OAAO;AAIL,YAAM,QAAQ,UAAU,SAAQ;AAChC,UAAI,OAAO;AACT,eAAO,KAAK;AACZ,qBAAa,KAAK,EAAE,IAAI,EAAE;MAC5B;IACF;AAEA,WAAO;EACT;AAEA,KAAG,eAAe,CAAC,aAAY;AAC7B,cAAU,IAAI,QAAQ;AACtB,WAAO,MAAK;AACV,gBAAU,OAAO,QAAQ;IAC3B;EACF;AAEA,QAAM,SAAU,GAAG,cAAc,CAAC,UAAS;AACzC,WAAO,IAAI,KAAK;AAChB,iBAAa,KAAK,EAAE,KAAK,IAAI,EAAE;AAC/B,WAAO;EACT;AAEA,KAAG,cAAc,CAAC,UAAU,OAAO,OAAO,KAAK;AAE/C,SAAO;AACT;AAQA,SAAS,UAAU,OAAoB;AACrC,MAAI,MAAM,kBAAkB;AAC1B,UAAM,iBAAgB;EACxB;AACF;;;ACmDA,SAAS,uBAAuB,MAAhC;AACE,SACE,KAAK,SAAS,SAAS,KAAK,OAC1B,KAAK,QAAQ,yBAAyB,KAAK,OAAO,KAAK,SAAS,IAChE;AAEN;AA6FA,IAAM,kBAAqC,MAAM;AACjD,IAAM,kBAAmC,CAAC,OAAO,YAAY,QAAQ;AAIrE,IAAM,cAAuC,CAC3C,UACA,UACA,EAAE,aAHJ,MAIK,aAAa,UAAU,QAAQ;AACpC,IAAM,eAAwC,CAAC,GAAG,aAAa;AAa/D,IAAa,WAAb,MAAA;EAkCE,YACU,QADZ;AACY;AAlCF,wCAQJ,CARN;AAUU,qCAEJ,CAFN;AAQU;;;;wCAAe,oBAAI,IAA7B;AAMU;;;;yCAAgB,oBAAI,IAA9B;AAEkB;AAEA,6CAA4C,CAA9D;AACkB,6CAA4C,CAA9D;AAEkB,8CAAqB;AAG3B,SAAZ,SAAY;AAOR,SAAK,SAAS;MACZ,kBAAkB;MAClB,GAAG;IACT;AAEI,SAAK,QAAQ,KAAK,OAAO;AAEzB,SAAK,gBAAgB,OAAO;AAC5B,SAAK,gBAAgB,UAAU;AAC/B,SAAK,gBAAgB,cAAc;AAEnC,QAAI,OAAO,eAAe;AACxB,WAAK,iBAAiB,OAAO,aAAa;IAC5C;AAEA,QAAI,OAAO,cAAc;AACvB,WAAK,gBAAgB,OAAO,YAAY;IAC1C;EACF;EAEO,SACL,QACA,gBAFJ;AA7VA,QAAAC;AAiWI,UAAM,WAAW;AAEjB,UAAM,WACH,mBACE,eAAe,cAAYA,MAAA,eAAe,gBAAf,gBAAAA,IAA4B,gBAC1D,OAAO;AAOT,QAAI,aAAa,KAAK,kBAAkB,YAAY;AAClD,aAAO,CAAC,YAAY;IACtB;AAGA,UAAM,cACH,kBAAkB,eAAe,eAAgB;AAEpD,UAAM,UAA4B;MAChC,GAAG;MACH;MACA;MACA,WACG,kBAAkB,eAAe,cAChC,IAAI,SAAd;AACU,cAAM,UAAU,0BAA0B,MAAM,WAAW;AAC3D,eAAO,SAAS,UAAU,SAAS;UACjC,OAAO,SAAS,MAAM,MAAM;UAC5B,WAAW,QAAQ;QAC/B,CAAW;MACH;IACR;AAEI,QAAI;AAEJ,UAAM,SAAS,YAAY,KAAK,cAAc,QAAQ;AACtD,QAAI,QAAS,UAAU,OAAO,SAAU,KAAK,OAAO;AAEpD,wBAAoB,UAAU,MAAM,MAAxC;AACM,aAAO,OAAO;AACZ,cAAM,gBAAgB,MAAM,EAAE,GAAG,QAAQ,GAAG,YAApD,GAAmE,OAAO;AAClE,YAAI,QAAQ,aAAa,GAAG;AAC1B,kBAAQ,yBAAyB,aAAa;QAChD,OAAO;AACL,eAAK;AACL;QACF;MACF;IACF,CAAC;AAED,SAAK,KAAK,OAAO,EAAE,IAAI;AACvB,WAAO,QAAQ,YAAY,CAAC,IAAI,QAAQ,SAAS,IAAI,CAAC,EAAE;EAC1D;EAEO,gBAAgB,cAAzB;AACI,WAAO,KAAK,YAAY,EAAE,QAAQ,CAAC,aAAvC;AACM,YAAM,EAAE,WAAW,cAAc,kBAAkB,GAAG,SAA5D,IACQ,aAAa,QAAQ;AAgBvB,UAAI;AAAW,aAAK,gBAAgB,SAAS,QAAQ;AACrD,UAAI;AAAc,aAAK,gBAAgB,YAAY,QAAQ;AAC3D,UAAI;AAAkB,aAAK,gBAAgB,gBAAgB,QAAQ;AAEnE,UAAI,OAAO,KAAK,KAAK,WAAW,QAAQ,GAAG;AACzC,aAAK,UAAU,QAAQ,EAAE,KAAK,QAAQ;MACxC,OAAO;AACL,aAAK,UAAU,QAAQ,IAAI,CAAC,QAAQ;MACtC;IACF,CAAC;EACH;EAEQ,iBACN,UACA,UACA,uBAHJ;AAKI,UAAM,WAAW,KAAK,cAAc,QAAQ;AAC5C,UAAM,EAAE,WAAW,OAAvB,IAAkC;AAE9B,aAAS,SACPC,WACA,OAFN;AAIM,MAAAA,UAAS,QACP,OAAO,UAAU,aAAa,QAG5B,UAAU,OAAO,cAGjB,UAAU,QAAQ,eAClBA,UAAS;IACf;AAIA,aAAS,UAAU,SAAS,KAAK;AAEjC,aAAS;IAEP,cAAc,QAAQ,kBAGpB,QAAQ,SAAS,IAAI,yBAAyB,SAAS,IAEvD,OAAO,cAAc,aAAa,YAElC,SAAS;AAEb,QAAI,QAAQ;AACV,aAAO,KAAK,MAAM,EAAE,QAAQ,CAAC,cAAnC;AACQ,YAAIA,YAAW,sBAAsB,SAAS;AAQ9C,YAAI,CAACA,cAAYA,aAAA,gBAAAA,UAAU,cAAa,UAAU;AAChD,UAAAA,YAAW,sBAAsB,SAAS,IAAI,EAAE,SAA1D;QACQ;AACA,cAAMC,YAAW,OAAO,SAAS;AAEjC,YAAI,OAAOA,cAAa,YAAY;AAClC,UAAAD,UAAS,OAAOC;QAClB,OAAO;AACL,gBAAM,EAAE,SAAS,MAAM,MAAjC,IAA2CA;AAEjC,UAAAD,UAAS;;UAGP,YAAY,QAAQ,kBAGlB,QAAQ,OAAO,IAAI,uBAAuB,OAAO,IAEjD,OAAO,YAAY,aAAa,UAEhCA,UAAS;AAEb,cAAI,OAAO,SAAS,YAAY;AAC9B,YAAAA,UAAS,OAAO;UAClB;AAEA,mBAASA,WAAU,KAAK;QAC1B;AAEA,YAAIA,UAAS,QAAQA,UAAS,OAAO;AAMnC,UAAAA,UAAS,QAAQA,UAAS,SAAS;QACrC;MACF,CAAC;IACH;EACF;EAEQ,gBACN,OACA,WAAmB,OAFvB;AAII,UAAM,SAAS,UAAU,MAAM,YAAnC;AACI,UAAM,MAAM,KAAK,kBAAkB,MAAM;AACzC,QAAI,aAAa,KAAK;AACpB,gBACE,CAAC,OAAO,QAAQ,OADxB,IAGQ,KAHR;AAOM,UAAI;AAAK,eAAO,KAAK,kBAAkB,GAAG;AAE1C,WAAK,kBAAkB,QAAQ,IAAI;AAEnC,WAAK,kBAAkB,MAAM,IAAI;IACnC;EACF;EAEO,iBAAiB,eAA1B;AACK,SAAK,qBAAiC;AACvC,WAAO,KAAK,aAAa,EAAE,QAAQ,CAAC,cAAxC;AAIM,WAAK,gBAAgB,WAAW,IAAI;AAEpC,oBAAc,SAAS,EAAE,QAAQ,CAAC,YAAxC;AACQ,aAAK,gBAAgB,SAAS,IAAI,EAAG,IAAI,SAAS;AAClD,cAAM,QAAQ,QAAQ,MAAM,qBAAqB;AACjD,YAAI,CAAC,SAAS,MAAM,CAAC,MAAM,SAAS;AAElC,eAAK,cAAc,IAAI,SAAS,IAAI,OAAO,OAAO,CAAC;QACrD;MACF,CAAC;IACH,CAAC;EACH;EAEQ,cAAc,UAAxB;AACI,QAAI,CAAC,OAAO,KAAK,KAAK,cAAc,QAAQ,GAAG;AAC7C,YAAM,SAA4C,KAAK,aACrD,QAAQ,IACN,CAFV;AAGM,aAAO,SAAS,CAAtB;AAuBM,UAAI,aAAa,KAAK,aAAa,IAAI,QAAQ;AAC/C,UAAI,CAAC,cAAc,KAAK,cAAc,MAAM;AAI1C,qBAAa,KAAK,gBAAgB,UAAU,IAAI;AAMhD,aAAK,cAAc,QAAQ,CAAC,QAAQ,UAA5C;AACU,cAAI,OAAO,KAAK,QAAQ,GAAG;AAIzB,kBAAM,kBAAkB,KAAK,aAAa,IAAI,KAAK;AACnD,gBAAI,iBAAiB;AACnB,8BAAgB,QAAQ,CAAC,cACvB,WAAY,IAAI,SAAS,CAAC;YAE9B;UACF;QACF,CAAC;MACH;AACA,UAAI,cAAc,WAAW,MAAM;AACjC,mBAAW,QAAQ,CAAC,cAA5B;AACU,gBAAM,EAAE,QAAQ,GAAG,KAA7B,IAAsC,KAAK,cAAc,SAAS;AACxD,iBAAO,OAAO,QAAQ,IAAI;AAC1B,iBAAO,OAAO,OAAO,QAAQ,MAAM;QACrC,CAAC;MACH;IACF;AAEA,UAAM,QAAQ,KAAK,UAAU,QAAQ;AACrC,QAAI,SAAS,MAAM,QAAQ;AAGzB,YAAM,OAAO,CAAC,EAAE,QAAQ,CAAC,WAA/B;AACQ,aAAK,iBACH,UACA,QACA,KAAK,aAAa,QAAQ,EAAE,MAAM;MAEtC,CAAC;IACH;AAEA,WAAO,KAAK,aAAa,QAAQ;EACnC;EAEQ,eACN,UACA,WAFJ;AAII,QAAI,UAAU;AACZ,aAAO,KAAK,cAAc,QAAQ,EAAE,OAAO,SAAS;IACtD;EACF;EAEQ,gBACN,SACA,iBAFJ;AAII,QAAI,eAAe,KAAK,aAAa,IAAI,OAAO;AAChD,QAAI,CAAC,gBAAgB,iBAAiB;AACpC,WAAK,aAAa,IAAI,SAAU,eAAe,oBAAI,IAAzD,CAAuE;IACnE;AACA,WAAO;EACT;EAEO,gBACL,UACA,UACA,QACA,WAJJ;AAMI,QAAI,CAAC,SAAS;AAAe,aAAO;AAIpC,QAAI,CAAC;AAAU,aAAO;AAEtB,UAAM,YAAY,SAAS,cAAc,KAAK;AAE9C,QAAI,aAAa;AAAW,aAAO;AAEnC,QAAI,KAAK,sBAAsB,KAAK,aAAa,IAAI,SAAS,GAAG;AAC/D,YAAM,uBAAuB,KAAK,gBAAgB,UAAU,IAAI;AAChE,YAAM,YAAY,CAAC,oBAAoB;AACvC,YAAM,eAAe,CAAC,YAA5B;AACQ,cAAM,eAAe,KAAK,gBAAgB,SAAS,KAAK;AACxD,YACE,gBACA,aAAa,QACb,UAAU,QAAQ,YAAY,IAAI,GAClC;AACA,oBAAU,KAAK,YAAY;QAC7B;MACF;AAQA,UAAI,2BAA2B,CAAC,EAAE,UAAU,KAAK,cAAc;AAC/D,UAAI,wBAAwB;AAI5B,eAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,EAAE,GAAG;AACzC,cAAM,eAAe,UAAU,CAAC;AAEhC,YAAI,aAAa,IAAI,SAAS,GAAG;AAC/B,cAAI,CAAC,qBAAqB,IAAI,SAAS,GAAG;AACxC,gBAAI,uBAAuB;yBACzB,UAAU,KAAxB,KAEgB,UACA,SAHhB;YAKY;AAKA,iCAAqB,IAAI,SAAS;UACpC;AACA,iBAAO;QACT;AAEA,qBAAa,QAAQ,YAAY;AAEjC,YACE;;QAGA,MAAM,UAAU,SAAS;;;;QAKzB,0BAA0B,SAAS,cAAc,QAAS,SAAS,GACnE;AAIA,qCAA2B;AAC3B,kCAAwB;AAMxB,eAAK,cAAc,QAAQ,CAAC,QAAQ,gBAA9C;AACY,kBAAM,QAAQ,SAAS,MAAM,MAAM;AACnC,gBAAI,SAAS,MAAM,CAAC,MAAM,UAAU;AAClC,2BAAa,WAAW;YAC1B;UACF,CAAC;QACH;MACF;IACF;AAEA,WAAO;EACT;EAEO,WAAW,UAA8B,WAAlD;AACI,UAAM,SAAS,KAAK,eAAe,UAAU,SAAS;AACtD,WAAO,CAAC,EAAE,UAAU,OAAO;EAC7B;EAEO,kBAAkB,WAA3B;AACI,UAAM,EAAE,UAAU,UAAtB,IAAoC;AAChC,UAAM,SAAS,KAAK,eAAe,UAAU,SAAS;AACtD,QAAI;AAEJ,QAAI,QAAQ,UAAU,OAAO;AAC7B,QAAI,SAAS,UAAU;AACrB,YAAM,UAA0C;QAC9C;QACA;QACA,OAAO,UAAU,SAAS;QAC1B,WAAW,UAAU;MAC7B;AACM,YAAM,OAAO,uBAAuB,SAAS;AAC7C,aAAO,OAAO;AACZ,cAAM,oBAAoB,MAAM,MAAM,OAAO;AAC7C,YAAI,QAAQ,iBAAiB,GAAG;AAC9B,kBAAQ,uBAAuB,iBAAiB;QAClD,OAAO;AAGL,2BAAiB,qBAAqB;AACtC;QACF;MACF;IACF;AAEA,QAAI,mBAAmB,QAAQ;AAC7B,uBACE,UAAU,QACR,sBAAsB,UAAU,OAAO,UAAU,SAAS,IAC1D,gBAAgB,WAAW,uBAAuB,SAAS,CAAC;IAClE;AAIA,QAAI,mBAAmB,OAAO;AAC5B,aAAO;IACT;AAKA,WAAO,cAAc,uBAAuB,cAAc,IAAI,iBAC1D,YAAY,MAAM;EACxB;EAEO,UACL,SACA,SAFJ;AAII,UAAM,oBAAoB,QAAQ;AAClC,QAAI,CAAC;AAAmB;AAExB,UAAM,cAAc,QAAQ,SAAS,QAAQ;AAC7C,QAAI,CAAC;AAAa;AAElB,QAAI,QAAQ,aAAa,QAAQ;AAC/B,YAAM,WAAW,QAAQ,MAAM,cAC7B,mBACA,YAAY;AAEd,UAAI;AAAU,gBAAQ,WAAW;IACnC;AAEA,UAAM,iBAAiB,KAAK,kBAAkB,OAAO;AACrD,UAAM,YAAY,uBAAuB,cAAc;AACvD,UAAM,WAAW,QAAQ,MAAM,cAC7B,mBACA,cAAc;AAEhB,UAAM,SAAS,KAAK,eAAe,QAAQ,UAAU,SAAS;AAC9D,UAAM,OAAO,UAAU,OAAO;AAE9B,QAAI,MAAM;AACR,YAAM,cAAc,yBAClB,MACA,mBACA,SACA,SACA,QAAQ,MAAM,WACZ,YAAY,iBAAiB,IAC3B,kBAAkB,QAClB,mBACF,cAAc,CACf;AAIH,aAAO,UAAU,UAAU,KAAK,OAAO,MAAM;QAC3C;QACA;MACR,CAAO;IACH;AAEA,WAAO;EACT;EAEO,gBACL,UACA,WAFJ;AAII,UAAM,SAAS,KAAK,eAAe,UAAU,SAAS;AACtD,WAAO,UAAU,OAAO;EAC1B;EAEO,iBACL,gBACA,WACA,eAHJ;AAKI,QAAI,SAGY,KAAK,eAAe,gBAAgB,SAAS;AAC7D,QAAI,QAAQ,UAAU,OAAO;AAC7B,QAAI,CAAC,SAAS,eAAe;AAC3B,eAAS,KAAK,cAAc,aAAa;AACzC,cAAQ,UAAU,OAAO;IAC3B;AACA,WAAO;EACT;EAEO,iBACL,UACA,UACA,EAAE,OAAO,UAAU,MAHvB,GAII,SACA,SALJ;AAOI,QAAI,UAAU,aAAa;AAIzB,aAAO,yBAAyB,QAAQ,KAAK,EAC3C,UACA,QAAuB;IAE3B;AAEA,QAAI,UAAU,cAAc;AAE1B,aAAO;IACT;AAMA,QAAI,QAAQ,WAAW;AACrB,iBAAW;IACb;AAEA,WAAO,MACL,UACA,UACA;MACE;;;;;;;;;;;;MAYA;MACA;QACE;QACA,WAAW,MAAM,KAAK;QACtB;QACA,WAAW,QAAQ;MAC7B;MACQ;MACA,WAAW,CAFnB;IAEqB,CACd;EAEL;AACF;AAEA,SAAS,yBACP,UACA,mBACA,WACA,SACA,SALF;AAOE,QAAM,iBAAiB,SAAS,kBAAkB,SAAS;AAC3D,QAAM,YAAY,uBAAuB,cAAc;AACvD,QAAM,YAAY,UAAU,aAAa,QAAQ;AACjD,QAAM,EAAE,aAAa,QAAvB,IAAmC,QAAQ;AAEzC,SAAO;IACL,MAAM,uBAAuB,SAAS;IACtC,OAAO,UAAU,SAAS;IAC1B;IACA;IACA;IACA;IACA;IACA;IACA,OAAO,SAAS;IAChB;IACA,aAAgB,MAApB;AACM,aAAO,SAAS,UACd,0BAA0B,MAAM,mBAAmB,SAAS,GAC5D,OAAO;IAEX;IACA,cAAc,yBAAyB,QAAQ,KAAK;EACxD;AACA;AAEA,SAAgB,0BACd,eACA,mBACA,WAHF;AAKE,QAAM,EAAE,GAAG,oBAAoB,GAAGE,OAAM,QAAQ,KAAlD,IAA2D;AAEzD,MAAI;AAEJ,MAAI,OAAO,uBAAuB,UAAU;AAC1C,cAAU;MACR,WAAW;;;;MAIX,MAAM,OAAO,IAAIA,QAAO;IAC9B;EACE,OAAO;AACL,cAAU,EAAE,GAAG,mBAAnB;AAGI,QAAI,CAAC,OAAO,KAAK,SAAS,MAAM,GAAG;AACjC,cAAQ,OAAO;IACjB;EACF;AAEA,MAAI,WAAW,QAAQ,SAAS,QAAQ;eACtC,UAAU,KAAd,KAEM,oBAAoB,MAAM,KAAK,aAAa,CAAC,CAAA;EAEjD;AAEA,MAAI,WAAW,QAAQ,WAAW;AAChC,YAAQ,YAAY;EACtB;AAEA,SAAO;AACT;AAEA,SAAS,yBACP,OADF;SAGS,SAAS,aAAa,UAAU,UAAzC;AACI,QAAI,QAAQ,QAAQ,KAAK,QAAQ,QAAQ,GAAG;AAC1C,YAAM,kBAAZ,GAAA;IACI;AAMA,QAAI,gBAAgB,QAAQ,KAAK,gBAAgB,QAAQ,GAAG;AAC1D,YAAM,QAAQ,MAAM,cAAc,UAAU,YAAY;AACxD,YAAM,QAAQ,MAAM,cAAc,UAAU,YAAY;AACxD,YAAM,cAAc,SAAS,SAAS,UAAU;AAEhD,UAAI,aAAa;AACf,eAAO;MACT;AAEA,UAAI,YAAY,QAAQ,KAAK,wBAAwB,QAAQ,GAAG;AAI9D,cAAM,MAAM,SAAS,OAAO,QAAQ;AACpC,eAAO;MACT;AAEA,UAAI,wBAAwB,QAAQ,KAAK,YAAY,QAAQ,GAAG;AAK9D,cAAM,MAAM,UAAU,SAAS,KAAK;AACpC,eAAO;MACT;AAEA,UACE,wBAAwB,QAAQ,KAChC,wBAAwB,QAAQ,GAChC;AACA,eAAO,EAAE,GAAG,UAAU,GAAG,SAAjC;MACM;IACF;AAEA,WAAO;EACT;AACF;;;AC19BA,SAAS,wBACP,SADF;AAGE,SAAO,CAAC,QAAQ,cAAc,QAAQ,mBAAmB,QAAQ,OAAO;AAC1E;AAEA,IAAa,cAAb,MAAA;EAsBE,YAAY,QAAd;AApBU;;AAOA;;AAMA;AAKA,wCAAe,oBAAI,QAA7B;AAGI,SAAK,SAAS;AAMd,SAAK,sBAAsB,KACzB,CAAC,YADP;AAEQ,YAAM,WAAW,wBAAwB,OAAO;AAEhD,YAAM,QAAQ,KAAK,oBAAoB,KAAK,GAAG,QAAQ;AAEvD,UAAI,OAAO;AAGT,eAAO;MACT;AAEA,qCACE,QAAQ,QAAQ,OAChB,QAAQ,aAAa,KAAK;AAK5B,aAAO,KAAK,qBAAqB,OAAO;IAC1C,GACA;MACE,KACE,WAAW,mCAAmC,KACxD;MACQ,SAAS;;;MAGT,aAAa,cAAc,QAAQ,SAA3C;AACU,YAAI,sBAAsB,QAAQ,KAAK,GAAG;AACxC,iBAAO,QAAQ,MAAM,aACnB,cACA,YAAY,MAAM,IAAI,OAAO,QAAQ,QACrC,QAAQ,SAAS;QAErB;MACF;IACR,CAAO;AAGH,SAAK,0BAA0B,KAC7B,CAAC,YADP;AAEQ,qCACE,QAAQ,QAAQ,OAChB,QAAQ,aAAa,KAAK;AAE5B,aAAO,KAAK,yBAAyB,OAAO;IAC9C,GACA;MACE,KACE,WAAW,uCAAuC,KAC5D;MACQ,aAAa,EAAE,OAAO,OAAO,QAArC,GAAA;AACU,YAAI,sBAAsB,QAAQ,KAAK,GAAG;AACxC,iBAAO,QAAQ,MAAM,aAAa,OAAO,OAAO,QAAQ,SAAS;QACnE;MACF;IACR,CAAO;EAEL;;;;;EAMO,sBAAyB,EAC9B,OACA,OACA,SAAS,cACT,WACA,oBAAoB,KALxB,GAAA;AAOI,UAAM,WAAW,KAAK,OAAO,MAAM;AAEnC,gBAAY;MACV,GAAG,iBAAiB,mBAAmB,KAAK,CAAC;MAC7C,GAAG;IACT;AAEI,UAAM,UAAU,cAAc,MAAM;AACpC,UAAM,aAAa,KAAK,oBAAoB;MAC1C,cAAc,kBAAkB,KAAK,EAAE;MACvC,mBAAmB;MACnB,cAAc;MACd,SAAS;QACP;QACA;QACA;QACA;QACA,WAAW,mBAAmB,SAAS;QACvC,GAAG,uBAAuB,OAAO,KAAK,OAAO,SAAS;MAC9D;IACA,CAAK;AAED,QAAI;AACJ,QAAI,WAAW,SAAS;AACtB,gBAAU,IAAI,kBACZ,aAAa,WAAW,OAAO,GAC/B,WAAW,SACX,OACA,SAAS;IAEb;AAEA,UAAM,WAAW,CAAC;AAClB,UAAM,EAAE,OAAZ,IAAuB;AAEnB,WAAO;MACL,QACE,YAAY,oBACV,OAAO,KAAK,MAAM,EAAE,WAAW,IAC7B,OACA,SACF;MACJ;MACA;IACN;EACE;EAEO,QACL,QACA,QACA,cACA,SAJJ;AAMI,QACE,sBAAsB,QAAQ,KAAK,KACnC,KAAK,aAAa,IAAI,MAAM,MAAM,cAClC;AACA,YAAM,SAAS,KAAK,oBAAoB,KACtC,cACA,QACA,OAAO;AAET,UAAI,UAAU,WAAW,OAAO,QAAQ;AACtC,eAAO;MACT;IACF;AACA,WAAO;EACT;;EAGQ,qBAAqB,EAC3B,cACA,mBACA,cACA,QAJJ,GAAA;AAMI,QACE,YAAY,iBAAiB,KAC7B,CAAC,QAAQ,SAAS,kBAAkB,kBAAkB,KAAK,KAC3D,CAAC,QAAQ,MAAM,IAAI,kBAAkB,KAAK,GAC1C;AACA,aAAO;QACL,QAAQ,CAAhB;QACQ,SAAS,iCAAiC,kBAAkB,KAAK;MACzE;IACI;AAEA,UAAM,EAAE,WAAW,UAAU,MAAjC,IAA2C;AACvC,UAAM,WAAW,MAAM,cACrB,mBACA,YAAY;AAGd,UAAM,iBAAwC,CAAlD;AACI,QAAI;AACJ,UAAM,gBAAgB,IAAI,WAA9B;AAEI,QAAI,OAAO,aAAa,YAAY,CAAC,SAAS,kBAAkB,QAAQ,GAAG;AAIzE,qBAAe,KAAK,EAAE,YAAY,SAAxC,CAAkD;IAC9C;AAEA,aAAS,cAAiBC,SAAuB,YAArD;AACM,UAAIA,QAAO,SAAS;AAClB,kBAAU,cAAc,MAAM,SAAS;UACrC,CAAC,UAAU,GAAGA,QAAO;QAC/B,CAAS;MACH;AACA,aAAOA,QAAO;IAChB;AAEA,UAAM,UAAU,IAAI,IAAI,aAAa,UAAU;AAE/C,YAAQ,QAAQ,CAAC,cAArB;AAGM,UAAI,CAAC,cAAc,WAAW,SAAS;AAAG;AAE1C,UAAI,QAAQ,SAAS,GAAG;AACtB,YAAI,aAAa,SAAS,UACxB;UACE,WAAW,UAAU,KAAK;UAC1B,OAAO;UACP,WAAW,QAAQ;UACnB,MAAM;QAClB,GACU,OAAO;AAGT,cAAM,aAAa,uBAAuB,SAAS;AAEnD,YAAI,eAAe,QAAQ;AACzB,cAAI,CAAC,sBAAsB,MAAM,SAAS,GAAG;AAC3C,sBAAU,cAAc,MAAM,SAAS;cACrC,CAAC,UAAU,GAAG,qBAAqB,UAAU,KAAK,KAAK,QACrD,YAAY,iBAAiB,IAC3B,kBAAkB,QAAQ,YAC1B,YAAY,KAAK,UAAU,mBAAmB,MAAM,CAAC,CACzD;YACd,CAAa;UACH;QACF,WAAW,QAAQ,UAAU,GAAG;AAC9B,cAAI,WAAW,SAAS,GAAG;AACzB,yBAAa,cACX,KAAK,wBAAwB;cAC3B,OAAO;cACP,OAAO;cACP;cACA;YAChB,CAAe,GACD,UAAU;UAEd;QACF,WAAW,CAAC,UAAU,cAAc;QAEpC,WAAW,cAAc,MAAM;AAI7B,uBAAa,cACX,KAAK,oBAAoB;YACvB,cAAc,UAAU;YACxB,mBAAmB;YACnB,cAAc,YAAY,UAAU,IAAI,aAAa;YACrD;UACd,CAAa,GACD,UAAU;QAEd;AAEA,YAAI,eAAe,QAAQ;AACzB,yBAAe,KAAK,EAAE,CAAC,UAAU,GAAG,WAA9C,CAA0D;QAClD;MACF,OAAO;AACL,cAAM,WAAW,yBACf,WACA,QAAQ,cAAc;AAGxB,YAAI,CAAC,YAAY,UAAU,SAAS,KAAK,iBAAiB;AACxD,gBAAM,kBAAhB,KAA0D,UAAU,KAAK,KAAzE;QACQ;AAEA,YAAI,YAAY,SAAS,gBAAgB,UAAU,QAAQ,GAAG;AAC5D,mBAAS,aAAa,WAAW,QAAQ,QAAQ,KAAK,OAAO;QAC/D;MACF;IACF,CAAC;AAED,UAAM,SAAS,eAAe,cAAc;AAC5C,UAAM,cAA0B,EAAE,QAAQ,QAA9C;AACI,UAAM,SAAS,gBAAgB,WAAW;AAI1C,QAAI,OAAO,QAAQ;AACjB,WAAK,aAAa,IAAI,OAAO,QAAQ,YAAY;IACnD;AAEA,WAAO;EACT;;EAGQ,yBAAyB,EAC/B,OACA,OACA,cACA,QAJJ,GAAA;AAMI,QAAI;AACJ,QAAI,gBAAgB,IAAI,WAA5B;AAEI,aAAS,cAAiB,aAA4B,GAA1D;AACM,UAAI,YAAY,SAAS;AACvB,kBAAU,cAAc,MAAM,SAAS,EAAE,CAAC,CAAC,GAAG,YAAY,QAAlE,CAA2E;MACrE;AACA,aAAO,YAAY;IACrB;AAEA,QAAI,MAAM,cAAc;AACtB,cAAQ,MAAM,OAAO,QAAQ,MAAM,OAAO;IAC5C;AAEA,YAAQ,MAAM,IAAI,CAAC,MAAM,MAA7B;AAEM,UAAI,SAAS,MAAM;AACjB,eAAO;MACT;AAGA,UAAI,QAAQ,IAAI,GAAG;AACjB,eAAO,cACL,KAAK,wBAAwB;UAC3B;UACA,OAAO;UACP;UACA;QACZ,CAAW,GACD,CAAC;MAEL;AAGA,UAAI,MAAM,cAAc;AACtB,eAAO,cACL,KAAK,oBAAoB;UACvB,cAAc,MAAM;UACpB,mBAAmB;UACnB,cAAc,YAAY,IAAI,IAAI,OAAO;UACzC;QACZ,CAAW,GACD,CAAC;MAEL;AAEA,UAAI,SAAS;AACX,qCAA6B,QAAQ,OAAO,OAAO,IAAI;MACzD;AAEA,aAAO;IACT,CAAC;AAED,WAAO;MACL,QAAQ;MACR;IACN;EACE;AACF;AAEA,SAAS,aAAa,MAAtB;AACE,MAAI;AACF,SAAK,UAAU,MAAM,CAAC,GAAG,UAA7B;AACM,UAAI,OAAO,UAAU;AAAU,cAAM;AACrC,aAAO;IACT,CAAC;EACH,SAAS,QAAQ;AACf,WAAO;EACT;AACF;AAEA,SAAS,6BACP,OACA,OACA,YAHF;AAKE,MAAI,CAAC,MAAM,cAAc;AACvB,UAAM,UAAU,oBAAI,IAAI,CAAC,UAAU,CAAC;AACpC,YAAQ,QAAQ,CAAC,UAArB;AACM,UAAI,gBAAgB,KAAK,GAAG;AAC1B;UACE,CAAC,YAAY,KAAK;;UAElB,2BAA2B,OAAO,KAAK;UACvC,MAAM,KAAK;;AAEb,eAAO,OAAO,KAAK,EAAE,QAAQ,QAAQ,KAAK,OAAO;MACnD;IACF,CAAC;EACH;AACF;;;ACtZA,SAAS,iBACP,SACA,YACA,UAHF;AAKE,QAAM,MAAM,GAAG,UAAU,GAAG,QAAQ;AACpC,MAAI,WAAW,QAAQ,QAAQ,IAAI,GAAG;AACtC,MAAI,CAAC,UAAU;AACb,YAAQ,QAAQ,IACd,KACC,WACC,QAAQ,eAAe,cAAc,QAAQ,aAAa,WACxD,UACA;MACE,GAAG;MACH;MACA;IACZ,CAAY;EAEV;AACA,SAAO;AACT;AAUA,IAAa,cAAb,MAAA;EACE,YACkB,OACR,QACA,WAHZ;AACoB;AACR;AACA;AAFQ,SAApB,QAAoB;AACR,SAAZ,SAAY;AACA,SAAZ,YAAY;EACP;EAEI,aAIL,OACA,EACE,OACA,QACA,QACA,WACA,UAVN,GAAA;AAaI,UAAM,sBAAsB,uBAAuB,KAAK;AACxD,UAAM,SAAS,0BAAnB;AAEI,gBAAY;MACV,GAAG,iBAAiB,mBAAmB;MACvC,GAAG;IACT;AAEI,UAAM,UAAwB;MAC5B;MACA,SAAS,CAAf;MACM,MAAS,UAAa,UAA5B;AACQ,eAAO,OAAO,MAAM,UAAU,QAAQ;MACxC;MACA;MACA,WAAW,mBAAmB,SAAS;MACvC,GAAG,uBAAuB,OAAO,KAAK,SAAS;MAC/C,WAAW,CAAC,CAAC;MACb,cAAc,oBAAI,IAAxB;MACM,YAAY;MACZ,UAAU;MACV,SAAS,oBAAI,IAAnB;IACA;AAEI,UAAM,MAAM,KAAK,oBAAoB;MACnC,QAAQ,UAAU,CAAxB;MACM;MACA,cAAc,oBAAoB;MAClC,WAAW,EAAE,KAAK,oBAAI,IAA5B,EAAA;MACM;IACN,CAAK;AAED,QAAI,CAAC,YAAY,GAAG,GAAG;AACrB,YAAM,kBAAZ,KAA8D,MAA9D;IACI;AAIA,YAAQ,aAAa,QACnB,CAAC,EAAE,aAAa,WAAW,aADjC,GACiDC,YADjD;AAEQ,YAAM,YAAY,cAAcA,OAAM;AAEtC,UAAI,aAAa,UAAU,IAAI,MAAM;AACnC,cAAM,UAAU,KAAK,YACnB,WACA,WACA,aACA,OAAO;AAET,YAAI,YAAY,OAAO,GAAG;AAIxB;QACF;AAGA,sBAAc;MAChB;AAEA,UAAI,WAAW,CAAC,QAAQ,WAAW;AACjC,cAAM,0BAAgD,CAAhE;AACU,qBAAa,QAAQ,CAAC,UAAhC;AACY,cAAI,MAAM,cAAc;AACtB,oCAAwB,MAAM,KAAK,KAAK,IAAI;UAC9C;QACF,CAAC;AAED,cAAM,kBAAkB,CAAC,mBACvB,wBAAwB,uBAAuB,cAAc,CAAC,MAC9D;AAEF,cAAM,mBAAmB,CAAC,mBAApC;AACY,gBAAM,YAAY,aAAa,UAAU,IAAI,IAAI,cAAc;AAC/D,iBAAO,QAAQ,aAAa,UAAU,QAAQ,UAAU,KAAK,KAAK;QACpE;AAEA,eAAO,KAAK,WAAW,EAAE,QAAQ,CAAC,mBAA5C;AAKY,cACE,gBAAgB,cAAc,KAC9B,CAAC,iBAAiB,cAAc,GAChC;AACA,8BACE,WACA,aACA,gBACA,QAAQ,KAAK;UAEjB;QACF,CAAC;MACH;AAEA,YAAM,MAAMA,SAAQ,WAAW;IACjC,CAAC;AAQH,UAAM,OAAO,IAAI,KAAK;AAEtB,WAAO;EACT;EAEQ,oBAAoB;IAC1B;IACA;IACA;IACA;;;IAGA;EAAJ,GAAA;AAEI,UAAM,EAAE,SAAZ,IAAyB,KAAK;AAI1B,QAAI,WAAwB,CAAhC;AAKI,UAAM,WACH,UAAU,SAAS,kBAAkB,MAAM,KAC5C,sBAAsB,QAAQ,cAAc,QAAQ,WAAW,KAC9D,UAAW,QAAQ,MAAM,IAAI,QAAQ,YAAY;AAEpD,QAAI,aAAa,OAAO,UAAU;AAChC,eAAS,aAAa;IACxB;AAUA,UAAM,YAA+B,IAAI,SAA7C;AACM,YAAM,UAAU,0BACd,MACA,UACA,QAAQ,SAAS;AAGnB,UAAI,YAAY,QAAQ,IAAI,GAAG;AAC7B,cAAM,OAAO,QAAQ,aAAa,IAAI,QAAQ,KAAK,KAAK;AACxD,YAAI,MAAM;AACR,gBAAMC,UAAS,SAAS,UACtB;YACE,GAAG;YACH,MAAM,KAAK;UACzB,GACY,OAAO;AAGT,cAAIA,YAAW,QAAQ;AACrB,mBAAOA;UACT;QACF;MACF;AAEA,aAAO,SAAS,UAAU,SAAS,OAAO;IAC5C;AAEA,UAAM,eAAe,oBAAI,IAA7B;AAEI,SAAK;MACH;MACA;;;;MAIA;MACA;IAAQ,EACR,QAAQ,CAACC,UAAS,UAFxB;AAGM,YAAM,iBAAiB,uBAAuB,KAAK;AACnD,YAAM,QAAQ,OAAO,cAAc;AAEnC,mBAAa,IAAI,KAAK;AAEtB,UAAI,UAAU,QAAQ;AACpB,cAAM,iBAAiB,SAAS,kBAAkB;UAChD;UACA,WAAW,MAAM,KAAK;UACtB;UACA,WAAWA,SAAQ;QAC7B,CAAS;AAED,cAAM,YAAY,kBAAkB,WAAW,cAAc;AAE7D,YAAI,gBAAgB,KAAK;UACvB;UACA;;;UAGA,MAAM,eACJ,iBAAiBA,UAAS,OAAO,KAAK,IACtCA;UACF;QAAS;AAMX,YAAI;AAIJ,YACE,MAAM,iBACL,YAAY,aAAa,KAAK,wBAAwB,aAAa,IACpE;AACA,0BAAgB,UAAkB,cAAc,aAAa;QAC/D;AAEA,cAAM,QAAQ,SAAS,iBACrB,UACA,MAAM,KAAK,OACX,aAAa;AAGf,YAAI,OAAO;AACT,oBAAU,OAAO;;YAEf;YACA;YACA;UACZ;QACQ,OAAO;AACL,qCAA2B,WAAW,cAAc;QACtD;AAEA,mBAAWA,SAAQ,MAAM,UAAU;UACjC,CAAC,cAAc,GAAG;QAC5B,CAAS;MACH,WACE,WACA,CAACA,SAAQ,cACT,CAACA,SAAQ,YACT,CAAC,sBAAsB,MAAM,KAAK;;;MAIlC,CAAC,SAAS,gBAAgB,UAAU,MAAM,KAAK,KAAK,GACpD;AACA,kBAAU,MAAlB,KAEU,uBAAuB,KAAK,GAC5B,MAHV;MAKM;IACF,CAAC;AAID,QAAI;AACF,YAAM,CAAC,IAAI,SAAS,IAAI,SAAS,SAAS,QAAQ;QAChD;QACA;QACA,aAAa,QAAQ;QACrB,aAAa;QACb;MACR,CAAO;AAID,eAAS,UAAU;AAInB,UAAI,WAAW;AAEb,mBAAW,QAAQ,MAAM,UAAU,SAAS;MAC9C;IACF,SAAS,GAAG;AAEV,UAAI,CAAC;AAAQ,cAAM;IACrB;AAEA,QAAI,aAAa,OAAO,QAAQ;AAC9B,YAAM,UAAU,cAAc,MAAM;AAOpC,YAAM,OAAO,QAAQ,QAAQ,MAAM,MAAM,QAAQ,QAAQ,MAAM,IAAI,CAAzE;AACM,UAAI,KAAK,QAAQ,YAAY,KAAK;AAAG,eAAO;AAC5C,WAAK,KAAK,YAAY;AAOtB,UACE,KAAK,UACL,KAAK,OAAO,QAAQ,QAAQ,SAAS,cAAc,OAAO,GAC1D;AACA,eAAO;MACT;AAEA,YAAM,WAAW,QAAQ,aAAa,IAAI,MAAM;AAChD,UAAI,UAAU;AACZ,iBAAS,cAAc,QAAQ,MAAM,SAAS,aAAa,QAAQ;AACnE,iBAAS,YAAY,gBAAgB,SAAS,WAAW,SAAS;AAClE,qBAAa,QAAQ,CAAC,UAAU,SAAS,aAAa,IAAI,KAAK,CAAC;MAClE,OAAO;AACL,gBAAQ,aAAa,IAAI,QAAQ;UAC/B,aAAa;;;;UAIb,WAAW,iBAAiB,SAAS,IAAI,SAAS;UAClD;QACV,CAAS;MACH;AAEA,aAAO;IACT;AAEA,WAAO;EACT;EAEQ,kBACN,OACA,OACA,SACA,WAJJ;AAMI,QAAI,CAAC,MAAM,gBAAgB,UAAU,MAAM;AAIzC,aAAO,UAAU,UAAU,KAAK,IAAI;IACtC;AAEA,QAAI,QAAQ,KAAK,GAAG;AAClB,aAAO,MAAM,IAAI,CAAC,MAAM,MAA9B;AACQ,cAAMC,SAAQ,KAAK,kBACjB,MACA,OACA,SACA,kBAAkB,WAAW,CAAC,CAAC;AAEjC,mCAA2B,WAAW,CAAC;AACvC,eAAOA;MACT,CAAC;IACH;AAEA,WAAO,KAAK,oBAAoB;MAC9B,QAAQ;MACR,cAAc,MAAM;MACpB;MACA;IACN,CAAK;EACH;;;EAIQ,cAWN,cACA,QACA,SACA,WAAW,sBAAsB,QAAQ,cAAc,QAAQ,WAAW,GAd9E;AAgBI,UAAM,WAAW,oBAAI,IAAzB;AACI,UAAM,EAAE,SAAZ,IAAyB,KAAK;AAE1B,UAAM,eAAe,IAAI,KAUtB,KAAK;AAER,KAAC,SAAS,QAERC,eACA,kBAHN;AAKM,YAAM,cAAc,aAAa;QAC/BA;;;;;QAKA,iBAAiB;QACjB,iBAAiB;MAAQ;AAE3B,UAAI,YAAY;AAAS;AACzB,kBAAY,UAAU;AAEtB,MAAAA,cAAa,WAAW,QAAQ,CAAC,cAAvC;AACQ,YAAI,CAAC,cAAc,WAAW,QAAQ,SAAS;AAAG;AAElD,YAAI,EAAE,YAAY,SAA1B,IAAuC;AAC/B;;;;UAIE,EAAE,cAAc,aAChB,gBAAgB,UAAU,UAAU;UACpC;AACA,oBAAU,WAAW,QAAQ,CAAC,QAAxC;AACY,kBAAM,OAAO,IAAI,KAAK;AACtB,gBAAI,SAAS;AAAU,2BAAa;AACpC,gBAAI,SAAS,SAAS;AACpB,oBAAM,OAAO,yBAAyB,KAAK,QAAQ,SAAS;AAK5D,kBAAI,CAAC,QAAS,KAA0B,OAAO,OAAO;AACpD,2BAAW;cACb;YAGF;UACF,CAAC;QACH;AAEA,YAAI,QAAQ,SAAS,GAAG;AACtB,gBAAM,WAAW,SAAS,IAAI,SAAS;AACvC,cAAI,UAAU;AAIZ,yBAAa,cAAc,SAAS;AACpC,uBAAW,YAAY,SAAS;UAClC;AAEA,mBAAS,IACP,WACA,iBAAiB,SAAS,YAAY,QAAQ,CAAC;QAEnD,OAAO;AACL,gBAAM,WAAW,yBACf,WACA,QAAQ,cAAc;AAGxB,cAAI,CAAC,YAAY,UAAU,SAAS,KAAK,iBAAiB;AACxD,kBAAM,kBAAlB,KAEc,UAAU,KAAK,KAF7B;UAIU;AAEA,cACE,YACA,SAAS,gBACP,UACA,UACA,QACA,QAAQ,SAAS,GAEnB;AACA,oBACE,SAAS,cACT,iBAAiB,SAAS,YAAY,QAAQ,CAAC;UAEnD;QACF;MACF,CAAC;IACH,GAAG,cAAc,OAAO;AAExB,WAAO;EACT;EAEQ,YACN,WACA,UACA,UACA,SACA,gBALJ;AAOI,QAAI,UAAU,IAAI,QAAQ,CAAC,YAAY,QAAQ,GAAG;AAChD,YAAM;;;;QAKF,CAAC,QAAQ,QAAQ;;;SAIhB,YAAY,QAAQ,KAAK,wBAAwB,QAAQ,KAE1D,WACA;;AAKJ,YAAM,IAAI;AAMV,UAAI,KAAK,CAAC,gBAAgB;AACxB,yBAAiB,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC;MAChD;AAOA,UAAI;AAEJ,YAAM,WAAW,CACfC,OACA,SAFR;AAIQ,eACE,QAAQA,KAAI,IACV,OAAO,SAAS,WACdA,MAAK,IAAI,IACT,SACF,QAAQ,MAAM,cAAcA,OAAM,OAAO,IAAI,CAAC;MAEpD;AAEA,gBAAU,IAAI,QAAQ,CAAC,WAAW,mBAAxC;AACQ,cAAM,OAAO,SAAS,GAAG,cAAc;AACvC,cAAM,OAAO,SAAS,GAAG,cAAc;AAEvC,YAAI,WAAW;AAAM;AACrB,YAAI,gBAAgB;AAClB,yBAAe,KAAK,cAAc;QACpC;AACA,cAAM,OAAO,KAAK,YAChB,WACA,MACA,MACA,SACA,cAAc;AAEhB,YAAI,SAAS,MAAM;AACjB,0BAAgB,iBAAiB,oBAAI,IAA/C;AACU,wBAAc,IAAI,gBAAgB,IAAI;QACxC;AACA,YAAI,gBAAgB;AAClB,oBAAU,eAAe,IAAnC,MAA6C,cAAc;QACnD;MACF,CAAC;AAED,UAAI,eAAe;AAEjB,mBAAY,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,GAAG,EAAnD;AACQ,sBAAc,QAAQ,CAAC,OAAO,SAAtC;AACW,mBAAiB,IAAI,IAAI;QAC5B,CAAC;MACH;IACF;AAEA,QAAI,UAAU,MAAM;AAClB,aAAO,KAAK,MAAM,SAAS,iBACzB,UACA,UACA,UAAU,MACV,SACA,kBAAkB,QAAQ,MAAM,WAAW,GAAG,cAAc,CAAC;IAEjE;AAEA,WAAO;EACT;AACF;AAEA,IAAM,qBAAkC,CAAxC;AAEA,SAAS,kBACP,EAAE,KAAAC,KADJ,GAEE,MAFF;AAIE,MAAI,CAACA,KAAI,IAAI,IAAI,GAAG;AAClB,IAAAA,KAAI,IAAI,MAAM,mBAAmB,IAArC,KAA8C,EAAE,KAAK,oBAAI,IAAzD,EAAA,CAAgE;EAC9D;AACA,SAAOA,KAAI,IAAI,IAAI;AACrB;AAEA,SAAS,gBACP,MACA,OAFF;AAIE,MAAI,SAAS,SAAS,CAAC,SAAS,iBAAiB,KAAK;AAAG,WAAO;AAChE,MAAI,CAAC,QAAQ,iBAAiB,IAAI;AAAG,WAAO;AAE5C,QAAM,OACJ,KAAK,QAAQ,MAAM,OACjB;IACE,GAAG,KAAK;IACR,GAAG,MAAM;EACjB,IACM,KAAK,QAAQ,MAAM;AAEvB,QAAM,kBAAkB,KAAK,IAAI,QAAQ,MAAM,IAAI;AACnD,QAAMA,OACJ,kBAAkB,oBAAI,IAD1B,IAEM,KAAK,IAAI,OAAO,KAAK,MACrB,MAAM;AAEV,QAAM,SAAS,EAAE,MAAM,KAAAA,KAAzB;AAEE,MAAI,iBAAiB;AACnB,UAAM,qBAAqB,IAAI,IAAI,MAAM,IAAI,KAAjD,CAAuD;AAEnD,SAAK,IAAI,QAAQ,CAAC,UAAU,QAAhC;AACM,aAAO,IAAI,IAAI,KAAK,gBAAgB,UAAU,MAAM,IAAI,IAAI,GAAG,CAAC,CAAC;AACjE,yBAAmB,OAAO,GAAG;IAC/B,CAAC;AAED,uBAAmB,QAAQ,CAAC,QAAhC;AACM,aAAO,IAAI,IACT,KACA,gBAAgB,MAAM,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,IAAI,GAAG,CAAC,CAAC;IAE1D,CAAC;EACH;AAEA,SAAO;AACT;AAEA,SAAS,iBAAiB,MAA1B;AACE,SAAO,CAAC,QAAQ,EAAE,KAAK,QAAQ,KAAK,IAAI;AAC1C;AAEA,SAAS,2BAA2B,EAAE,KAAAA,KAAtC,GAAwD,MAAxD;AACE,QAAM,YAAYA,KAAI,IAAI,IAAI;AAC9B,MAAI,aAAa,iBAAiB,SAAS,GAAG;AAC5C,uBAAmB,KAAK,SAAS;AACjC,IAAAA,KAAI,OAAO,IAAI;EACjB;AACF;AAEA,IAAM,WAAW,oBAAI,IAArB;AAIA,SAAS,kBACP,aACA,aACA,gBACA,OAJF;AAME,QAAM,WAAW,CAAC,aAApB;AACI,UAAM,QAAQ,MAAM,cAA2B,UAAU,cAAc;AACvE,WAAO,OAAO,UAAU,YAAY;EACtC;AAEA,QAAM,WAAW,SAAS,WAAW;AACrC,MAAI,CAAC;AAAU;AAEf,QAAM,WAAW,SAAS,WAAW;AACrC,MAAI,CAAC;AAAU;AAIf,MAAI,YAAY,QAAQ;AAAG;AAI3B,MAAI,MAAM,UAAU,QAAQ;AAAG;AAK/B,MACE,OAAO,KAAK,QAAQ,EAAE,MACpB,CAAC,QAAQ,MAAM,cAAc,UAAU,GAAG,MAAM,MAAM,GAExD;AACA;EACF;AAEA,QAAM,aACJ,MAAM,cAAsB,aAAa,YAAY,KACrD,MAAM,cAAsB,aAAa,YAAY;AACvD,QAAM,YAAY,uBAAuB,cAAc;AACvD,QAAM,cAAc,GAAG,UAAU,IAAI,SAAS;AAE9C,MAAI,SAAS,IAAI,WAAW;AAAG;AAC/B,WAAS,IAAI,WAAW;AAExB,QAAM,iBAA2B,CAAnC;AAGE,MAAI,CAAC,QAAQ,QAAQ,KAAK,CAAC,QAAQ,QAAQ,GAAG;AAC5C,KAAC,UAAU,QAAQ,EAAE,QAAQ,CAAC,UAAlC;AACM,YAAM,WAAW,MAAM,cAAc,OAAO,YAAY;AACxD,UAAI,OAAO,aAAa,YAAY,CAAC,eAAe,SAAS,QAAQ,GAAG;AACtE,uBAAe,KAAK,QAAQ;MAC9B;IACF,CAAC;EACH;aAEA,UAAU,KAAZ,KAeI,WACA,YACA,eAAe,SACb,uCACE,eAAe,KAAK,OAAO,IAC3B,gDACF,IACF,aACA,EAAE,GAAG,SAFT,GAGI,EAAE,GAAG,SAHT,CAAA;AAKA;AAEA,SAAS,sBACP,QACA,cACA,aAHF;AAKE,MAAI;AACJ,aAAW,aAAa,aAAa,YAAY;AAC/C,QAAI,QAAQ,SAAS,GAAG;AACtB,UAAI,UAAU,KAAK,UAAU,cAAc;AACzC,eAAO,OAAO,uBAAuB,SAAS,CAAC;MACjD;IACF,WAAW,WAAW;AACpB,gBAAU,KAAK,SAAS;IAC1B,OAAO;AACL,kBAAY,CAAC,SAAS;IACxB;EACF;AACA,MAAI,OAAO,OAAO,eAAe,UAAU;AACzC,WAAO,OAAO;EAChB;AACA,MAAI,WAAW;AACb,eAAW,aAAa,WAAW;AACjC,YAAM,WAAW,sBACf,QACA,yBAAyB,WAAW,WAAW,EAAG,cAClD,WAAW;AAEb,UAAI,OAAO,aAAa,UAAU;AAChC,eAAO;MACT;IACF;EACF;AACF;;;ACz3BA,IAAa,gBAAb,cAAmC,YAAnC;EA4BE,YAAY,SAA8B,CAA5C,GAAA;AACI,UAAJ;AA5BU;AACA;AAEE;AACF,mCAAU,oBAAI,IAAxB;AAEU;AACA;AACA,gDAAuB,IAAI,kBAAkB,qBAAqB;AAElE;AAQQ;;kDAAyB;AAKzB;;;;AAEA,mCAAU;AA4UlB,mCAAU;AAxUhB,SAAK,SAAS,gBAAgB,MAAM;AAEpC,SAAK,WAAW,IAAI,SAAS;MAC3B,OAAO;MACP,kBAAkB,KAAK,OAAO;MAC9B,eAAe,KAAK,OAAO;MAC3B,cAAc,KAAK,OAAO;IAChC,CAAK;AAED,SAAK,KAAT;EACE;EAEQ,OAAV;AAII,UAAM,YAAa,KAAK,OAAO,IAAI,YAAY,KAAK;MAClD,UAAU,KAAK;MACf,eAAe,KAAK,OAAO;IACjC,CAAK;AAOD,SAAK,iBAAiB,UAAU;AAEhC,SAAK,iBAAT;EACE;EAEQ,mBAAV;AACI,UAAM,EAAE,UAAZ,IAA0B,KAAK;AAE3B,SAAK,qBAAqB,WAA9B;AACI,2CAAW;AAKX,SAAK,cAAc,IAAI,YACrB,MACC,KAAK,cAAc,IAAI,YAAY,EAAE,OAAO,MAAM,UAFzD,CAEoE,GAC9D,SAAS;AAGX,SAAK,sBAAsB,KACzB,CAAC,GAAuB,YAD9B;AAEQ,aAAO,KAAK,eAAe,GAAG,OAAO;IACvC,GACA;MACE,KACE,WAAW,mCAAmC,KACxD;MACQ,cAAc,CAAC,MAAvB;AAGU,cAAM,QAAQ,EAAE,aAAa,KAAK,iBAAiB,KAAK;AACxD,YAAI,sBAAsB,KAAK,GAAG;AAChC,gBAAM,EAAE,YAAY,IAAI,UAApC,IAAkD;AACtC,iBAAO,MAAM;YACX,EAAE;;;;;;;YAOF,EAAE;YACF,mBAAmB,EAAE,YAAY,IAAI,UADnD,CAC8D;UAAC;QAErD;MACF;IACR,CAAO;AAMH,yBAAI,IAAI,CAAC,KAAK,KAAK,OAAO,KAAK,eAAe,KAAK,CAAC,GAAE,QAAQ,CAAC,UAC7D,MAAM,aADZ,CAC0B;EAExB;EAEO,QAAQ,MAAjB;AACI,SAAK,KAAT;AAII,QAAI;AAAM,WAAK,KAAK,QAAQ,IAAI;AAChC,WAAO;EACT;EAEO,QAAQ,aAAsB,OAAvC;AACI,YAAQ,aAAa,KAAK,iBAAiB,KAAK,MAAM,QAA1D;EACE;EAYO,KACL,SADJ;AAGI,UAAM;;;;;;;;MAQJ,oBAAoB;IAA1B,IACQ;AAEJ,WAAO,KAAK,YAAY,sBAA6B;MACnD,GAAG;MACH,OAAO,QAAQ,aAAa,KAAK,iBAAiB,KAAK;MACvD,QAAQ,KAAK;MACb;IACN,CAAK,EAAE;EACL;EAEO,MAGL,SAHJ;AAII,QAAI;AACF,QAAE,KAAK;AACP,aAAO,KAAK,YAAY,aAAa,KAAK,MAAM,OAAO;IACzD,UAAJ;AACM,UAAI,CAAC,EAAE,KAAK,WAAW,QAAQ,cAAc,OAAO;AAClD,aAAK,iBAAb;MACM;IACF;EACF;EAEO,OACL,SADJ;AAGI,QAAI,OAAO,KAAK,SAAS,IAAI,KAAK,CAAC,QAAQ,IAAI;AAU7C,aAAO;IACT;AACA,UAAM,QAEF,QAAQ,aAER,KAAK,iBACL,KAAK;AACT,QAAI;AACF,QAAE,KAAK;AACP,aAAO,MAAM,OAAO,QAAQ,MAAM,cAAc,QAAQ,QAAQ,KAAK;IACvE,UAAJ;AACM,UAAI,CAAC,EAAE,KAAK,WAAW,QAAQ,cAAc,OAAO;AAClD,aAAK,iBAAb;MACM;IACF;EACF;EAEO,KAGL,SAHJ;AAII,WAAO,KAAK,YAAY,sBAAsB;MAC5C,GAAG;MACH,OAAO,QAAQ,aAAa,KAAK,iBAAiB,KAAK;MACvD,QAAQ,QAAQ,MAAM;MACtB,QAAQ,KAAK;IACnB,CAAK;EACH;EAEO,MAGL,OAHJ;AAII,QAAI,CAAC,KAAK,QAAQ,MAAM;AAWtB,kBAAY,IAAI;IAClB;AACA,SAAK,QAAQ,IAAI,KAAK;AACtB,QAAI,MAAM,WAAW;AACnB,WAAK,oBAAoB,KAAK;IAChC;AACA,WAAO,MAAX;AAIM,UAAI,KAAK,QAAQ,OAAO,KAAK,KAAK,CAAC,KAAK,QAAQ,MAAM;AACpD,oBAAY,IAAI;MAClB;AAIA,WAAK,oBAAoB,OAAO,KAAK;IACvC;EACF;EAEO,GAAG,SAAZ;AAKI,uBAAmB,MAAvB;AACI,IAAAC,OAAM,MAAV;AACI,UAAM,MAAM,KAAK,eAAe,GAApC;AACI,QAAI,WAAW,CAAC,KAAK,WAAW,QAAQ,kBAAkB;AACxD,WAAK,iBAAX;IACI;AACA,WAAO;EACT;;;;;;;;EASO,OAAO,QAAgB,YAAhC;AACI,YAAQ,aAAa,KAAK,iBAAiB,KAAK,MAAM,OAAO,MAAM;EACrE;;;;;;EAOO,QAAQ,QAAgB,YAAjC;AACI,YAAQ,aAAa,KAAK,iBAAiB,KAAK,MAAM,QAAQ,MAAM;EACtE;;;;;;;EAQO,SAAS,QAAlB;AACI,QAAI,YAAY,MAAM;AAAG,aAAO,OAAO;AACvC,QAAI;AACF,aAAO,KAAK,SAAS,SAAS,MAAM,EAAE,CAAC;IACzC,SAAS,GAAG;iBACV,UAAU,KAAK,CAAC;IAClB;EACF;EAEO,MAAM,SAAf;AACI,QAAI,CAAC,QAAQ,IAAI;AACf,UAAI,OAAO,KAAK,SAAS,IAAI,GAAG;AAG9B,eAAO;MACT;AACA,gBAAU,EAAE,GAAG,SAAS,IAAI,aAAlC;IACI;AACA,QAAI;AAKF,QAAE,KAAK;AAIP,aAAO,KAAK,eAAe,MAAM,SAAS,KAAK,IAAI;IACrD,UAAJ;AACM,UAAI,CAAC,EAAE,KAAK,WAAW,QAAQ,cAAc,OAAO;AAClD,aAAK,iBAAb;MACM;IACF;EACF;EAEO,MAAM,SAAf;AACI,SAAK,KAAT;AAEI,uBAAmB,MAAvB;AAEI,QAAI,WAAW,QAAQ,gBAAgB;AAGrC,WAAK,QAAQ,QAAQ,CAAC,UAAU,KAAK,oBAAoB,OAAO,KAAK,CAAC;AACtE,WAAK,QAAQ,MAAnB;AACM,kBAAY,IAAI;IAClB,OAAO;AAOL,WAAK,iBAAX;IACI;AAEA,WAAO,QAAQ,QAAnB;EACE;EAEO,iBAAiB,YAA1B;AACI,UAAM,oBAAoB,KAAK,eAAe,YAAY,UAAU;AACpE,QAAI,sBAAsB,KAAK,gBAAgB;AAC7C,WAAK,iBAAiB;AACtB,WAAK,iBAAX;IACI;EACF;EAIO,MACL,SADJ;AAGI,UAAM,EACJ,QACA,aAAa,MACb,kBACA,eAJN,IAKQ;AAEJ,QAAI;AACJ,UAAM,UAAU,CAAC,UAArB;AACM,YAAM,EAAE,MAAM,eAApB,IAAuC;AACjC,QAAE,KAAK;AACP,UAAI,OAAO;AACT,aAAK,OAAO,KAAK,iBAAiB;MACpC;AACA,UAAI;AACF,eAAQ,eAAe,OAAO,IAAI;MACpC,UAAN;AACQ,UAAE,KAAK;AACP,aAAK,OAAO;AACZ,aAAK,iBAAiB;MACxB;IACF;AAEA,UAAM,eAAe,oBAAI,IAA7B;AAEI,QAAI,kBAAkB,CAAC,KAAK,SAAS;AAUnC,WAAK,iBAAiB;QACpB,GAAG;QACH,eAAe,OAAvB;AACU,uBAAa,IAAI,KAAK;AACtB,iBAAO;QACT;MACR,CAAO;IACH;AAEA,QAAI,OAAO,eAAe,UAAU;AAIlC,WAAK,iBAAiB,KAAK,eAAe,SAAS,YAAY,OAAO;IACxE,WAAW,eAAe,OAAO;AAM/B,cAAQ,KAAK,IAAI;IACnB,OAAO;AAGL,cAAN;IACI;AAEA,QAAI,OAAO,qBAAqB,UAAU;AACxC,WAAK,iBAAiB,KAAK,eAAe,YAAY,gBAAgB;IACxE;AAKA,QAAI,kBAAkB,aAAa,MAAM;AACvC,WAAK,iBAAiB;QACpB,GAAG;QACH,eAAe,OAAO,MAA9B;AACU,gBAAM,SAAS,eAAe,KAAK,MAAM,OAAO,IAAI;AACpD,cAAI,WAAW,OAAO;AAIpB,yBAAa,OAAO,KAAK;UAC3B;AACA,iBAAO;QACT;MACR,CAAO;AAGD,UAAI,aAAa,MAAM;AACrB,qBAAa,QAAQ,CAAC,UAAU,KAAK,oBAAoB,MAAM,KAAK,CAAC;MACvE;IACF,OAAO;AAIL,WAAK,iBAAiB,OAAO;IAC/B;AAEA,WAAO;EACT;EAEO,mBACL,QACA,cAFJ;AAII,WAAO,KAAK,MAAM;MAChB;MACA,YAAY,gBAAgB,iBAAiB;IACnD,CAAK;EACH;EAEO,kBAAkB,UAA3B;AACI,WAAO,KAAK,qBAAqB,kBAC/B,KAAK,uBAAuB,QAAQ,CAAC;EAEzC;EAEO,gBACL,UACA,UAFJ;AAII,WAAO,KAAK,SAAS,gBAAgB,UAAU,QAAQ;EACzD;EAEO,eAAe,cAAxB;AAhhBA,QAAAC;AAihBI,aAAOA,MAAA,KAAK,OAAO,cAAZ,gBAAAA,IAAuB,OAAO,kBAAiB;EACxD;EAEU,iBAAiB,SAA7B;AACI,QAAI,CAAC,KAAK,SAAS;AACjB,WAAK,QAAQ,QAAQ,CAAC,MAAM,KAAK,oBAAoB,GAAG,OAAO,CAAC;IAClE;EACF;EAEQ,uBAAuB,UAAjC;AACI,UAAM,EAAE,UAAZ,IAA0B,KAAK;AAC3B,WAAO,YAAY,UAAU,UAAU,QAAQ,IAAI;EACrD;;;;;;;EAQQ,eAAe,GAAuB,SAAhD;AACI,UAAM,EAAE,SAAZ,IAAyB;AAQrB,UAAM,OAAO,KAAK,KAAU,CAAC;AAE7B,QAAI,SAAS;AACX,UAAI,EAAE,cAAc,OAAO,QAAQ,eAAe,UAAU;AAC1D,aAAK,4BAA4B;MACnC;AAEA,UACE,QAAQ,kBACR,QAAQ,eAAe,KAAK,MAAM,GAAG,MAAM,QAAQ,MAAM,OACzD;AAGA;MACF;IACF;AAEA,QAAI,CAAC,YAAY,CAAC,MAAM,SAAS,QAAQ,KAAK,MAAM,GAAG;AACrD,QAAE,SAAU,EAAE,WAAW,MAAO,QAAQ;IAC1C;EACF;AAUF;AAEA,IAAI,SAAS;AACX,gBAAc,UAAU,qBAAqB;AAC/C;;;AC7kBA,IAAY;CAAZ,SAAYC,gBAAa;AAMvB,EAAAA,eAAAA,eAAA,SAAA,IAAA,CAAA,IAAA;AAMA,EAAAA,eAAAA,eAAA,cAAA,IAAA,CAAA,IAAA;AAMA,EAAAA,eAAAA,eAAA,WAAA,IAAA,CAAA,IAAA;AAMA,EAAAA,eAAAA,eAAA,SAAA,IAAA,CAAA,IAAA;AAOA,EAAAA,eAAAA,eAAA,MAAA,IAAA,CAAA,IAAA;AAKA,EAAAA,eAAAA,eAAA,OAAA,IAAA,CAAA,IAAA;AAKA,EAAAA,eAAAA,eAAA,OAAA,IAAA,CAAA,IAAA;AAOA,EAAAA,eAAAA,eAAA,WAAA,IAAA,CAAA,IAAA;AACF,GAjDY,kBAAA,gBAAa,CAAA,EAAA;;;ACiDzB,IAAM,EAAE,QAAQ,eAAhB,IAAmC;AAmBnC,IAAM,gBAA6C;EACjD,SAAS;EACT,eAAe,cAAc;EAC7B,MAAM;EACN,WAAW;EACX,SAAS;AACX;AAEA,IAAMC,SAAqC;EACzC,SAAS;EACT,eAAe,cAAc;EAC7B,MAAM;EACN,WAAW;EACX,SAAS;AACX;AArFA;AAmiBU,YAAO;AApQjB,IAAa,kBAAb,MAAA;EAoEE,YAAY,EACV,cACA,SACA,mBAAmB,aAAa,UAAU,QAAQ,KAAK,EAH3D,GAAA;AA5DkB;AACA;AAGT;;;;;;AAiBC;AAKA;AAOA;AAIA;AACA;AACA,yCAAgB,oBAAI,IAA9B;AAOU;;;;;;AACA;AAEA;AAEA;AA8KD;;;;;;;;;;AAyBA;;;;;;;;;;;;;;;;;;;;AAEA,wBAAC;AAGD,wBAAC;AA0JA;AA4mBA;mDAA0B;AAsT1B,iCAAiB;AAEjB;AAsFA,4CAAmB,oBAAI,IAAjC;AA+FU,oCAOJ,UAAU,CAAC,iBAPjB;AAQI,YAAM,EAAE,OAAO,WAAW,KAA9B,IAAuC;AAEnC,UAAI,aAAa,WAAW,aAAa;AACvC,eAAO,EAAE,OAAO,WAAW,QAAQ,aAAa,OAAO,KAA7D;MACI;AAEA,UAAI,aAAa,SAAS,OAAO,CAAC,aAAa,cAAc,IAAI,GAAG;AAClE;MACF;AAEA,UAAI;AACJ,YAAM,WAAW,KAAK,QAAQ,SAAlC;AAEI,UAAI,aAAa,WAAW,SAAS;AACnC,iBAAS,aAAa;AACtB,YACE,OAAO,kBAAkB,cAAc,SACvC,OAAO,YACN,CAAC,KAAK,QAAQ,qBACb,SAAS,OAAO,kBAAkB,cAAc,UAClD,KAAK,QAAQ,gBAAgB,cAC7B;AACA;QACF;MACF,WAAW,aAAa,WAAW,WAAW;AAC5C,YAAI,KAAK,sBAAsB;AAC7B,eAAK,uBAAuB;AAC5B,eAAK,iBAAb;QACM;AACA,iBACE,aAAa,SAAS,MACnB;UACC,GAAI,aAAa,UAAU,YAAY,IACrC,SAAS,SACT,EAAE,MAAM,QAAW,WAAW,SAAS,SAAS,KAA9D;UACY,OAAO,aAAa;UACpB,eAAe,cAAc;UAC7B,SAAS;QACrB,IACU,aAAa;AAEjB,YAAI,aAAa,SAAS,OAAO,OAAO,cAAc,aAAa;AACjE,iBAAO,YAAY;QACrB;AAEA,YAAI,OAAO,OAAO;AAChB,eAAK,aAAb;QACM;MACF,WAAW,aAAa,WAAW,oBAAoB;AACrD,cAAM,aACJ,aAAa,UAAU,YAAY,IACjC,SAAS,SACT,KAAK,iBAAiB,KAAK,WAAW;AAC1C,cAAM,EAAE,WAAd,IAA6B,aAAa;AACpC,cAAM,QAAQ,aAAa,SAAY,WAAW;AAClD,cAAM,gBAAgB,QAAQ,cAAc,QAAQ,cAAc;AAClE,iBAAS;UACP,GAAG;UACH;UACA;QACR;MACI;AAGA,gBAAU,MAAO;AAGjB,UAAI,CAAC,OAAO;AAAO,eAAO,OAAO;AACjC,aAAO,gBAAgB,KAAK,uBAAuB,OAAO,aAAa;AACvE,aAAO,UAAU,yBAAyB,OAAO,aAAa;AAC9D,eAAS,KAAK,WAAW,MAAM;AAE/B,aAAO,EAAE,OAAO,WAAW,QAAQ,KAAvC;IACE,CAAC;AA7/CC,SAAK,eAAe;AAGpB,SAAK,uBAAuB,QAAQ,gBAAgB;AACpD,SAAK,aAAa;AAElB,SAAK,kBAAkB,KAAK,gBAAgB,KAAK,IAAI;AACrD,SAAK,aAAa,KAAK,WAAW,KAAK,IAAI;AAE3C,UAAM,EACJ,YAAY,EAAE,aAAa,qBAAqB,cADtD,IACwE,CADxE,EAAA,IAEQ,aAAa;AAEjB,UAAM;MACJ,cAAc;;MAEd,qBAAqB,gBAAgB,YAAY,qBAC/C;IADR,IAGQ;AAEJ,SAAK,YAAY;AAEjB,SAAK,UAAU;MACb,GAAG;;;;MAKH;;;MAIA;MACA,WAAW,KAAK,yBAAyB,QAAQ,SAAS;IAChE;AAEI,SAAK,2BAAT;AAEI,SAAK,cAAc,IAAI,MAAM;AAC7B,QAAI,OAAO,YAAY;AACrB,WAAK,OAAO,UAAU,IAAI,MAAM;IAClC;AAEA,UAAM,QAAQ,uBAAuB,KAAK,KAAK;AAC/C,SAAK,YAAY,SAAS,MAAM,QAAQ,MAAM,KAAK;EACrD;;;;;EA1GA,IAAW,QAAb;AACI,WAAO,KAAK;EACd;;;;EAKA,IAAW,YAAb;AACI,WAAO,KAAK,QAAQ;EACtB;EAqCA,IAAY,gBAAd;AACI,WAAO,KAAK,QAAQ,SAAxB,EAAmC,OAAO;EACxC;EA4DQ,6BAAV;AACI,SAAK,UAAU,IAAI,gBAEjB;MACA,OAAO,KAAK;MACZ,WAAW,KAAK;MAChB,QAAQ;MACR,MAAM,CAAZ;IACA,CAAK;AACD,UAAM,aAAa,KAAK,QAAQ,KAC9B,IAAI;MACF,WAAW,MAAnB;AACU,YAAI,CAAC,KAAK,QAAQ,UAAU;AAC1B,eAAK,UAAjB;AAOY,qBAAW,MAAM,KAAK,cAAlC,CAAiD;QACvC;MACF;MACA,aAAa,MAArB;AACU,YAAI,CAAC,KAAK,QAAQ,UAAU;AAC1B,eAAK,cAAjB;QACU;MACF;IACR,CAAO,GACD,UACE,CACE,EAAE,OAAO,WAAW,QAAQ,SAAS,KAH/C,GAIU,YAJV;AASU,YAAM,EAAE,WAAlB,IAAiC;AAEvB,UAAI,YAAY,eAAe;AAE7B,gBAAQ,WAAW;AACnB,gBAAQ,oBAAoB;MAC9B;AACA,UACE,KAAK,QAAQ,gBAAgB,aAC7B,eAAZ;AAEY;AACF,UAAI,eAAd;AAAiD,eAAO,KAAxD;AAEU,YAAM,EAAE,UAAU,kBAA5B,IAAkD;AAExC,UAAI,UAAU;AACZ,cAAM,eAAe,KAAK,aAAa,gBAAgB,KAAK;AAC5D,cAAM,cAAc,KAAK,aAAa;AACtC,cAAM,cACJ,cAAc,aAAa,mBAAmB;AAEhD,cAAM,gBACJ,eAAe,aAAa,0BAC1B,aAAa,aAAa,UAAU,SAAS,SAAS,IACtD,MAAM,UAAU,OAAO;AAE3B,YAAI,iBAAiB,MAAM,mBAAmB,SAAS,GAAG;AACxD;QACF;MACF;AAEA,UACE,eADZ,MAEa,CAAC,KAAK,QAAQ,+BACb,MAAM,UAAU,OAAO,IACzB;AACA;MACF;AACA,aAAO,KAAjB;AAEU,eAAS,OAAnB;AACY,gBAAQ,WAAW;AACnB,gBAAQ,oBAAoB;AAC5B,eAAO;MACT;IACF,GACA,OAAO,CADf,EACkB,CACX;AAGH,SAAK,OAAO,WAAW,KAAK,KAAK,UAAU;AAC3C,SAAK,YAAY,WAAW,UAAU,KAAK,UAAU;AAErD,SAAK,QAAQ,IAAI,QAArB;AAGI,SAAK,MAAM,WAAW,MAA1B;IAAiC;AAC7B,SAAK,MAAM,KAAK,KAAK,QAAQ,EAAE,UAAU,KAAK,OAAO;EACvD;;;;;;EAgDO,aAAa,EAAE,aAAa,KAArC,IAA8C,CAA9C,GAAA;AACI,WAAO,KAAK,aAAa,MAAM,KAAY;MACzC,OAAO,KAAK;MACZ,WAAW,KAAK;MAChB,mBAAmB;MACnB;IACN,CAAK;EACH;EAEQ,iBACN,oBADJ;AAGI,UAAM,cACJ,KAAK,aAAa,wBAChB,gBACA,sBAAsB,KAAK,QAAQ;AAEvC,UAAM,cAAc,MAAxB;AACM,YAAM,OAAO,KAAK,aAAxB;AAGM,YAAM,OACJ,KAAK,QAAQ,qBAAqB,KAAK,WACpC,KAAK,UAAoB,SAC1B;AAEJ,aAAO,KAAK,WAAW;QACrB;QACA,WACE,KAAK,WAAW,aACd,SAAS,SAAY,UACrB;QACJ,SAAS,CAAC,KAAK;QACf,eACE,KAAK,WAAW,cAAc,QAAQ,cAAc;QACtD,SAAS,CAAC,KAAK;MACvB,CAAwC;IACpC;AAEA,YAAQ,aAAa;MACnB,KAAK,cAAc;AACjB,eAAO;UACL,GAAG,YAAb;UACU,SAAS;UACT,eAAe,cAAc;QACvC;MACM;MACA,KAAK;AACH,eAAO,YAAf;MACM,KAAK;AACH,eAAO;UACL,GAAG,YAAb;UACU,SAAS;UACT,eAAe,cAAc;QACvC;MACM,KAAK;AACH,eAAOA;MAET;AACE,eAAO;IACX;EACF;EAEQ,mBAAV;AA5mBA,QAAAC;AA6mBI,UAAM,EAAE,WAAW,YAAvB,IAAuC,KAAK;AACxC,UAAM,QAAQ,KAAK;AAEnB,UAAM,oBACJ,gBAAgB,aAChB,gBAAgB,cAChB,KAAK;AAEP,UAAM,oBACJ,CAAC,aAAa,EAAE,OAAO,UAD7B,GAC0C,KAAK,oBAAoB,KAC7D,CAAC,KAAK;AAER,QAAI,qBAAqB,mBAAmB;AAC1C,OAAAA,MAAA,KAAK,yBAAL,gBAAAA,IAAA;IACF;AAEA,QAAI,qBAAqB,CAAC,mBAAmB;AAC3C;IACF;AAEA,UAAM,QAA8D;MAClE;MACA;MACA,YAAY;MACZ,SAAS;MACT,UAAU,CAAC,SAAjB;AACQ,cAAM,OAAO,KAAK,aAAa,gBAAgB,KAAK;AACpD,YAAI,KAAK,oBAAoB,KAAK,oBAAoB;AAUpD,gBAAM,WAAW;QACnB;AACA,YAAI,MAAM,gBAAgB,MAAM;AAE9B;QACF;AAEA,cAAM,EAAE,QAAQ,eAAxB,IAA2C,KAAK,QAAQ,SAAxD;AAEQ,YACE,CAAC,KAAK;;;;;;;;;SAUL,eAAe;;;QAId,mBAAmB,iBACnB,mBAAmBD,SACrB;AACA;QACF;AAEA,YAAI,CAAC,MAAM,eAAe,MAAM,KAAK,MAAM,GAAG;AAC5C,eAAK,eAAf;QACQ;MACF;IACN;AACI,UAAM,cAAc,KAAK,aAAa,MAAM,MAAM,KAAK;AAEvD,SAAK,uBAAuB,OAAO,OACjC,MADN;AAEQ,WAAK,uBAAuB;AAC5B,kBAAR;IACM,GACA,EAAE,OAAO,UADf,CAC0B;EAExB;EAGO,mBAAT;AACI,UAAM,EAAE,QAAQ,QAApB,IAAgC,KAAK,QAAQ,SAA7C;AACI,QAAI;;;MAIA,QAAQ,kBAAkB,cAAc;;MAGxC,KAAK,aAAb;;;MAIQ,KAAK,QAAQ,gBAAgB,aAE7B,UAGA,KAAK,iBAAb;;AAEI,QAAI,UAAU,eAAe;AAC3B,cAAQ,KAAK,iBAAnB;IACI;AACA,QAAI,CAAC,MAAM,KAAK,kBAAkB,KAAK,GAAG;AACxC,WAAK,mBAAmB;IAC1B;AACA,WAAO,KAAK;EACd;;;;;;;;;;;;;;;EAgBO,QACL,WADJ;AA5uBA,QAAAC;AA+uBI,UAAM,EAAE,YAAZ,IAA4B,KAAK;AAE7B,UAAM,mBAEF;;MAEF,cAAc;IACpB;AAKI,QAAI,gBAAgB,YAAY;AAC9B,uBAAiB,cAAc;IACjC,OAAO;AACL,uBAAiB,cAAc;IACjC;AAEA,QAAI,WAAW,aAAa,eAAe,KAAK,WAAW,WAAW,GAAG;AACvE,YAAM,WAAW,mBAAmB,KAAK,KAAK;AAC9C,YAAM,OAAO,SAAS;AACtB,UAAI,CAAC,QAAQ,CAAC,KAAK,KAAK,CAAC,MAAM,EAAE,SAAS,KAAK,UAAU,WAAW,GAAG;mBACrE,UAAU,KAAlB,IAGU,aACAA,MAAA,SAAS,SAAT,gBAAAA,IAAe,UAAS,QAFlC;MAIM;IACF;AAEA,QAAI,aAAa,CAAC,MAAM,KAAK,WAAW,SAAS,GAAG;AAElD,uBAAiB,YAAY,KAAK,QAAQ,YACxC,KAAK,yBAAyB,EAAE,GAAG,KAAK,WAAW,GAAG,UAA9D,CAAyE;IACrE;AAEA,SAAK,aAAa;AAClB,WAAO,KAAK,WAAW,kBAAkB;MACvC,kBAAkB,cAAc;IACtC,CAAK;EACH;EAgBO,UAGL,EACA,OACA,WACA,SACA,aACA,YARJ,GAAA;AAeI;MACE,KAAK,QAAQ,gBAAgB;;MAE7B,iBAAiB,KAAK,OAAO,aAAa;;AAE5C,UAAM,kBAAkB;MACtB,GAAG,QACD,KAAK,SACL,EAAE,aAAa,OAFvB,GAGQ;QACE;QACA;QACA;MACV,CAAS;MAEH,WAAY,QAAQ,YAClB;QACE,GAAG,KAAK;QACR,GAAG;MACb;;;;;;MAOM,aAAa;MACb,6BAA6B,KAAK,QAAQ;IAChD;AAEI,oBAAgB,QAAQ,KAAK,kBAAkB,gBAAgB,KAAK;AAOpE,SAAK,YACH,QACE,KAAK,kBAAkB,KAAK,QAAQ,KAAK,IACzC,gBAAgB;AAEpB,QAAI,aAAa;AAEjB,UAAM,WAAW,KAAK,QAAQ,gBAAgB;AAE9C,QAAI,CAAC,UAAU;AACb,gBACE,aADR,EAAA;IAII;AAEA,UAAM,EAAE,UAAAC,WAAU,iBAAtB,IAA2C,KAAK,cAC1C,cAAc,SAAS;AAEzB,qBACE;MACE,QAAQ;MACR,MAAM;MACN,OAAO,CAAf;IACA,GACM;MAAE,YADR;;IAAA,CACsD;AAElD,WAAO,KAAK,aACT,WAAW,iBAAiB,cAAc,SAAS,EACnD,KAAK,CAAC,oBAAb;AAKQ,MAAAA,UAAR;AAEQ,UAAI,UAAU;AAGZ,cAAM,WAAW,KAAK,aAAhC;AAMU,aAAK,aAAa,MAAM,MAAM;UAC5B,QAAQ,CAAC,UAArB;AACc,gBAAI,aAAa;AACf,oBAAM,YACJ;gBACE,OAAO,KAAK;gBACZ,WAAW,KAAK;gBAChB,mBAAmB;gBACnB,YAAY;cAChC,GACkB,CAAC,aACC,YAAY,UAAkB;gBAC5B,iBAAiB,gBAAgB;gBACjC,WAAW,gBAAgB;cACjD,CAAqB,CAAC;YAER,OAAO;AAML,oBAAM,WAAW;gBACf,OAAO,gBAAgB;gBACvB,WAAW,gBAAgB;gBAC3B,MAAM,gBAAgB;cACxC,CAAiB;YACH;UACF;UACA,gBAAgB,CAAC,OAAO,SAApC;AACc,gBACE,MAAM,YAAY,QAClB,CAAC,MAAM,KAAK,QAAQ,SAAS,MAAM,GACnC;AACA,2BAAa;YACf;UACF;QACZ,CAAW;MACH,OAAO;AAeL,cAAM,aAAa,KAAK,iBAAlC;AACU,cAAM,OAAO,YAAa,WAAW,MAAyB;UAC5D,iBAAiB,gBAAgB;UACjC,WAAW,gBAAgB;QACvC,CAAW;AAED,yBAAiB;UACf,MAAM;UACN,OAAO;YACL,GAAG;YACH,eAAe,cAAc;;YAE7B,SAAS;YACT;YACA,WACE,WAAW,cAAc,cAAc,cAAc;UACrE;UACY,QAAQ;QACpB,CAAW;MACH;AAEA,aAAO,KAAK,WAAW,eAAe;IACxC,CAAC,EACA,QAAQ,MAAf;AAEQ,MAAAA,UAAR;AAOQ,UAAI,YAAY,CAAC,YAAY;AAC3B,yBACE;UACE,MAAM;UACN,QAAQ;UACR,OAAO,CAArB;QACA,GACY;UAAE,YADd;;QAAA,CAC8C;MAEtC;IACF,CAAC;EACL;;;;;;;;;EAUO,gBAIL,SAJJ;AAWI,UAAM,eAAe,KAAK,aACvB,yBAAyB;MACxB,OAAO,QAAQ;MACf,WAAW,QAAQ;MACnB,SAAS,QAAQ;IACzB,CAAO,EACA,UAAU;MACT,MAAM,CAAC,qBAAf;AACU,cAAM,EAAE,aAAa,QAA/B,IAA2C;AACjC,cAAM,EAAE,MAAlB,IAA4B;AAElB,YAAI,OAAO;AACT,cAAI,SAAS;AACX,oBAAQ,KAAK;UACf,OAAO;AACL,sBAAU,MAAxB,IAAsE,KAAtE;UACY;AAEA;QACF;AAEA,YAAI,aAAa;AACf,eAAK,YAAY,CAAC,UAAU,kBAC1B,YAAY,UAAU;YACpB;YAGA,GAAG;UACnB,CAAe,CAAC;QAEN;MACF;IACR,CAAO;AAEH,SAAK,cAAc,IAAI,YAAY;AAEnC,WAAO,MAAX;AACM,UAAI,KAAK,cAAc,OAAO,YAAY,GAAG;AAC3C,qBAAa,YAArB;MACM;IACF;EACF;;;;;;EAGO,aACL,YADJ;AAGI,UAAM,gBAAgB,QAAQ,KAAK,SAAS,cAAc,CAA9D,CAAgE;AAC5D,WAAO,KAAK,SAAS,aAAa;AAClC,SAAK,cAAT;EACE;;;;;;;;;;;;;;;;;EAkBO,MAAM,aACX,WADJ;AAGI,gBAAY,KAAK,yBAAyB,SAAS;AAEnD,QAAI,MAAM,KAAK,WAAW,SAAS,GAAG;AAIpC,aAAO,cAAc,KAAK,iBAAhC,CAAkD;IAC9C;AAEA,SAAK,QAAQ,YAAY;AAGzB,QAAI,CAAC,KAAK,aAAd,GAA8B;AACxB,aAAO,cAAc,KAAK,iBAAhC,CAAkD;IAC9C;AAEA,WAAO,KAAK,WACV;;MAEE,aAAa,KAAK,QAAQ;MAC1B;IACR,GACM,EAAE,kBAAkB,cAAc,aADxC,CACsD;EAEpD;;;;;;EAOO,YAAY,OAArB;AACI,UAAM,EAAE,aAAZ,IAA6B;AACzB,UAAM,EAAE,QAAQ,SAApB,IAAiC,KAAK,aAAa,EAAE,YAAY,MAAjE,CAAwE;AAEpE,UAAM,YAAY,MAChB,QACA;MACE,WAAW,KAAK;MAChB,UAAU,CAAC,CAAC;MACZ,cAAc;IACtB,CAAgD;AAG5C,QAAI,WAAW;AACb,mBAAa,MAAM,WAAW;QAC5B,OAAO,KAAK,QAAQ;QACpB,MAAM;QACN,WAAW,KAAK;MACxB,CAAO;AAED,mBAAa,iBAAnB;IACI;EACF;;;;EAKO,aAAa,cAAtB;AACI,SAAK,QAAQ,eAAe;AAC5B,SAAK,cAAT;EACE;;;;EAKO,cAAT;AACI,SAAK,QAAQ,eAAe;AAC5B,SAAK,cAAT;EACE;;EAGQ,qBACN,QAKA,SAAJ;AAEI,QAAI,QAAQ,iBAAiB;AAC3B,YAAM,EAAE,cAAc,eAAe,qBAAqB,YAAhE,IACQ;AAEF,UAAI,gBAAgB,WAAW;MAE/B,WAAW,OAAO,QAAQ,oBAAoB,YAAY;AAWxD,gBAAQ,cAAc,QAAQ,gBAAgB,KAC5C,SACA,aACA,EAAE,QAAQ,SAAS,YAAY,MAAM,mBAH/C,CAGmE;MAE7D,WAAW,WAAW,qBAAqB;AACzC,gBAAQ,cAAc;MACxB,OAAO;AACL,gBAAQ,cAAc,QAAQ;MAChC;IACF;AAEA,WAAO,QAAQ;EACjB;EAEQ,MACN,SACA,eACA,YACA,UAJJ;AAQI,UAAM,qBAAqB,KAAK,QAAQ;AACxC,YAAQ,YAAR,QAAQ,UAAY,CAAxB;AAEI,QAAI,uBAAuB;AAC3B,UAAM,aAAa,MAAvB;AACM,6BAAuB;IACzB;AACA,UAAM;;;MAEJ,CAAI,WACF,IAAI,WAAc,CAAC,eAD3B;AAEU,YAAI;AACF,iBAAO,OAAO,UAAU;YACtB,KAAK,OAAnB;AACgB,qCAAuB;AACvB,yBAAW,KAAK,KAAK;YACvB;YACA,OAAO,CAAC,UAAU,WAAW,MAAM,KAAK;YACxC,UAAU,MAAM,WAAW,SAAzC;UACA,CAAa;QACH,UAAV;AACY,cAAI,CAAC,sBAAsB;AACzB,sBAAU,WAAW;AACrB,iBAAK,MAAM,KAAK;cACd,MAAM;cACN,QAAQ;cACR,OAAO;gBACL,YAAY;cAC9B;cACgB;cACA;cACA,MAAM;gBACJ,YAAlB;;;;;;;;gBAQkB,aAAa;cAC/B;YACA,CAAe;UACH;QACF;MACF,CAAC;;AAEL,QAAI,EAAE,YAAY,SAAtB,IAAmC,KAAK,aAAa,wBAC/C,SACA;MACE;MACA,OAAO;MACP;MACA;MACA,iBAAiB;IACzB,CAAO;AAIH,UAAM,EAAE,OAAO,UAAnB,IAAiC;AAC7B,UAAM,YAA8B;MAClC,OAAO,MAAb;AACQ,qBAAa,YAArB;MACM;MACA;MACA;IACN;AACI,SAAK,iBAAiB,IAAI,SAAS;AAEnC,QAAI,sBACF,iBAAiB,cAAc,WAC/B,iBAAiB,cAAc;AACjC,iBAAa,WAAW,KAAK,UAAU,MAA3C,CAAkD;AAC9C,UAAM,eAAe,WAClB,KACC,IAAI;MACF,MAAM,CAAC,iBAAjB;AACY,YACE,aAAa,WAAW,sBACvB,aAAa,SAAS,OAAO,aAAa,MAAM,SACjD;AACA,oBAAU,WAAW;QACvB,OAAO;AACL,iBAAO,UAAU;QACnB;MACF;MACA,UAAU,MAAM,KAAK,iBAAiB,OAAO,SAAS;IAChE,CAAS,CAAC,EAEH,UAAU;MACT,MAAM,CAAC,UAAf;AACU,cAAM,OAAa,CAA7B;AAEU,YACE,uBACA,MAAM,SAAS,OACf,aAAa,MAAM,SACnB,CAAC,MAAM,MAAM,SACb;AACA,gCAAsB;AACtB,eAAK,aAAjB;QACU;AAEA,aAAK,MAAM,KAAK,EAAE,GAAG,OAAO,OAAO,WAAW,KAAxD,CAA8D;MACtD;IACR,CAAO;AAEH,WAAO,EAAE,UAAU,cAAc,WAArC;EACE;EAIQ,gBAAV;AAEI,QAAI,KAAK,aAAa,SAAS;AAC7B;IACF;AAEA,UAAM,EACJ,aACA,SAAS,EAAE,aAAa,aAF9B,EAAA,IAGQ;AAEJ,QAAI,CAAC,gBAAgB,CAAC,KAAK,aAA/B,KAAiD,gBAAgB,cAAc;AACzE,UAAI,SAAS;AACX,YACE,CAAC,KAAK,2BACN,gBACA,gBAAgB,cAChB;qBACA,UAAU,KAApB,IAEY,iBAAiB,KAAK,OAAO,aAAa,CAAA;AAE5C,eAAK,0BAA0B;QACjC;MACF;AAEA,WAAK,cAAX;AACM;IACF;AAEA,SAAI,2CAAa,cAAa,cAAc;AAC1C;IACF;AAEA,UAAM,OAAO,gBAAgB,KAAK,cAAc,CAApD;AACI,SAAK,WAAW;AAEhB,UAAM,aAAa,MAAvB;AAl1CA,UAAAD,KAAA;AAm1CM,UAAI,KAAK,aAAa;AACpB,YACE,CAAC,yBAAyB,KAAK,aAAa,KAC5C,GAAC,MAAAA,MAAA,KAAK,SAAQ,oBAAb,wBAAAA,OACD;AACA,eAAK,WACH;;;;;YAKE,aACE,KAAK,QAAQ,uBAAuB,aAClC,aACA;UAClB,GACY;YACE,kBAAkB,cAAc;UAC9C,CAAa,EACD,KAAK,MAAM,IAAI;QACnB,OAAO;AACL,eAAV;QACQ;MACF;IACF;AAEA,UAAM,OAAO,MAAjB;AACM,YAAME,QAAO,KAAK;AAClB,UAAIA,OAAM;AACR,qBAAaA,MAAK,OAAO;AACzB,QAAAA,MAAK,UAAU,WAAW,YAAYA,MAAK,QAAQ;MACrD;IACF;AAEA,SAAJ;EACE;;EAGQ,gBAAV;AACI,QAAI,KAAK,aAAa;AACpB,mBAAa,KAAK,YAAY,OAAO;AACrC,aAAO,KAAK;IACd;EACF;;;;;;;;EASO,UACL,YADJ;AAKI,WAAO,KAAK,WAAW,UAAU;EACnC;EACQ,WACN,YACA,iBAFJ;AAQI,SAAK,aAAa;AAClB,QAAI,EAAE,iBAAV,IAA+B,mBAAmB,CAAlD;AAEI,SAAK,aAAa,WAAW,IAAI,IAAI;AAErC,UAAM;;;;MAIJ,qBAAqB,cAAc;;MAGnC,qBAAqB,cAAc;;AAGrC,UAAM,eAAe,KAAK;AAC1B,UAAM,iBAAiB,KAAK,QAAQ;AAEpC,UAAM,gBAAgB,QAAQ,KAAK,SAAS,cAAc,CAA9D,CAAgE;AAC5D,UAAM,UACJ;;;MAGE;QACA,OAAO,KAAK,SAAS,aAAa;AAMtC,UAAM,QAAQ,KAAK,kBAAkB,QAAQ,KAAK;AAElD,SAAK,YAAY;AASjB,QAAI,cAAc,eAAe,YAAY;AAC3C,cAAQ,YAAY,KAAK,yBAAyB,WAAW,SAAS;IACxE;AAEA,QAAI,CAAC,yBAAyB;AAE5B,WAAK,cAAX;AAIM,UACE,cACA,WAAW,aACX,CAAC,MAAM,WAAW,WAAW,YAAY;MAEzC,QAAQ,gBAAgB;;OAGvB,QAAQ,gBAAgB;;MAGvB,OAAO,QAAQ,oBAAoB,aACrC;AAEA,aAAK,qBAAqB,qBAAqB,OAAO;AACtD,YAAI,qBAAqB,QAAQ;AAC/B,6BAAmB,cAAc;QACnC;MACF;IACF;AAEA,UAAM,mBAAmB,KAAK;AAE9B,QAAI,CAAC,kBAAkB;AACrB,yBAAmB,cAAc;AAEjC,UACE,qBAAqB,cAAc,YACnC,yCAAY,cACZ,CAAC,MAAM,WAAW,WAAW,YAAY,GACzC;AACA,2BAAmB,cAAc;MACnC;AAIA,UAAI,QAAQ,gBAAgB,WAAW;AACrC,2BAAmB,cAAc;MACnC;IACF;AAEA,QAAI,QAAQ,gBAAgB,WAAW;AACrC,WAAK,cAAX;IACI;AAEA,SAAK,iBAAT;AACI,UAAM,EAAE,SAAS,UAAU,gBAA/B,IAAmD;MAC7C,CAAC,UADP;AAEQ,gBAAQ,MAAM,MAAM;UAClB,KAAK;AACH,kBAAM,MAAM;UACd,KAAK;AACH,gBAAI,MAAM,WAAW,sBAAsB,CAAC,MAAM,MAAM;AACtD,qBAAO,MAAM;QACnB;MACF;;;;;MAKA,QAAQ,gBAAgB,YACrB,EAAE,MAAM,OAAjB,IACQ;IAAS;AAEb,UAAM,EAAE,cAAc,YAAY,SAAtC,IAAmD,KAAK,MAClD,SACA,kBACA,OACA,eAAe;AAGjB,QAAI,CAAC,4BAA4B,YAAY,CAAC,KAAK,mBAAmB;AACpE,UAAI,KAAK,kBAAkB;AACzB,aAAK,iBAAiB,YAA9B;MACM;AAEA,WAAK,mBAAmB;IAC1B;AAEA,UAAM,MAAM,OAAO,OACjB,0BACE,QACG,KAAK,CAAC,WAAW,cAAc,KAAK,WAAW,MAAM,CAAC,CAAC,EACvD,QAAQ,MAAnB;AACY,UAAI,CAAC,KAAK,aAAtB,KAAwC,KAAK,iBAAiB,SAAS,GAAG;AAI5D,aAAK,cAAnB;MACY;IACF,CAAC,CAAC,GAEN;MACE,QAAQ,MAAhB;AACU,cAAMC,gBAAe,WAAW,UAAU,CAApD,CAAsD;AAC5C,cAAM,cAAc,MAAMA,cAAa,YAAjD;AACU,gBAAQ,KAAK,aAAa,WAAW;AACrC,eAAO;MACT;IACR,CAAO;AAEH,WAAO;EACT;EAEO,eAAT;AACI,WAAO,KAAK,QAAQ;EACtB;;;;EAKO,OAAT;AACI,SAAK,QAAQ,SAAjB;AACI,SAAK,2BAAT;AACI,SAAK,cAAT;EACE;EAEQ,gBAAV;AA9jDA,QAAAH;AA+jDI,QAAI,KAAK;AAAY;AAErB,SAAK,mBAAT;AACI,KAAAA,MAAA,KAAK,yBAAL,gBAAAA,IAAA;AACA,QAAI,KAAK,kBAAkB;AACzB,WAAK,iBAAiB,YAA5B;AACM,aAAO,KAAK;IACd;AAEA,SAAK,YAAT;AAEI,SAAK,cAAc,QAAQ,CAAC,QAAQ,IAAI,YAA5C,CAAyD;AACrD,SAAK,cAAc,MAAvB;AACI,SAAK,aAAa,WAAW,OAAO,IAAI;AACxC,SAAK,aAAa;AAClB,SAAK,sBAAT;AACI,SAAK,aAAa;EACpB;EAEQ,kBAAkB,UAA5B;AACI,WAAO,KAAK,aAAa,UAAU,QAAQ;EAC7C;EAEQ,WAAoC,QAA9C;AACI,UAAM,SAAS,KAAK,aAAa,cAAc;MAC7C,UAAU,KAAK;MACf,MAAM,OAAO;MACb,aAAa,KAAK,QAAQ;MAC1B,OAAO;IACb,CAAK;AAGD,WAAO,WAAW,OAAO,OAAO,SAAS,EAAE,GAAG,QAAQ,MAAM,OAAhE;EACE;;;;;;EAOQ,qBAAV;AACI,QAAI,KAAK,eAAe;AACtB,mBAAa,KAAK,aAAa;AAC/B,WAAK,gBAAgB;IACvB;AACA,SAAK,QAAQ;EACf;;;;;;EAGQ,iBAAV;AACI,QAAI,KAAK;AAAO;AAChB,SAAK,QAAQ;AACb,QAAI,CAAC,KAAK,eAAe;AACvB,WAAK,gBAAgB,WAAW,MAAM,KAAK,OAAO,IAAI,GAAG,CAAC;IAC5D;EACF;;;;;;EAGO,OAAO,YAAY,OAA5B;AACI,QAAI,CAAC,WAAW;AAKd,YAAM,OAAO,KAAK,aAAa,gBAAgB,KAAK,KAAK;AACzD,UAAI,KAAK,oBAAoB,KAAK,oBAAoB;AACpD;MACF;IACF;AAEA,UAAM,EAAE,MAAZ,IAAsB;AAClB,SAAK,mBAAT;AAEI,QACE,UACC,KAAK,QAAQ,eAAe,gBAC3B,KAAK,QAAQ,eAAe,uBAC5B,CAAC,KAAK,iBAAiB,OACzB;AACA,YAAM,OAAO,KAAK,aAAxB;AACM;;;QAGE,MAAM,KAAK,QAAQ,KAAK,aAAa,EAAE,YAAY,MAA3D,CAAkE,EAAE,MAAM;QAClE;AAUA,aAAK,oBAAb;MACM,OAAO;AAML,aAAK,MAAM,KAAK;UACd,MAAM;UACN,OAAO;YACL,MAAM,KAAK;YACX,WACE,KAAK,WAAW,aACd,KAAK,SAAS,YACd;YACJ,eAAe,cAAc;YAC7B,SAAS;YACT,OAAO;YACP,SAAS,CAAC,KAAK;UAC3B;UACU,QAAQ;UACR,OAAO,KAAK;UACZ,WAAW,KAAK;UAChB,MAAM,CAAhB;QACA,CAAS;MACH;IACF;EACF;EAGQ,cAAc,eAAxB;AAOI,QAAI,UAAU;AAEd,UAAM,EAAE,OAAO,UAAnB,IAAiC;AAC7B,UAAMC,YAAW,MAArB;AACM,WAAK,iBAAiB,OAAO,SAAS;IACxC;AACA,UAAM,YAA8B;MAClC,UAAU;MACV,OAAO,MAAb;AACQ,kBAAU;AACV,QAAAA,UAAR;MACM;MACA;MACA;IACN;AACI,SAAK,iBAAiB,IAAI,SAAS;AACnC,WAAO;MACL,UAAAA;MACA,kBAAkB,CAChB,cACA,mBAFR;AAIQ,YAAI,CAAC,SAAS;AACZ,eAAK,MAAM,KAAK;YACd,GAAG;YACH;YACA;YACA,MAAM,EAAE,GAAG,eAAvB;UACA,CAAW;QACH;MACF;IACN;EACE;EAEQ,uBAAuB,mBAAjC;AACI,QAAI,sBAAsB,cAAc,WAAW;AACjD,aAAO;IACT;AAMA,UAAM,YAAY,MAAM,KAAK,KAAK,iBAAiB,OAAvD,CAA+D,EAAE,SAC3D,CAACG,eACC,aAAaA,YAAW,IAAI,KAAKA,WAAU,aAAa,MAAS;AAErE,YAAO,uCAAW,aAAY;EAChC;EAEQ,wBAAV;AACI,SAAK,iBAAiB,QAAQ,CAAC,cAAc,UAAU,MAA3D,CAAkE;EAChE;;;;;;;;;;EASO,QAAT;AAGI,UAAM,eAAe,KAAK,QAAQ,gBAAgB;AAClD,SAAK,UAAU,eAAeL,SAAQ,eAAe;MACnD,YAAY,eAAlB,IAAA;IACA,CAAK;AAED,SAAK,sBAAT;EACE;;;;;;EAGQ,UACN,QACA,gBAFJ;AAII,SAAK,MAAM,KAAK;MACd,QAAQ;MACR,MAAM;MACN,OAAO;MACP,OAAO,KAAK;MACZ,WAAW,KAAK;MAChB,MAAM,EAAE,GAAG,eAAjB;IACA,CAAK;EACH;;;;;;;;EA4FQ,sBAAV;AACI,UAAM,EAAE,aAAa,gBAAzB,IAA6C,KAAK;AAE9C,QAAI,gBAAgB,uBAAuB,gBAAgB,gBAAgB;AACzE,WAAK,UAAU;QACb,aAAa;;;QAGb,gBAEE,oBACA,SAHV;AAOU,eAAK,kBAAkB;AAGvB,cAAI,OAAO,KAAK,oBAAoB,YAAY;AAC9C,mBAAO,KAAK,gBAAgB,oBAAoB,OAAO;UACzD;AAEA,iBAAO;QACT;MACR,CAAO;IACH,OAAO;AACL,WAAK,UAAX;IACI;EACF;EAEQ,yBAAyB,WAAnC;AACI,WAAO,KAAK,aAAa,aAAa,KAAK,OAAO,SAAS;EAC7D;AACF;AAEA,SAAgB,sBACd,SADF;AAGE,MAAI,WAAW,SAAS;eACtB,UAAU,MAAd,IAAuD,OAAvD;EACE;AACF;AAEA,SAAS,aACP,GACA,GAFF;AAIE,SAAO,CAAC,EAAE,KAAK,KAAK,EAAE,UAAU,EAAE,SAAS,MAAM,EAAE,WAAW,EAAE,SAAS;AAC3E;AAEA,SAAS,2BACP,aACA,cAFF;AAIE,MAAI,YAAY,cACd,SACA;AACF,QAAM,UAAU,IAAI,QAAqB,CAAC,KAAK,QAAjD;AACI,cAAU;AACV,aAAS;EACX,CAAC;AACD,QAAM,WAAoD,IAAI;IAC5D,KAAK,OAAT;AACM,UAAI;AACF,cAAM,WAAW,YAAY,KAAK;AAClC,YAAI,aAAa,QAAW;AAC1B,sBAAY;QACd;MACF,SAAS,OAAO;AACd,eAAO,KAAK;MACd;IACF;IACA,UAAU,MAAd;AACM,UAAI,WAAW;AACb,gBAAQ,SAAS;MACnB,OAAO;AACL,cAAM,UAAU;AAChB,cAAM,OAAO;AACb,eACE,OAAO,iBAAiB,cACtB,IAAI,aAAa,SAAS,IAAI,IAM9B,OAAO,OAAO,IAAI,MAAM,OAAO,GAAG,EAAE,KAAhD,CAAsD,CAAC;MAEjD;IACF;EACJ,CAAG;AACD,SAAO,EAAE,SAAS,SAApB;AACA;;;AC16DA,IAAM,SAAS,CAAf;AAcA,IAAM,0BAA0B,oBAAI,QAApC;AAaA,SAAS,2BACP,OACA,YAFF;AAIE,QAAM,WAAW,MAAM,UAAU;AACjC,MAAI,OAAO,aAAa,YAAY;AAElC,UAAM,UAAU,IAAI,WAAxB;AACM,8BAAwB;QACtB;;;;;SAKC,wBAAwB,IAAI,KAAK,IAAK,KAAK;MAAI;AAGlD,aAAO,SAAS,MAAM,MAAM,SAAS;IACvC;EACF;AACF;AAEA,IAAM,eAAe,oBAAI,QAAzB;AAOA,IAAa,YAAb,MAAA;EAwBE,YACE,cACA,iBAFJ;AAlBE;yCAAgB;AAER;AACA;AAQQ;AACC;AACT;AAkCD;;;;;;;;AAzBL,UAAM,QAAS,KAAK,QAAQ,aAAa;AACzC,UAAM,MAAM,aAAa,IAAI,YAAY,KAAK,KAAK;AACnD,iBAAa,IAAI,cAAc,EAAE;AACjC,SAAK,KAAK,KAAK;AACf,SAAK,kBAAkB;AACvB,SAAK,eAAe;AAOpB,QAAI,CAAC,wBAAwB,IAAI,KAAK,GAAG;AACvC,8BAAwB,IAAI,OAAO,CAAC;AACpC,iCAA2B,OAAO,OAAO;AACzC,iCAA2B,OAAO,QAAQ;AAC1C,iCAA2B,OAAO,OAAO;IAC3C;EACF;EAQA,IAAY,YAAd;AACI,YAAQ,KAAK,mBAAmB,MAAM;EACxC;EACA,IAAY,UAAU,OAAxB;AACI,KAAC,KAAK,mBAAmB,MAAM,aAAa;EAC9C;EAEO,iBAAT;AACI,SAAK,YAAY;EACnB;EAEQ,YACN,QACA,WAFJ;AAII,UAAM,EAAE,UAAZ,IAA0B;AACtB,WAAO,EACL;;;IAIA,UAAU,YAAY,wBAAwB,IAAI,KAAK,KAAK,KAC5D,MAAM,WAAW,UAAU,SAAS,KACpC,MAAM,OAAO,MAAM,UAAU,OAAO,IAAI;EAE5C;EAEA,IAAI,UAAN;AACI,WAAO,KAAK,cAAc,KAAK,YAAY,UAAU;EACvD;EAEQ,6BACN,WACA,UACA,OAHJ;AAOI,UAAM,EAAE,mBAAZ,IAAmC,KAAK;AAEpC,QAAI,mBAAmB,oBAAoB,QAAQ,GAAG;AACpD,WAAK,gBAAL,KAAK,cAAgB,mBAAmB,aAEtC;QACA;MACR,CAAO;AAKD,aAAO,KAAK,YAAY,OAAO,WAAW,QAAQ;IACpD;AACA,WAAO;EACT;EAEO,gBACL,UACA,EACE,UAAU,OACV,WACA,aACA,mBANN,GAAA;AA1MA,QAAAM;AAqNI,UAAM,cAAc;MAClB;MACA;MACA,mBAAmB;MACnB,YAAY;IAClB;AAII,KAAAA,MAAA,KAAK,oBAAL,gBAAAA,IAAuB;AAEvB,UAAM,YAAY,uBAAtB;AACI,UAAM,WACJ,YAAY,SAAY,KAAK,MAAM,KAAY,WAAW;AAE5D,QAAI,SAAS,KAAK,6BAChB,qCAAU,QACV,UACA,KAAK;AAEP,QAAI,WAAW;AACb,aAAO;IACT;AAEA,QAAI,kBAAkB,QAAQ,WAAW,GAAG;AAK1C,WAAK,MAAM,MAAM;QACf,gBAAgB,CAGd,OACA,SADV;AAGU,cAAI,MAAM,YAAY,KAAK,iBAAiB;AAE1C,kBAAM,cAAc;UACtB;QACF;QACA,QAAQ,CAAC,UAAjB;AACU,cAAI,KAAK,YAAY,QAAQ,SAAS,GAAG;AACvC,kBAAM,WAAW;cACf;cACA,MAAM,OAAO;cACb;cACA,WAAW,uBAAzB;YACA,CAAa;AAED,iBAAK,YAAY;cACf;cACA;cACA,SAAS,wBAAwB,IAAI,KAAK,KAAK;YAC7D;UACU,OAAO;AAiCL,gBAAI,YAAY,SAAS,UAAU;AAGjC,uBAAS,EAAE,GAAG,QAAQ,MAAM,SAAS,OAAnD;AACc;YACF;UAGF;AAEA,gBAAM,OAAO,MAAM,KAAY,WAAW;AAO1C,cAAI,KAAK,UAAU;AACjB,qBAAS,EAAE,GAAG,QAAQ,MAAM,KAAK,OAA7C;UACU;QACF;MACR,CAAO;IACH,OAAO;AACL,WAAK,YAAY;IACnB;AAEA,WAAO;EACT;EAEO,mBACL,UACA,UAkBA,QAAQ,KAAK,OApBjB;AA0BI,UAAM,cAAoC,CAA9C;AACI,UAAM,YAAY,SAAS,uBAA/B;AAEI,QAAI,SAAS,KAAK,6BAChB,YAAY,SACV,MAAM,KAAY;MAChB,IAAI;;;;MAIJ,OAAO,KAAK,aAAa,gBAAgB,SAAS,QAAQ,EAAE;MAC5D,WAAW,SAAS;MACpB,YAAY;MACZ,mBAAmB;IAC7B,CAAS,EAAE,QAEL,UACA,SAAS,QAAQ;AAGnB,QAAI,SAAS,gBAAgB,UAAU;AACrC,eAAS,EAAE,GAAG,QAAQ,QAAQ,CAApC,EAAA;IACI;AAEA,QAAI,sBAAsB,MAAM,KAAK,SAAS,gBAAgB,QAAQ;AACpE,aAAO,QAAQ,QAAQ,MAAM;IAC/B;AAEA,UAAM,yBAAyB,OAC5B;MACC,GAAG;MACH,WAAW,KAAK,UAAU,cAAc;IAChD;AAEI,QAAI,CAAC,aAAa,kBAAkB,QAAQ,SAAS,WAAW,GAAG;AACjE,kBAAY,KAAK;QACf,QAAQ,OAAO;QACf,QAAQ;QACR,OAAO,SAAS;QAChB,WAAW,SAAS;MAC5B,CAAO;AAED,YAAM,EAAE,cAAd,IAAgC;AAC1B,UAAI,eAAe;AACjB,aAAK,aACF,qBAAqB,KAAK,EAC1B,QAAQ,CAAC,oBAApB;AACY,gBAAM,YAAY,mBAAmB,gBAAgB;AACrD,cACE,CAAC,aACD,CAAC,OAAO,eAAe,KAAK,eAAe,SAAS,GACpD;AACA;UACF;AACA,gBAAM,UAAU,cAAc,SAAS;AACvC,gBAAM,EAAE,OAAO,UAAU,UAArC,IAAmD;AAGvC,gBAAM,EAAE,QAAQ,oBAAoB,SAAhD,IACc,gBAAgB,aAAa,EAAE,YAAY,MADzD,CACgE;AAEpD,cAAI,YAAY,oBAAoB;AAElC,kBAAM,kBAAmB,QACvB,oBACA;cACE,gBAAgB,uBAAlC;cACkB,WAAY,YAAY,iBAAiB,QAAQ,KAAM;cACvD,gBAAgB;YAClC,CAAiB;AAIH,gBAAI,iBAAiB;AACnB,0BAAY,KAAK;gBACf,QAAQ;gBACR,QAAQ;gBACR,OAAO;gBACP;cAClB,CAAiB;YACH;UACF;QACF,CAAC;MACL;IACF;AAEA,QAAI,iBAAiB,SAAS;AAC9B,QAAI,OAAO,mBAAmB,YAAY;AACxC,uBAAiB,eAAe,uBAAtC,CAA8D;IAC1D;AAEA,QACE,YAAY,SAAS,MACpB,kBAAkB,IAAI,SAAS,KAChC,SAAS,UACT,SAAS,kBACT,SAAS,kBACT;AACA,YAAM,UAAiB,CAA7B;AAEM,WAAK,aACF,eAAe;QACd,aAAa,CAACC,WAAxB;AACY,cAAI,CAAC,WAAW;AACd,wBAAY,QAAQ,CAAC,UAAUA,OAAM,MAAM,KAAK,CAAC;UACnD;AAKA,gBAAM,EAAE,OAApB,IAA+B;AAInB,cAAI,QAAQ;AACV,gBAAI,CAAC,WAAW;AAKd,oBAAM,OAAOA,OAAM,KAAY;gBAC7B,IAAI;;;;gBAIJ,OAAO,KAAK,aAAa,gBAAgB,SAAS,QAAQ,EACvD;gBACH,WAAW,SAAS;gBACpB,YAAY;gBACZ,mBAAmB;cACrC,CAAiB;AAED,kBAAI,KAAK,UAAU;AACjB,yBAAS;kBACP,GAAG;kBACH,MAAM,KAAK;gBAC/B;cACgB;YACF;AAGA,gBAAI,CAAC,KAAK,SAAS;AACjB,qBACEA,QACA,QACA;gBACE,SAAS,SAAS;gBAClB,WAAW,SAAS;cACxC,CAAmB;YAEL;UACF;AAIA,cAAI,CAAC,aAAa,CAAC,SAAS,kBAAkB,CAAC,KAAK,SAAS;AAC3D,YAAAA,OAAM,OAAO;cACX,IAAI;cACJ,OAAO,OAAO,EAAE,WAAW,QAAAC,QAA3C,GAAA;AACkB,uBAAO,cAAc,eAAe,QAAQA;cAC9C;YAChB,CAAe;UACH;QACF;QAEA,SAAS;;QAGT,YAAY;;;QAIZ,kBAAkB,SAAS;;;;;QAM3B,gBAAgB,SAAS,kBAAkB;MACrD,CAAS,EACA,QAAQ,CAACC,YAAW,QAAQ,KAAKA,OAAM,CAAC;AAE3C,UAAI,SAAS,uBAAuB,SAAS,gBAAgB;AAI3D,eAAO,QAAQ,IAAI,OAAO,EAAE,KAAK,MAAM,MAAM;MAC/C;IACF;AAEA,WAAO,QAAQ,QAAQ,MAAM;EAC/B;EAEO,uBACL,oBACA,UAFJ;AAaI,UAAM,OACJ,OAAO,uBAAuB,aAC5B,mBAAmB,SAAS,WAAW,EAAE,OAAjD,CAAyD,IACjD;AAEJ,QAAI,SAAS,QAAQ;AACnB,aAAO;IACT;AAEA,SAAK,MAAM,4BAA4B,CAAC,UAA5C;AACM,UAAI;AACF,aAAK,mBAAmB,EAAE,KAAlC,GAA0C,UAAU,KAAe;MAC7D,SAAS,OAAO;AACd,kBAAU,MAAM,KAAK;MACvB;IACF,GAAG,KAAK,EAAE;AAEV,WAAO;EACT;EAEO,uBACL,QACA,EACE,UACA,WACA,aACA,mBANN,GAAA;AAaI,QAAI,uBAAR,GAA0D;AACpD,UAAI,kBAAkB,QAAQ,WAAW,GAAG;AAC1C,aAAK,MAAM,MAAM;UACf,OAAO;UACP,QAAQ,OAAO;UACf,QAAQ;UACR;QACV,CAAS;MACH;AAEA,WAAK,aAAa,iBAAxB;IACI;EACF;AACF;AAEA,SAAS,kBACP,QACA,cAA2B,QAF7B;AAIE,QAAM,eAAe,gBAAgB,YAAY,gBAAgB;AACjE,MAAI,kBAAkB,CAAC,sBAAsB,MAAM;AACnD,MAAI,CAAC,mBAAmB,gBAAgB,OAAO,MAAM;AACnD,sBAAkB;EACpB;AACA,SAAO;AACT;;;ACzdA,IAAa,eAAb,MAAA;EA8CE,YAAY,SAAd;AA7CS;AAES;AAIA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACT;AAEC;AAYD;;;;;;;;;;iDAAiC;AAEhC;AACD;AAOA;;;sCAAa,oBAAI,IAA1B;AAMY;;;;0CAAiB,oBAAI,IAAjC;AAuRU,0CAAiB,IAAI;MAI3B,WAAW,8BAA8B,KAC7C;;IAAuD;AA+H7C,4CAAmB;AAgQjB;;mDAA0B,IAAI,KAGrC,KAAK;AAslBA,kDAAyB,oBAAI,QAAvC;AAjvCI,UAAM,2BAA2B,IAAI;MACnC,CAAC,aAAa,KAAK,MAAM,kBAAkB,QAAQ;;MAEnD,EAAE,OAAO,MAAf;IAAsB;AAGlB,SAAK,SAAS,QAAQ;AACtB,SAAK,iBAAiB,QAAQ;AAC9B,SAAK,qBAAqB,QAAQ;AAClC,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,UAAU,QAAQ;AACvB,SAAK,yBAAyB,QAAQ;AACtC,SAAK,cAAc,QAAQ;AAC3B,SAAK,aAAa,QAAQ;AAC1B,SAAK,qBAAqB,QAAQ;AAClC,UAAM,oBAAoB,QAAQ;AAClC,SAAK,oBACH,oBACE,yBACG,OAAO,iBAAiB,EAKxB,OAAO,wBAAwB,IAClC;AACJ,SAAK,iBAAiB,QAAQ,kBAAkB,CAApD;AAEI,QAAK,KAAK,cAAc,QAAQ,aAAc;AAC5C,WAAK,gBAAgB,CAA3B;IACI;EACF;EAEA,IAAI,OAAN;AACI,WAAO,KAAK,OAAO;EACrB;EAEA,IAAI,QAAN;AACI,WAAO,KAAK,OAAO;EACrB;;;;;EAMO,OAAT;AACI,SAAK,WAAW,QAAQ,CAAC,OAAO,GAAG,KAAvC,CAA6C;AAEzC,SAAK,qBACH,kBADN,EAAA,CACyE;EAEvE;EAEQ,qBAAqB,OAA/B;AACI,SAAK,eAAe,QAAQ,CAAC,WAAW,OAAO,KAAK,CAAC;AACrD,SAAK,eAAe,MAAxB;EACE;EAEO,MAAM,OAIX,EACA,UACA,WACA,oBACA,eACA,iBAAiB,CATrB,GAUI,sBAAsB,OACtB,QAAQ,mBACR,gBACA,aACA,aACA,gBACA,QAhBJ,GAAA;AAqBI,UAAM,YAAY,IAAI,UAAqC,IAAI;AAE/D,eAAW,KAAK,MAAM,iBAAiB,KAAK,UAAU,QAAQ,CAAC;AAC/D,UAAM,EAAE,iBAAZ,IAAiC,KAAK,gBAAgB,QAAQ;AAE1D,gBAAY,KAAK,aAAa,UAAU,SAAS;AAEjD,QAAI,kBAAkB;AACpB,UAAI,SAAS;AACX,kBACE,KAAK,YADf,IAGU,iBAAiB,UAAU,aAAa,CAAA;MAE5C;AAEA,kBAAY,MAAM,KAAK,WAAY,qBAAiC;QAClE,QAAQ,KAAK;QACb,UAAU;QACV;QACA;MACR,CAAO;IACH;AAEA,UAAM,qBACJ,KAAK,kBACJ,KAAK,cAAc,UAAU,EAAE,IAAI;MAClC;MACA;MACA,SAAS;MACT,OAAO;IACf;AAEI,UAAM,eACJ,sBACA,UAAU,uBAAuB,oBAAoB;MACnD,UAAU;MACV;MACA,oBACE,gBAAgB,iBAE1B;MACQ;MACA;MACA;MACA,QAAQ;MACR;IACR,CAAO;AAEH,SAAK,iBAAT;AAEI,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAjC;AACM,YAAM,QAAQ,CAApB;AACM,aAAO,KAAK,sBACV,UACA;QACE,GAAG;QACH,oBAAoB,eAAe,qBAAqB;MAClE,GACQ,WACA,CAFR,GAGQ,KAAK,EAEJ,WAAW,KACV,qBADV,GAEU,SAAS,CAAC,WAFpB;AAGY,cAAM,cAA6B,EAAE,GAAG,OAApD;AAEY,eAAO,KACL,UAAU,mBAAmB,aAAa;UACxC,UAAU;UACV;UACA,oBACE,gBAAgB,iBAElC;UACgB;UACA;UACA,QAAQ;UACR;UACA;UACA;UACA,kBAAkB,eAAe,UAAU,KAAK;UAChD;UACA;QAChB,CAAe,CAAC;MAEN,CAAC,CAAC,EAEH,KACC,IAAI,CAAC,gBADf;AAEY,cAAM,YAAY,sBAAsB,WAAW;AACnD,YAAI,aAAa,gBAAgB,QAAQ;AACvC,gBAAM,IAAI,sBAAsB,WAAW;QAC7C;AAEA,YAAI,oBAAoB;AACtB,6BAAmB,UAAU;AAC7B,6BAAmB,QAAQ;QAC7B;AAEA,eAAO;MACT,CAAC,CAAC,EAEH,UAAU;QACT,MAAM,CAAC,gBAAjB;AACY,eAAK,iBAAjB;AAOY,cAAI,CAAC,UAAU,SAAS;AACtB,kBAAM,SAA2C;cAC/C,MAAM,KAAK,cAAc;gBACvB,UAAU;gBACV,MAAM,YAAY;gBAClB;gBACA;cAClB,CAAiB;YACjB;AAEc,gBAAI,sBAAsB,WAAW,GAAG;AACtC,qBAAO,QAAQ,IAAI,sBAAsB,WAAW;YACtD;AAEA,gBAAI,OAAO,KAAK,YAAY,cAAc,CAAxD,CAA0D,EAAE,QAAQ;AACpD,qBAAO,aAAa,YAAY;YAClC;AAEA,oBAAQ,MAAM;UAChB;QACF;QAEA,OAAO,CAAC,UAAlB;AACY,cAAI,oBAAoB;AACtB,+BAAmB,UAAU;AAC7B,+BAAmB,QAAQ;UAC7B;AAEA,cAAI,cAAc;AAChB,iBAAK,MAAM,iBAAiB,UAAU,EAAE;UAC1C;AAEA,eAAK,iBAAjB;AAEY,cAAI,gBAAgB,UAAU;AAC5B,mBAAO,QAAQ,EAAE,MAAM,OAArC,CAAgD;UACpC;AAEA,cAAI,gBAAgB,OAAO;AACzB,mBAAO,QAAQ,EAAE,MAAM,QAAW,MAAhD,CAAuD;UAC3C;AAEA,iBAAO,KAAK;QACd;MACV,CAAS;IACL,CAAC;EACH;EAEO,WACL,SACA,eAFJ;AAII,kBAAc,QAAQ,OAAO,kBAAkB,KAAK;AAIpD,YAAQ,YACN,cACE,KAAK,wBAAwB,SAAS;MACpC;IACV,CAAS,EAAE,WAAW,KACZ,UAAU,CAAC,UADrB;AAEY,cAAQ,MAAM,MAAM;QAClB,KAAK;AACH,gBAAM,MAAM;QACd,KAAK,KAAK;AACR,cAAI,MAAM,WAAW;AACnB,mBAAO,cAAc,MAAM,KAAK;QACpC;MACF;IACF,CAAC,CAAC,GAEJ;;;MAGE,cAAc,EAAE,MAAM,OAAhC;IACA,CAAS,GAAT;EAEE;EAEO,UAAU,UAAnB;AACI,WAAO,KAAK,kBAAkB,kBAAkB,QAAQ;EAC1D;EAUO,gBAAgB,UAAzB;AACI,UAAM,EAAE,eAAZ,IAA+B;AAE3B,QAAI,CAAC,eAAe,IAAI,QAAQ,GAAG;AACjC,YAAM,sBAAsB,uBAAuB,QAAQ;AAE3D,YAAM,aAAkC;;;;;;QAMtC,kBAAkB,cAAc,CAAC,UAAU,QAAQ,GAAG,UAAU,IAAI;QACpE,oBAAoB,mBAAmB,QAAQ;QAC/C,yBAAyB,cAAc,CAAC,aAAa,GAAG,QAAQ;QAChE,yBAAyB,cAAc,CAAC,OAAO,GAAG,QAAQ;QAC1D,kBAAkB,+BAA+B,QAAQ;QACzD,aAAa,cAAc,CAAC,QAAQ,GAAG,QAAQ,IAAI,WAAW;QAC9D,aAAa,6BACX;UACE,EAAE,MAAM,UAAU,QAAQ,KAAtC;UACY,EAAE,MAAM,aAApB;UACY,EAAE,MAAM,cAApB;UACY,EAAE,MAAM,SAApB;QACA,GACU,QAAQ;QAEV,eAAe,2DAAqB;QACpC,aAAa,iBACX,mBAAmB;;;QAIrB,SAAS;UACP,GAAG;UACH,aAAa,SAAS,YAAY,IAAI,CAAC,QAAjD;AACY,gBACE,IAAI,SAAS,yBACb,IAAI,cAAc,SAClB;AACA,qBAAO,EAAE,GAAG,KAAK,WAAW,QAA1C;YACY;AACA,mBAAO;UACT,CAAC;QACX;MACA;AAEM,qBAAe,IAAI,UAAU,UAAU;IACzC;AAEA,UAAM,QAAQ,eAAe,IAAI,QAAQ;AACzC,QAAI,MAAM,WAAW;AACnB,YAAM,MAAM;IACd;AACA,WAAO;EACT;EAEO,aACL,UACA,WAFJ;AAII,UAAM,cAAc,KAAK,gBAAgB,QAAQ,EAAE;AACnD,UAAM,mBAAmB,OAAO,QAAQ,aAAa,CAAzD,CAA2D,EAAE,IACvD,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,KAAK,UAAU,SAAY,YAAY,GAAG,IAAI,KAAK,CAAC;AAGzE,WAAO;MACL,GAAG;MACH,GAAG,OAAO,YAAY,gBAAgB;IAC5C;EACE;EAEO,WAIL,SAJJ;AAMI,kBAAc,QAAQ,OAAO,kBAAkB,KAAK;AAEpD,UAAM,QAAQ,KAAK,UAAU,QAAQ,KAAK;AAK1C,cAAU;MACR,GAAG;MACH,WAAW,KAAK,aAAa,OAAO,QAAQ,SAAS;IAC3D;AAEI,QAAI,OAAO,QAAQ,gCAAgC,aAAa;AAC9D,cAAQ,8BAA8B;IACxC;AAEA,UAAM,aAAa,IAAI,gBAAmC;MACxD,cAAc;MACd;MACA,kBAAkB;IACxB,CAAK;AAED,WAAO;EACT;EAEO,MAIL,SAJJ;AAMI,UAAM,QAAQ,KAAK,UAAU,QAAQ,KAAK;AAE1C,WAAO,KAAK,WAA8B;MACxC,GAAI;MACJ;IACN,CAAK,EAAE,KAAK,CAAC,WAAW;MAClB,GAAG;MACH,MAAM,KAAK,cAAc;QACvB,UAAU;QACV,MAAM,+BAAO;QACb,aAAa,QAAQ;MAC7B,CAAO;IACP,EAAM;EACJ;EAGO,oBAAT;AACI,WAAO,KAAK;EACd;EAEO,WACL,UAA8B;IAC5B,gBAAgB;EACtB,GAAA;AAOI,SAAK,qBACH,kBADN,EAAA,CAGO;AAGH,SAAK,WAAW,QAAQ,CAAC,oBAA7B;AAGM,sBAAgB,MAAtB;IACI,CAAC;AAED,QAAI,KAAK,eAAe;AACtB,WAAK,gBAAgB,CAA3B;IACI;AAGA,WAAO,KAAK,MAAM,MAAM,OAAO;EACjC;EAEO,qBACL,UAAyC,UAD7C;AAGI,UAAM,UAAU,oBAAI,IAAxB;AACI,UAAM,aAAa,oBAAI,IAA3B;AACI,UAAM,4BAA4B,oBAAI,IAA1C;AACI,UAAM,qBAAqB,oBAAI,IAAnC;AAEI,QAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,cAAQ,QAAQ,CAAC,SAAvB;AACQ,YAAI,OAAO,SAAS,UAAU;AAC5B,qBAAW,IAAI,MAAM,IAAI;AACzB,oCAA0B,IAAI,MAAM,KAAK;QAC3C,WAAW,eAAe,IAAI,GAAG;AAC/B,gBAAM,cAAcC,OAAM,KAAK,UAAU,IAAI,CAAC;AAC9C,qBAAW,IAAI,aAAa,iBAAiB,IAAI,CAAC;AAClD,oCAA0B,IAAI,aAAa,KAAK;QAClD,WAAW,gBAAgB,IAAI,KAAK,KAAK,OAAO;AAC9C,6BAAmB,IAAI,IAAI;QAC7B;MACF,CAAC;IACH;AAEA,SAAK,WAAW,QAAQ,CAAC,OAA7B;AACM,YAAM,WAAWA,OAAM,KAAK,UAAU,GAAG,QAAQ,KAAK,CAAC;AACvD,UAAI,YAAY,OAAO;AACrB,gBAAQ,IAAI,EAAE;AACd;MACF;AAEA,YAAM,EACJ,WACA,SAAS,EAAE,YAFnB,EAAA,IAGU;AAEJ,UAAI,YAAY,YAAY,gBAAgB,WAAW;AACrD;MACF;AAEA,UACE,YAAY,YACX,aAAa,0BAA0B,IAAI,SAAS,KACpD,YAAY,0BAA0B,IAAI,QAAQ,GACnD;AACA,gBAAQ,IAAI,EAAE;AACd,YAAI;AAAW,oCAA0B,IAAI,WAAW,IAAI;AAC5D,YAAI;AAAU,oCAA0B,IAAI,UAAU,IAAI;MAC5D;IACF,CAAC;AAED,QAAI,mBAAmB,MAAM;AAC3B,yBAAmB,QAAQ,CAAC,YAAlC;AACQ,cAAM,KAAK,IAAI,gBAAgB;UAC7B,cAAc;UACd,SAAS;YACP,GAAG;YACH,aAAa;UACzB;QACA,CAAS;AACD,gBAAQ,IAAI,EAAE;MAChB,CAAC;IACH;AAEA,QAAI,WAAW,0BAA0B,MAAM;AAC7C,gCAA0B,QAAQ,CAAC,UAAU,sBAAnD;AACQ,YAAI,CAAC,UAAU;AACb,gBAAM,YAAY,WAAW,IAAI,iBAAiB;AAElD,cAAI,WAAW;uBACb,UAAU,KAAtB,IAEc,SAFd;UAIU,OAAO;uBACL,UAAU,KAAtB,EAAA;UAGU;QACF;MACF,CAAC;IACH;AAEA,WAAO;EACT;EAEO,yBACL,iBAA0B,OAD9B;AAGI,UAAM,0BACJ,CADN;AAGI,SAAK,qBAAqB,iBAAiB,QAAQ,QAAQ,EAAE,QAC3D,CAAC,oBADP;AAEQ,YAAM,EAAE,YAAhB,IAAgC,gBAAgB;AACxC,WACG,kBAAkB,gBAAgB,cACnC,gBAAgB,cAChB;AACA,gCAAwB,KAAK,gBAAgB,QAAvD,CAAgE;MACxD;IACF,CAAC;AAGH,SAAK,iBAAT;AAEI,WAAO,QAAQ,IAAI,uBAAuB;EAC5C;EAEO,yBACL,SADJ;AAGI,QAAI,EAAE,OAAO,UAAjB,IAA+B;AAC3B,UAAM,EACJ,aACA,cAAc,QACd,UAAU,CAHhB,GAIM,aAAa,CAJnB,EAAA,IAKQ;AAEJ,kBAAc,OAAO,kBAAkB,YAAY;AAEnD,YAAQ,KAAK,UAAU,KAAK;AAC5B,gBAAY,KAAK,aAAa,OAAO,SAAS;AAE9C,QAAI;AAEJ,QAAI,SAAS;AACX;QACE,CAAC,KAAK,gBAAgB,KAAK,EAAE,oBAAoB,KAAK;;QAEtD,iBAAiB,OAAO,aAAa;;IAEzC;AAEA,UAAM,cACJ,KAAK,gBAAgB,KAAK,EAAE,mBAC1B,KACE,KAAK,WAAY,qBAAqB;MACpC,QAAQ,KAAK;MACb,UAAU;MACV;MACA;IACZ,CAAW,CAAC,IAEJ,GAAG,SAAS,GAAG,KACjB,SAAS,CAACC,eADhB;AAEQ,YAAM,EAAE,YAAAC,aAAY,SAAS,IAArC,IAA6C,KAAK,sBACxC,OACA,SACAD,YACA,UAAU;AAGZ,YAAM,YAAY,IAAI,UAAiB,IAAI;AAE3C,gBAAU;AACV,aAAQC,YAA2D,KACjE,IAAI,CAAC,cADf;AAEY,kBAAU,uBAAuB,WAAW;UAC1C,UAAU;UACV,WAAAD;UACA;UACA,oBACE,gBAAgB,iBAEhC;QACA,CAAa;AAED,cAAM,SAA8C;UAClD,MAAM,UAAU,QAAQ;QACtC;AAEY,YAAI,sBAAsB,SAAS,GAAG;AACpC,iBAAO,QAAQ,IAAI,sBAAsB,SAAS;QACpD,WAAW,+BAA+B,SAAS,GAAG;AACpD,iBAAO,QAAQ,UAAU,WAAW,sBAAsB;AAE1D,iBAAO,UAAU,WAAW,sBAAsB;QACpD;AAEA,YACE,UAAU,cACV,OAAO,KAAK,UAAU,UAAU,EAAE,QAClC;AACA,iBAAO,aAAa,UAAU;QAChC;AAEA,YAAI,OAAO,SAAS,gBAAgB,QAAQ;AAC1C,iBAAO,OAAO;QAChB;AAEA,YAAI,gBAAgB,UAAU;AAC5B,iBAAO,OAAO;QAChB;AAEA,eAAO;MACT,CAAC,GACD,WAAW,CAAC,UADtB;AAEY,YAAI,gBAAgB,UAAU;AAC5B,iBAAO,GAAG;YACR,MAAM;UACtB,CAAsD;QAC1C;AAEA,eAAO,GAAG,EAAE,MAAM,QAAW,MAAzC,CAAgD;MACtC,CAAC,GACD,OAAO,CAAC,WAAW,CAAC,EAAE,OAAO,QAAQ,OAAO,MAAM,CAAC;IAEvD,CAAC,CAAC;AAGJ,WAAO,OAAO,OAAO,YAAY,EAAE,SAAS,MAAM,qCAAtD,CAAmE;EACjE;EAEO,mBAAT;AACI,QAAI,KAAK;AAAa,WAAK,YAA/B;AACI,SAAK,WAAW,QAAQ,CAAC,oBAAoB,gBAAgB,OAAjE,CAAyE;EACvE;EASQ,sBACN,OACA,SACA,WACA,YAEA,iBAAyB,mCAAS,uBAChC,KAAK,oBAAX;AAKI,QAAI,QAOA,CAPR;AASI,UAAM,EAAE,aAAa,aAAa,eAAe,wBAArD,IACM,KAAK,gBAAgB,KAAK;AAE5B,UAAM,gBAAgB,iBAAiB,KAAK;AAC5C,UAAM,iBAA4C;MAChD,QAAQ,KAAK;IACnB;AAEI,QAAI,aAAa;AACf,YAAM,EAAE,yBAAyB,KAAvC,IAAgD;AAE1C,UAAI;AAcF,YAAS,cAAT,SAAqB,QAA7B;AACU,iBAAO,IAAI,WAA8B,CAAC,aAApD;AACY,qBAAS,YAArB;AACc,qBAAO,OAAO,UAAU;gBACtB,MAAM,SAAS,KAAK,KAAK,QAAQ;gBACjC,UAAU,SAAS,SAAS,KAAK,QAAQ;gBACzC,OAAO,SAAS,MAAM,KAAK,QAAQ;cACnD,CAAe;YACH;AACA,gBAAI,eAAe,UAA/B;AAEY,kBAAM,YAAN,MAAM,UAAY,MAA9B;AACc,2BAAa,YAA3B;AACc,6BAAe,UAA7B;YACY;AAEA,mBAAO,MAAnB;AACc,2BAAa,YAA3B;AACc,oBAAM,UAAU;YAClB;UACF,CAAC;QACH;AAlCA,cAAM,YAAY,KAAK,mBAAmB,eAAe;UACvD,OAAO;UACP;UACA,SAAS;YACP,GAAG,KAAK;YACR,GAAG;YACH,oBAAoB;UAChC;UACU;QACV,CAAS;AAED,kBAAU,UAAU;AAyBpB,YAAI,eAAe;AACjB,gBAAM,qBAAqBD,OAAM,WAAW;AAC5C,gBAAM,UAAU,mBAAmB,SAAS;AAE5C,kBAAQ,wBAAwB,OAAO,oBAAoB,OAAO;AAElE,cAAI,CAAC,MAAM,YAAY;AACrB,kBAAM,aAAa,QAAQ,MAAM,WAAW,cAAc,EAAE;cAC1D;cACA,SAAS,MAFvB;AAGgB,oBACE,wBAAwB,KAAK,oBAAoB,OAAO,MACxD,OACA;AACA,0CAAwB,OAAO,oBAAoB,OAAO;gBAC5D;cACF,CAAC;;;;cAID,kBAAkB,kBAAkB,eAClC,MAAhB,IACgB,YAAY,EAAE,UAAU,KAAxC,CAA8C;YAAC;UAErC;QACF,OAAO;AACL,gBAAM,aAAa,QAAQ,MAAM,WAAW,cAAc,EAAE,KAC1D,WAAW;QAEf;MACF,SAAS,OAAO;AACd,cAAM,aAAa,WAAW,MAAM,KAAK;MAC3C;IACF,OAAO;AACL,YAAM,aAAa,GAAG,EAAE,MAAM,CAApC,EAAA,CAAoE;IAChE;AAEA,QAAI,aAAa;AACf,YAAM,EAAE,UAAd,IAA4B,uBAAuB,KAAK;AAClD,UAAI,SAAS;AACX;UACE,KAAK;;UAEL,UAAU,CAAC,EAAE,YAHvB,IAGuC,UAAU,MAAM,CAAC;UAC9C,iBAAiB;;MAErB;AAEA;QACE,CAAC;;QAED,UAAU,CAAC,EAAE,YAHrB,IAGqC,UAAU,MAAM,CAAC;QAC9C,iBAAiB;;AAGnB,YAAM,aAAa,MAAM,WAAW,KAClC,SAAS,CAAC,WADlB;AAEU,eAAO,KACL,KAAK,WAAY,QAAe;UAC9B,QAAQ,KAAK;UACb,UAAU;UACV,cAAc;UACd;UACA;QACd,CAAa,CAAC;MAEN,CAAC,CAAC;IAEN;AAEA,WAAO;MACL,SAAS,MAAG;AA3+BlB,YAAAG;AA2+BqB,gBAAAA,MAAA,MAAM,YAAN,gBAAAA,IAAA;;MACf,YAAY,MAAM,WAAW,KAC3B,WAAW,CAAC,UADpB;AAEU,gBAAQ,YAAY,KAAK;AACzB,0BAAkB,KAAK;AACvB,cAAM;MACR,CAAC,CAAC;IAEV;EACE;EAEQ,mBACN,SAOA,EACE,WACA,oBACA,gBAXN,GAAA;AAkBI,UAAM,YAAa,UAAU,gBAAgB,KAAK,kBAAtD;AACI,UAAM,EAAE,YAAZ,IAA4B;AAKxB,UAAM,eAAe,KAAK,MAAM,iBAAiB,QAAQ,KAAK;AAE9D,WAAO,KAAK,sBACV,cACA,QAAQ,SACR,QAAQ,SAAS,EACjB,WAAW,KACX,IAAI,CAAC,aALX;AASQ,YAAM,SAAS,UAAU,gBAAgB,UAAU;QACjD,GAAG;QACH,UAAU;QACV;MACV,CAAS;AACD,YAAM,YAAY,sBAAsB,MAAM;AAE9C,UAAI,aAAa,gBAAgB,QAAQ;AACvC,kBAAU,eAApB;AACU,2DAAkB;AAClB,cAAM,IAAI,sBAAsB,MAAM;MACxC;AAEA,YAAM,MAAM;QACV,MAAM,OAAO;QACb,GAAI,UAAU,UACZ;UACE,SAAS;UACT,eAAe,cAAc;UAC7B,WAAW;UACX,SAAS;QACvB,IACY;UACE,WAAW,OAAO,OAAO,aAAa;UACtC,SAAS;UACT,eAAe,cAAc;UAC7B,SAAS,CAAC,OAAO;QAC/B;MACA;AAMQ,UAAI,WAAW;AACb,YAAI,gBAAgB,QAAQ;AAC1B,cAAI,OAAO;AACX,cAAI,YAAY;QAClB;AACA,YAAI,gBAAgB,UAAU;AAC5B,cAAI,QAAQ,IAAI,sBAAsB,MAAM;AAC5C,cAAI,IAAI,cAAc,aAAa;AACjC,gBAAI,gBAAgB,cAAc;UACpC;QACF;MACF;AAEA,aAAO;IACT,CAAC,GACD,WAAW,CAAC,UADlB;AAGQ,UAAI,aAAa,UAAU,iBAAiB,gBAAgB,QAAQ;AAClE,kBAAU,eAApB;AACU,2DAAkB;AAClB,cAAM;MACR;AAEA,YAAM,MAAqC;QACzC,MAAM;QACN,WAAW;QACX,SAAS;QACT,eAAe,cAAc;QAC7B,SAAS;MACnB;AAEQ,UAAI,gBAAgB,UAAU;AAC5B,YAAI,QAAQ;AACZ,YAAI,gBAAgB,cAAc;MACpC;AAEA,aAAO,GAAG,GAAG;IACf,CAAC,CAAC;EAEN;EAEO,wBACL,SACA;;;;IAIE,gBAAgB,cAAc;IAC9B,QAAQ,QAAQ;IAChB,qBAAqB,CAAC,MAAM;IAC5B,aAAa,MAHnB;IAG0B;IACpB;EAJN,GAAA;AAaI,UAAM,YAAY,KAAK,aAAa,OAAO,QAAQ,SAAS;AAE5D,UAAM,WAAW,KAAK,eAAe;AACrC,QAAI,EACF,cAAe,YAAY,SAAS,eAAgB,eACpD,cAAe,YAAY,SAAS,eAAgB,QACpD,oBAAoB,OACpB,8BAA8B,MAC9B,UAAU,CALhB,EAAA,IAMQ;AAEJ,QACE,KAAK,0BACJ,gBAAgB,kBAAkB,gBAAgB,sBACnD;AACA,oBAAc;IAChB;AAEA,UAAM,aAAa,OAAO,OAAO,CAArC,GAAyC,SAAS;MAC5C;MACA;MACA;MACA;MACA;MACA;MACA;IACN,CAAK;AAED,UAAM,YAAY,IAAI,UAA6B,MAAM,eAAe;AAExE,UAAM,gBAAgB,CAACF,eAA3B;AAIM,iBAAW,YAAYA;AAEvB,YAAM,qBACJ,gBAAgB,aADxB,IAKU,kBAAkB,cAAc,WAChC,WAAW,uBAAuB,cAG5C;AACM,YAAM,qBAAqB,KAAK,mBAC9B,YACA,EAAE,WAAW,oBAAoB,YAAY,gBAFrD,CAEsE;AAEhE,yBAAmB,aACjB,mBAAmB,WAAW,KAAK,kBAAkB;AAEvD;;;QAGE,WAAW,gBAAgB;QAC3B;AACA,2DAAkB,wBAChB,eACA;MAEJ;AAEA,aAAO;IACT;AAIA,UAAM,kBAAkB,MAA5B;AACM,WAAK,eAAe,OAAO,UAAU,EAAE;IACzC;AACA,SAAK,eAAe,IAAI,UAAU,IAAI,CAAC,UAA3C;AACM,yBAAmB,KAAK;QACtB,MAAM;QACN;QACA,QAAQ;MAChB,CAAO;IACH,CAAC;AAED,UAAM,qBAAqB,IAAI,QAAnC;AACI,QAAI,YACF;AASF,QAAI,KAAK,gBAAgB,WAAW,KAAK,EAAE,kBAAkB;AAC3D,UAAI,SAAS;AACX,kBACE,KAAK,YADf,IAGU,iBAAiB,WAAW,OAAO,aAAa,CAAA;MAEpD;AAEA,mBAAa,KACX,KAAK,WAAY,qBAAqB;QACpC,QAAQ,KAAK;QACb,UAAU,WAAW;QACrB,WAAW,WAAW;QACtB,SAAS,WAAW;MAC9B,CAAS,CAAC,EACF,KAAK,SAAS,CAACA,eAAc,cAAcA,UAAS,EAAE,UAAU,CAAC;AAOnE,6BAAuB;IACzB,OAAO;AACL,YAAM,kBAAkB,cAAc,WAAW,SAAS;AAC1D,6BAAuB,gBAAgB;AACvC,mBAAa,gBAAgB;IAC/B;AAEA,WAAO;;;MAGL,YAAY,IAAI,WAA2C,CAAC,aAAlE;AACQ,iBAAS,IAAI,eAAe;AAC5B,mBAAW,UAAU,QAAQ;AAC7B,2BAAmB,UAAU,QAAQ;MACvC,CAAC,EAAE,KAAK,MAAd,CAAqB;MACf,UAAU;IAChB;EACE;EAEO,eAAwB,EAC7B,aACA,SACA,aAAa,OACb,mBAAmB,aAAa,aAAa,gBAAgB,IAAI,QACjE,eALJ,GAAA;AAUI,UAAM,sBAAsB,oBAAI,IAApC;AASI,QAAI,SAAS;AACX,WAAK,qBAAqB,OAAO,EAAE,QAAQ,CAAC,OAAlD;AACQ,YAAI,GAAG,QAAQ,gBAAgB,cAAc;AAC3C;QACF;AAEA,cAAM,UAAU,GAAG,iBAA3B;AACQ,4BAAoB,IAAI,IAAI;UAC1B;UACA,UAAU;YACR,QAAQ,mCAAS;YACjB,UAAU,EAAC,mCAAS;UAChC;QACA,CAAS;MACH,CAAC;IACH;AAEA,UAAM,UAA8C,oBAAI,IAA5D;AAEI,QAAI,aAAa;AACf,YAAM,UAAU,oBAAI,IAA1B;AACM,WAAK,MAAM,MAAM;QACf,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QA+BR,YAAa,cAAc,oBAAqB;;;;;;;;QAShD;QAEA,eAAe,OAAO,MAAM,UAApC;AACU,gBAAM,KAAK,MAAM;AAEjB,cAAI,cAAc,mBAAmB,CAAC,QAAQ,IAAI,EAAE,GAAG;AACrD,oBAAQ,IAAI,EAAE;AACd,gBAAI,gBAAgB;AAIlB,kCAAoB,OAAO,EAAE;AAE7B,kBAAI,SAGyC,eAC3C,IACA,MACA,QAAQ;AAGV,kBAAI,WAAW,MAAM;AAGnB,yBAAS,GACN,QAAnB,EACmB;;gBAA0D;cAC/D;AAIA,kBAAI,WAAW,OAAO;AACpB,wBAAQ,IACN,IACA,MAA+C;cAEnD;AAIA,qBAAO;YACT;AAEA,gBACE,mBAAmB,QACnB,GAAG,QAAQ,gBAAgB,cAC3B;AAIA,kCAAoB,IAAI,IAAI,EAAE,IAAI,UAAU,KAA1D,CAAgE;YACpD;UACF;QACF;MACR,CAAO;IACH;AAEA,QAAI,oBAAoB,MAAM;AAC5B,0BAAoB,QAAQ,CAAC,EAAE,IAAI,UAAU,KAAnD,MAAA;AACQ,YAAI;AAQJ,YAAI,gBAAgB;AAClB,cAAI,CAAC,MAAM;AACT,mBAAO,GAAG,aAAtB;UACU;AACA,mBAAS,eAAe,IAAI,MAAM,QAAQ;QAC5C;AAGA,YAAI,CAAC,kBAAkB,WAAW,MAAM;AACtC,mBAAS,GACN,QAAb,EACa;;UAA0D;QAC/D;AAEA,YAAI,WAAW,OAAO;AACpB,kBAAQ,IAAI,IAAI,MAA+C;QACjE;MACF,CAAC;IACH;AAEA,QAAI,kBAAkB;AAQpB,WAAK,MAAM,iBAAiB,gBAAgB;IAC9C;AAEA,WAAO;EACT;EAIO,cACL,SADJ;AAr7CA,QAAAE;AAw7CI,UAAM,EAAE,UAAU,KAAtB,IAA+B;AAE3B,QAAI,SAAS;AACX,YAAM,EAAE,aAAa,QAAQ,CAAnC,EAAA,IAA0C;AACpC,YAAM,iBAAgBA,MAAA,uBAAuB,QAAQ,MAA/B,gBAAAA,IAAkC;AAExD,UACE,KAAK,eACL,gBAAgB,cAChB,CAAC,yBAAyB,QAAQ,KAClC,CAAC,KAAK,uBAAuB,IAAI,KAAK,GACtC;AACA,aAAK,uBAAuB,IAAI,KAAK;mBAErC,UAAU,KAAlB,IAEU,iBAAiB,UAAU,WAAW,iBAAiB,WAAW,EAAE,CAAA;MAExE;IACF;AAEA,WACE,KAAK,cACH,cAAc,MAAM,UAAU,KAAK,KAAK,IACxC;EACN;EAEO,aAA8B,SAAvC;AACI,UAAM,EAAE,MAAM,UAAU,aAA5B,IAA6C;AAEzC,WAAO,KAAK,cACR,aAAa,MAAM,UAAU,KAAK,OAAO,YAAY,IACrD;EACN;EAEQ,mBACN,EACE,OACA,WACA,aACA,aACA,mBACA,QAPN,GAgBI,EACE,oBACA,YACA,WACA,gBApBN,GAAA;AA4BI,UAAM,YAAY,MAChB,KAAK,MAAM,KAAU;MACnB;MACA;MACA,mBAAmB;MACnB,YAAY;IACpB,CAAO;AAEH,UAAM,mBAAmB,CACvB,MACA,kBAFN;AAIM,YAAM,OAAO,KAAK;AAElB,UAAI,WAAW,CAAC,qBAAqB,SAAS,MAAM;AAClD,8BAAsB,KAAK,OAAO;MACpC;AAEA,YAAM,WAAW,CACfC,UADR;AAOQ,YAAI,CAAC,KAAK,YAAY,CAAC,mBAAmB;AACxC,UAAAA,QAAO;QACT;AAEA,eAAO;;UAEL,MAAMA;UACN,WACE,KAAK,WAAW,aACdA,QAAO,YACP;UACJ,SAAS,yBAAyB,aAAa;UAC/C;UACA,SAAS,CAAC,KAAK;QACzB;MACM;AAEA,YAAM,WAAW,CACfA,UADR;AAGQ,eAAO,GAAG;UACR,MAAM;UACN,OAAO,SAASA,KAAI;UACpB,QAAQ;QAClB,CAAS;MACH;AAEA;;;;SAIG,KAAK,YAAY,sBAClB,KAAK,gBAAgB,KAAK,EAAE;QAC5B;AACA,YAAI,SAAS;AACX,oBACE,KAAK,YADjB,IAGY,iBAAiB,OAAO,aAAa,CAAA;QAEzC;AACA,mBAAR;AAEQ,eAAO,KACL,KAAK,WAAY,QAAe;UAC9B,QAAQ,KAAK;UACb,UAAU;UACV,cAAc,OAAO,EAAE,KAAnC,IAA4C;UAChC;UACA;UACA,wBAAwB;UACxB,mBAAmB;QAC/B,CAAW,EAAE,KACD,CAAC,cAAkD;UACjD,MAAM;UACN,OAAO,SAAS,SAAS,QAAQ,MAAM;UACvC,QAAQ;QACtB,EAAc,CACH;MAEL;AAMA,UACE,gBAAgB,UAChB,kBAAkB,cAAc,WAChC,KAAK,SACL;AACA,eAAO,SAAS,MAAM;MACxB;AAEA,aAAO,SAAS,QAAQ,MAAS;IACnC;AAEA,UAAM,kBAAkB,MACtB,KAAK,mBACH;MACE;MACA;MACA;MACA;MACA;IACV,GACQ;MACE;MACA;MACA;IACV,CAAS,EACD,KACA,qBAFR,GAGQ,YAHR,GAIQ,IACE,CAAC,YAAkD;MACjD,GAAG;MACH,QAAQ;IACpB,EAAY,CACH;AAGL,YAAQ,aAAa;MACnB;MACA,KAAK,eAAe;AAClB,cAAM,OAAO,UAArB;AAEQ,YAAI,KAAK,UAAU;AACjB,iBAAO;YACL,UAAU;YACV,YAAY,iBAAiB,MAAM,cAAc,KAAK;UAClE;QACQ;AAEA,YAAI,mBAAmB;AACrB,iBAAO;YACL,UAAU;YACV,YAAY,OACV,iBAAiB,MAAM,cAAc,OAAO,GAC5C,gBAFd,CAE+B;UAE/B;QACQ;AAEA,eAAO,EAAE,UAAU,MAAM,YAAY,gBAA7C,EAAA;MACM;MAEA,KAAK,qBAAqB;AACxB,cAAM,OAAO,UAArB;AAEQ,YAAI,KAAK,YAAY,mBAAmB;AACtC,iBAAO;YACL,UAAU;YACV,YAAY,OACV,iBAAiB,MAAM,cAAc,OAAO,GAC5C,gBAFd,CAE+B;UAE/B;QACQ;AAEA,eAAO,EAAE,UAAU,MAAM,YAAY,gBAA7C,EAAA;MACM;MAEA,KAAK;AACH,eAAO;UACL,UAAU;UACV,YAAY,OACV,iBAAiB,UAD7B,GAC0C,cAAc,KAAK,CAAC;QAE9D;MAEM,KAAK;AACH,eAAO,EAAE,UAAU,MAAM,YAAY,gBAA7C,EAAA;MAEM,KAAK;AACH,eAAO,EAAE,UAAU,MAAM,YAAY,gBAA7C,EAAA;MAEM,KAAK;AACH,eAAO,EAAE,UAAU,OAAO,YAAY,MAA9C;IACI;EACF;AACF;AAEA,SAAS,uBAAT;AACE,MAAI,eAAe;SAEZ,IAAO;IACZ,OAAJ;AACM,qBAAe;IACjB;IACA,WAAJ;AACM,gBACE,cADR,EAAA;IAII;EACJ,CAAG;AACH;AASA,SAAS,yBAAyB,UAAlC;AACE,MAAI,aAAa;AAEjB,QAAM,UAAU;IACd,gBAAgB,CAAC,SAArB;AACM,mBACE,CAAC,CAAC,KAAK,cACP,KAAK,WAAW,KAAK,CAAC,cAAc,UAAU,KAAK,UAAU,QAAQ;AAEvE,UAAI,CAAC,YAAY;AACf,eAAO;MACT;IACF;EACJ,CAAG;AAED,SAAO;AACT;AAEA,SAAS,+BAA+B,UAAxC;AACE,SAAO,MAAM,UAAU;IACrB,gBAAgB,CAAC,SAArB;AA9tDA,UAAAD;AAiuDM,WACEA,MAAA,KAAK,eAAL,gBAAAA,IAAiB,KAAK,CAAC,cAAc,UAAU,KAAK,UAAU,WAC9D;AACA;MACF;AAEA,aAAO;QACL,GAAG;QACH,YAAY;UACV,GAAI,KAAK,cAAc,CAAjC;UACU;YACE,MAAM,KAAK;YACX,MAAM,EAAE,MAAM,KAAK,MAAM,OAAO,cAA5C;UACA;QACA;MACA;IACI;EACJ,CAAG;AACH;;;AC1rDA,IAAI,uBAAuB;AAmjB3B,IAAa,eAAb,MAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA2DE,YAAY,SAAd;AA1DS;AACA;AAIA;;;;AAgBA;AACA;AACA;AACS;AAER;AACA;AACA,+CAAiD,CAA3D;AACU,+CAAiD,CAA3D;AAmqBS;;;;;;;;;;;;;;;;;AAkIC,mDAA0B,IAAI,kBACpC,2BAA2B;AAxwB3B,QAAI,SAAS;AACX,gBACE,QAAQ,OADhB,EAAA;AAOM,gBACE,QAAQ,MADhB,EAAA;IAMI;AAEA,UAAM,EACJ,OACA,mBACA,UAAU,OACV,qBAAqB,GACrB,qBAAqB,MACrB,gBAAAE,iBACA,gBACA,yBAAyB,MAAM,wBAC/B,YACA,UACA,aACA,MACA,qBAAqB,IAAI,sBAb/B,EAAA,IAcQ;AAEJ,SAAK,OAAO;AACZ,SAAK,QAAQ;AACb,SAAK,qBAAqB;AAC1B,SAAK,iBAAiBA,mBAAkB,CAA5C;AACI,SAAK,iBAAiB;MACpB,GAAG;MACH,UAAS,qCAAU,YAAW;IACpC;AAEI,SAAK,aAAa,KAAK,WAAW,KAAK,IAAI;AAC3C,SAAK,QAAQ,KAAK,MAAM,KAAK,IAAI;AACjC,SAAK,SAAS,KAAK,OAAO,KAAK,IAAI;AACnC,SAAK,gBAAgB,KAAK,cAAc,KAAK,IAAI;AACjD,SAAK,aAAa,KAAK,WAAW,KAAK,IAAI;AAC3C,SAAK,2BAA2B,KAAK,2BACnC,KAAK,yBAAyB,KAAK,IAAI;AAEzC,SAAK,UAAU;AAEf,SAAK,eAAe,IAAI,aAAa;MACnC,QAAQ;MACR,gBAAgB,KAAK;MACrB;MACA;MACA;MACA;MACA,aAAa,CAAC,CAAC;MACf,eAAe;MACf;MACA;MACA,aACE,KAAK,eAAe,UAClB,MAAV;AACY,YAAI,KAAK,gBAAgB;AACvB,eAAK,eAAnB;QACY;MACF,IACA;MACJ;IACN,CAAK;AAED,SAAK,wBAAwB,WAAW,qBAAqB;AAC7D,QAAI,oBAAoB;AACtB,iBAAW,MAAjB;AACQ,aAAK,wBAAwB;MAC/B,GAAG,kBAAkB;IACvB;AAEA,QAAI,KAAK,eAAe;AAAS,WAAK,kBAA1C;EACE;EArIA,IAAW,sBAAsB,OAAnC;AACI,SAAK,aAAa,wBAAwB;EAC5C;;;;;;;;EASA,IAAW,wBAAb;AACI,WAAO,KAAK,aAAa;EAC3B;EA0HQ,oBAAV;AACI,QAAI,OAAO,WAAW,aAAa;AACjC;IACF;AAKA,UAAM,qBAAqB;AAI3B,UAAM,iBAAiB,OAAO,IAAI,iBAAiB;AACnD,KAAC,mBAAmB,cAAc,IAChC,mBAAmB,cAAc,KAAM,CAA7C,GAAuE,KACjE,IAAI;AAEN,uBAAmB,oBAAoB;AAKvC,QAAI,CAAC,wBAAwB,SAAS;AACpC,6BAAuB;AACvB,UACE,OAAO,YACP,OAAO,QAAQ,OAAO,2BACH,KAAK,OAAO,SAAS,QAAQ,GAChD;AACA,mBAAW,MAAnB;AACU,cAAI,CAAE,OAAe,iCAAiC;AACpD,kBAAM,MAAM,OAAO;AACnB,kBAAM,KAAK,OAAO,IAAI;AACtB,gBAAI;AACJ,gBAAI,OAAO,OAAO,UAAU;AAC1B,kBAAI,GAAG,QAAQ,SAAS,IAAI,IAAI;AAC9B,sBACE;cAEJ,WAAW,GAAG,QAAQ,UAAU,IAAI,IAAI;AACtC,sBACE;cACJ;YACF;AACA,gBAAI,KAAK;yBACP,UAAU,IACR,wEAEA,GADhB;YAGY;UACF;QACF,GAAG,GAAK;MACV;IACF;EACF;;;;;;EAOA,IAAI,oBAAN;AACI,WAAO,KAAK,aAAa;EAC3B;;;;;EAMA,IAAI,aAAN;AACI,WAAO,KAAK,aAAa;EAC3B;EAEA,IAAI,WAAW,YAAjB;AACI,SAAK,aAAa,aAAa;EACjC;;;;;;;;;;;EAYO,OAAT;AACI,SAAK,aAAa,KAAtB;EACE;;;;;;;;;;;;;;;;;;;;EAqBO,WAIL,SAJJ;AAMI,QAAI,KAAK,eAAe,YAAY;AAClC,gBAAU,aACR,KAAK,eAAe,YAGpB,OAAO;IAEX;AAEA,WAAO,KAAK,aAAa,WAA8B,OAAO;EAChE;;;;;;;;;;EAWO,MAIL,SAJJ;AAMI,QAAI,KAAK,eAAe,OAAO;AAC7B,gBAAU,aAAa,KAAK,eAAe,OAAO,OAAO;IAC3D;AAEA,QAAI,SAAS;AACX,gBACG,QAAQ,gBAA0C,qBAD3D,EAAA;AAQM,gBACG,QAAQ,gBAA0C,WAD3D,EAAA;AAOM,gBACE,QAAQ,OADhB,EAAA;AAMM,gBACE,QAAQ,MAAM,SAAS,YAD/B,EAAA;AAKM,gBACE,CAAE,QAAgB,mBAD1B,EAAA;AAKM,gBACE,CAAE,QAAgB,cAD1B,EAAA;AAKM,gBACE,CAAE,QAAgB,6BAD1B,EAAA;IAII;AAEA,WAAO,KAAK,aAAa,MAAyB,OAAO;EAC3D;;;;;;;;;EAUO,OAKL,SALJ;AAOI,UAAM,sBAAsB,aAC1B,QACE;MACE,aAAa;MACb,aAAa;IACvB,GACQ,KAAK,eAAe,MAAM,GAE5B,OAAO;AAMT,QAAI,SAAS;AACX,gBACE,oBAAoB,UAD5B,EAAA;AAKM,gBACE,oBAAoB,gBAAgB,kBAClC,oBAAoB,gBAAgB,YAA9C,EAAA;IAGI;AAEA,kBAAc,oBAAoB,UAAU,kBAAkB,QAAQ;AAEtE,WAAO,KAAK,aAAa,OACvB,mBAAmB;EAEvB;;;;;EAMO,UAIL,SAJJ;AAMI,UAAM,QAAQ,CAAlB;AAEI,UAAM,aACJ,KAAK,aAAa,yBAAgC,OAAO;AAE3D,UAAM,SAAS,WAAW,KACxB,IAAI,CAAC,YAAY;MACf,GAAG;MACH,MAAM,KAAK,aAAa,cAAc;QACpC,UAAU,QAAQ;QAClB,MAAM,OAAO;QACb,aAAa,QAAQ;QACrB;MACV,CAAS;IACT,EAAQ,CAAC;AAGL,WAAO,OAAO,OAAO,QAAQ,EAAE,SAAS,WAAW,QAAvD,CAAgE;EAC9D;EAoCO,UAIL,SACA,aAAsB,OAL1B;AAOI,WAAO,KAAK,MAAM,UAChB,EAAE,GAAG,SAAS,OAAO,KAAK,UAAU,QAAQ,KAAK,EADvD,GAEM,UAAU;EAEd;;;;;;;;;;;;;;;;;EAmBO,cAIL,SAJJ;AAMI,UAAM,cAAc,KAAK,aAAa;AAEtC,WAAO,KAAK,MACT,cAAc;MACb,GAAG;MACH,UAAU,KAAK,UAAU,QAAQ,UAAU,WAAW;IAC9D,CAAO,EACA,KACC,IAAI,CAAC,WADb;AAOU,UAAI,SAAS;AACX,YAAI,aAAa;AACf,gBAAM,OAAO,KAAK,aAAa,aAAa;YAC1C,GAAG;YACH,MAAM,OAAO;UAC7B,CAAe;AACD,iBAAO,EAAE,GAAG,QAAQ,KAAlC;QAGY;MACF;AAEA,aAAO;IACT,CAAC,CAAC;EAER;EAoCO,aAIL,SACA,aAAsB,OAL1B;AAOI,WAAO,KAAK,MAAM,aAChB,EAAE,GAAG,SAAS,UAAU,KAAK,UAAU,QAAQ,QAAQ,EAD7D,GAEM,UAAU;EAEd;;;;;;EAOO,WAIL,SAJJ;AAMI,UAAM,MAAM,KAAK,MAAM,WAA8B,OAAO;AAE5D,QAAI,QAAQ,cAAc,OAAO;AAC/B,WAAK,aAAa,iBAAxB;IACI;AAEA,WAAO;EACT;;;;;;;;;;;;EAaO,cAIL,SAJJ;AAMI,UAAM,MAAM,KAAK,MAAM,cAAiC,OAAO;AAE/D,QAAI,QAAQ,cAAc,OAAO;AAC/B,WAAK,aAAa,iBAAxB;IACI;AAEA,WAAO;EACT;EAEO,wBAAwB,IAAjC;AACI,SAAK,iBAAiB;EACxB;EAEO,aACL,SADJ;AAGI,WAAO,QAAQ,KAAK,MAAM,SAAS,EAAE,QAAQ,KAAjD,CAAuD;EACrD;;;;;;;;;;;;;;;;;EAkBO,aAAT;AACI,WAAO,QAAQ,QAAnB,EACO,KAAK,MACJ,KAAK,aAAa,WAAW;MAC3B,gBAAgB;IAC1B,CAAS,CAAC,EAEH,KAAK,MAAM,QAAQ,IAAI,KAAK,oBAAoB,IAAI,CAAC,OAAO,GAAnE,CAAuE,CAAC,CAAC,EAClE,KAAK,MAAM,KAAK,yBAAvB,CAAiD;EAC/C;;;;;EAMO,aAAT;AACI,WAAO,QAAQ,QAAnB,EACO,KAAK,MACJ,KAAK,aAAa,WAAW;MAC3B,gBAAgB;IAC1B,CAAS,CAAC,EAEH,KAAK,MAAM,QAAQ,IAAI,KAAK,oBAAoB,IAAI,CAAC,OAAO,GAAnE,CAAuE,CAAC,CAAC;EACvE;;;;;;EAOO,aAAa,IAAtB;AACI,SAAK,oBAAoB,KAAK,EAAE;AAChC,WAAO,MAAX;AACM,WAAK,sBAAsB,KAAK,oBAAoB,OAClD,CAAC,MAAM,MAAM,EAAE;IAEnB;EACF;;;;;;EAOO,aAAa,IAAtB;AACI,SAAK,oBAAoB,KAAK,EAAE;AAChC,WAAO,MAAX;AACM,WAAK,sBAAsB,KAAK,oBAAoB,OAClD,CAAC,MAAM,MAAM,EAAE;IAEnB;EACF;;;;;;;;;;;;;;;EAoCO,yBACL,gBADJ;AAGI,WAAO,KAAK,aAAa,yBAAyB,cAAc;EAClE;;;;;;;;;;;;EAaO,eAIL,SAJJ;AAMI,UAAMC,OAAM,KAAK,aAAa,eAC5B,OAAmE;AAErE,UAAM,UAAkC,CAA5C;AACI,UAAM,UAAmD,CAA7D;AAEI,IAAAA,KAAI,QAAQ,CAACC,SAAQ,aAAzB;AACM,cAAQ,KAAK,QAAQ;AACrB,cAAQ,KAAKA,OAAM;IACrB,CAAC;AAED,UAAM,SAAS,QAAQ,IACrB,OAAoB;AAKtB,WAAO,UAAU;AACjB,WAAO,UAAU;AAKjB,WAAO,MAAM,CAAC,UAAlB;iBACM,UAAU,MAAhB,IAEQ,KAFR;IAII,CAAC;AAED,WAAO;EACT;;;;;;;;;;;;;;EAeO,qBACL,UAAiC,UADrC;AAGI,WAAO,KAAK,aAAa,qBAAqB,OAAO;EACvD;;;;;;;;;;;;EAaO,QAAQ,YAAjB;AACI,WAAO,KAAK,MAAM,QAAQ,UAAU;EACtC;;;;;;;;EASO,QAAQ,iBAAjB;AACI,WAAO,KAAK,MAAM,QAAQ,eAAe;EAC3C;;;;EAKO,QAAQ,SAAjB;AACI,SAAK,OAAO;EACd;EAEA,IAAW,iBAAb;AACI,WAAO,KAAK,aAAa;EAC3B;EAMQ,UAAU,UAAwB,cAAc,OAA1D;AACI,UAAM,cAAc,KAAK,aAAa,UAAU,QAAQ;AACxD,WAAO,cACH,KAAK,wBAAwB,kBAAkB,WAAW,IAC1D;EACN;AAoFF;AAEA,IAAI,SAAS;AACX,eAAa,UAAU,qBAAqB;AAC9C;;;ACtgDA,IAAM,EAAE,gBAAAC,gBAAR,IAA2B,OAAO;AAOlC,SAAS,sBAAsB,OAA/B;AACE,SAAO,gBAAgB,KAAK,KAAK,aAAa;AAChD;AAEA,gBAAgB,qBACd,UADF;AArBA,MAAAC;AAwBE,QAAM,UAAU,IAAI,YAAY,OAAO;AACvC,QAAM,eAAcA,MAAA,SAAS,YAAT,gBAAAA,IAAkB,IAAI;AAM1C,QAAM,QAAQ,2CAAa;;;;;;;;;;;;;;;AAe3B,QAAM,WAAW,aAAY,+BAAO,SAAS,CAAC,QAAQ,CAAC,CAAC,SAAQ;AAChE,MAAI,SAAS;AACb,YACE,SAAS,QAAQ,OAAO,SAAS,KAAK,cAAc,YADxD,EAAA;AAKE,QAAM,SAAS,SAAS;AACxB,QAAM,SAAS,OAAO,UAAxB;AACE,MAAI,OAAO;AACX,MAAI,sBAAsB;AAC1B,MAAI;AAIJ,QAAM,sBAAsB,MAC1B,uBAAuB,OAAO,CAAC,KAAK,OAAO,OAAO,CAAC,KAAK;AAE1D,MAAI;AACF,WAAO,CAAC,MAAM;AACZ,OAAC,EAAE,OAAO,KAAhB,IAAyB,MAAM,OAAO,KAAtC;AACM,YAAM,QAAQ,OAAO,UAAU,WAAW,QAAQ,QAAQ,OAAO,KAAK;AACtE,YAAM,aAAa,OAAO,SAAS,SAAS,SAAS;AACrD,gBAAU;AACV,UAAI,KAAK,OAAO,QAAQ,UAAU,UAAU;AAC5C,aAAO,KAAK,MAAM,CAAC,oBAAzB,GAAgD;AACxC,8BAAsB;AACtB,YAAI;AACJ,SAAC,SAAS,MAAM,IAAI;UAClB,OAAO,MAAM,GAAG,EAAE;UAClB,OAAO,MAAM,KAAK,SAAS,MAAM;QAC3C;AACQ,cAAM,IAAI,QAAQ,QAAQ,UAAU;AACpC,cAAM,UAAU,aAAa,QAAQ,MAAM,GAAG,CAAC,CAAC;AAChD,cAAMC,eAAc,QAAQ,cAAc;AAC1C,YACEA,gBACAA,aAAY,YAAtB,EAAoC,QAAQ,kBAAkB,MAAM,IAC1D;AACA,gBAAM,IAAI,MACR,+DAA+D;QAEnE;AAGA,cAAM,OAAO,QAAQ,MAAM,CAAC;AAE5B,YAAI,MAAM;AACR,gBAAM;QACR;AACA,aAAK,OAAO,QAAQ,QAAQ;MAC9B;AACA,UAAI,oBAAV,GAAiC;AACzB;MACF;IACF;AACA,UAAM,IAAI,MAAM,iCAAiC;EACnD,UAAF;AACI,WAAO,OAAX;EACE;AACF;AAEA,eAAsB,kBAEpB,UAAoB,WAFtB;AAGE,mBAAiB,QAAQ,qBAAqB,QAAQ,GAAG;AACvD,UAAM,SAAS,kBAAkB,UAAU,IAAI;AAC/C,QAAI,OAAO,KAAK,MAAM,EAAE,UAAU;AAAG;AACrC,QAAI,sBAAsB,MAAM,GAAG;AACjC,UAAI,OAAO,KAAK,MAAM,EAAE,WAAW,KAAK,OAAO,YAAY,MAAM;AAC/D;MACF;AACA,UAAI,OAAO,EAAE,GAAG,OAAO,QAA7B;AACM,UAAI,YAAY,QAAQ;AACtB,aAAK,aAAa;UAChB,GAAG,KAAK;UACR,CAAC,sBAAsB,GAAG,IAAI,uBAC5B,OAAO,UAAU,CAD7B,CAC+B;QAE/B;MACM;AACA,gBAAU,IAAS;IACrB,OAAO;AACL,gBAAU,MAAM;IAClB;EACF;AACF;AAEA,SAAS,aAAa,YAAtB;AACE,QAAM,cAAsC,CAA9C;AACE,aAAW,MAAM,IAAI,EAAE,QAAQ,CAAC,SAAlC;AACI,UAAM,IAAI,KAAK,QAAQ,GAAG;AAC1B,QAAI,IAAI,IAAI;AAEV,YAAM,OAAO,KAAK,MAAM,GAAG,CAAC,EAAE,KAApC,EAA2C,YAA3C;AACM,YAAM,QAAQ,KAAK,MAAM,IAAI,CAAC,EAAE,KAAtC;AACM,kBAAY,IAAI,IAAI;IACtB;EACF,CAAC;AACD,SAAO;AACT;AAEA,SAAS,kBAAkB,UAAoB,UAA/C;AACE,MAAI,SAAS,UAAU,KAAK;AAC1B,UAAM,IAAI,YACR,iDAAiD,SAAS,MAAM,IAChE,EAAE,UAAU,SAFlB,CAE4B;EAE1B;AAEA,MAAI;AACF,WAAO,KAAK,MAAM,QAAQ;EAC5B,SAAS,KAAK;AACZ,UAAM,IAAI,iBAAiB,KAAK,EAAE,UAAU,SAAhD,CAA0D;EACxD;AACF;AAEA,SAAS,iCACP,UACA,UAFF;AAIE,MAAI;AACF,WAAO,KAAK,MAAM,QAAQ;EAC5B,SAAS,KAAK;AACZ,UAAM,IAAI,iBAAiB,KAAK,EAAE,UAAU,SAAhD,CAA0D;EACxD;AACF;AAEA,SAAS,cAAc,UAAoB,UAA3C;AACE,QAAM,cAAc,SAAS,QAAQ,IAAI,cAAc;AAEvD,MAAI,2CAAa,SAAS,sCAAsC;AAC9D,WAAO,iCAAiC,UAAU,QAAQ;EAC5D;AAEA,SAAO,kBAAkB,UAAU,QAAQ;AAC7C;AAEA,SAAgB,0BACd,YADF;AAGE,SAAO,CAAC,aACN,SAAS,KADb,EACoB,KAAK,CAAC,aAD1B;AAEM,UAAM,SAAS,cAAc,UAAU,QAAQ;AAE/C,QACE,CAAC,MAAM,QAAQ,MAAM,KACrB,CAACF,gBAAe,KAAK,QAAQ,MAAM,KACnC,CAACA,gBAAe,KAAK,QAAQ,QAAQ,GACrC;AACA,YAAM,IAAI,YACR,4CACE,MAAM,QAAQ,UAAU,IACtB,WAAW,IAAI,CAAC,OAAO,GAAG,aAAa,IACvC,WAAW,aACf,MACA,EAAE,UAAU,SAFtB,CAEgC;IAE1B;AACA,WAAO;EACT,CAAC;AACL;;;ACnMA,IAAM,qBAA+C;EACnD,cAAc;EACd,mBAAmB;EACnB,oBAAoB;;AAGtB,IAAM,iBAAiB;;EAErB,QAAQ;;;;;;;;;;;;;EAaR,gBAAgB;;AAGlB,IAAM,iBAAiB;EACrB,QAAQ;;AAGH,IAAM,qBAAqB;EAChC,MAAM;EACN,SAAS;EACT,SAAS;;AAGJ,IAAM,iBAAuC,CAAC,KAAK,YACxD,QAAQ,GAAG;AAEP,SAAU,yBACd,WACA,mBACG,SAA0B;AAE7B,UAAQ,QAAQ,cAAc;AAC9B,SAAO,iCACL,WACA,gBACA,GAAG,OAAO;AAEd;AAEM,SAAU,iCACd,WACA,YACG,SAAqB;AAExB,MAAI,UAAU,CAAA;AACd,MAAI,OAAO,CAAA;AAEX,UAAQ,QAAQ,CAAC,WAAU;AArE7B,QAAAG;AAsEI,cAAU;MACR,GAAG;MACH,GAAG,OAAO;MACV,SAAS;QACP,GAAG,QAAQ;QACX,GAAG,OAAO;;;AAId,QAAI,OAAO,aAAa;AACtB,cAAQ,cAAc,OAAO;IAC/B;AAEA,YAAQ,QAAS,YAAUA,MAAA,OAAO,SAAP,gBAAAA,IAAa,WAAU,CAAA,GAC/C,OAAO,QAAQ,QAAS,MAAM,EAC9B,KAAK,GAAG;AAEX,WAAO;MACL,GAAG;MACH,GAAG,OAAO;;EAEd,CAAC;AAED,UAAQ,UAAU,uBAChB,QAAQ,SACR,KAAK,kBAAkB;AAIzB,QAAM,EAAE,eAAe,YAAY,WAAW,MAAK,IAAK;AACxD,QAAM,OAA0B,EAAE,eAAe,UAAS;AAE1D,MAAI,KAAK,qBAAqB,OAAO,KAAK,cAAc,CAAA,CAAE,EAAE;AACzD,SAAa,aAAa;AAG7B,MAAI,KAAK;AAAe,SAAa,QAAQ,QAAQ,OAAOC,MAAK;AAEjE,SAAO;IACL;IACA;;AAEJ;AAKA,SAAS,uBACP,SACA,oBAAuC;AAGvC,MAAI,CAAC,oBAAoB;AACvB,UAAMC,qBAA4C,CAAA;AAClD,WAAO,KAAK,OAAO,OAAO,CAAC,EAAE,QAAQ,CAAC,SAAQ;AAC5C,MAAAA,mBAAkB,KAAK,YAAW,CAAE,IAAI,QAAQ,IAAI;IACtD,CAAC;AACD,WAAOA;EACT;AAMA,QAAM,aACJ,CAAA;AACF,SAAO,KAAK,OAAO,OAAO,CAAC,EAAE,QAAQ,CAAC,SAAQ;AAC5C,eAAW,KAAK,YAAW,CAAE,IAAI;MAC/B,cAAc;MACd,OAAO,QAAQ,IAAI;;EAEvB,CAAC;AAED,QAAM,oBAA4C,CAAA;AAClD,SAAO,KAAK,UAAU,EAAE,QAAQ,CAAC,SAAQ;AACvC,sBAAkB,WAAW,IAAI,EAAE,YAAY,IAAI,WAAW,IAAI,EAAE;EACtE,CAAC;AACD,SAAO;AACT;;;ACnJO,IAAM,eAAe,CAAC,YAA7B;AACE,YACE,WAAW,OAAO,UAAU,aADhC,EAAA;AAeA;;;ACbO,IAAM,0BAA0B,MAAK;AAC1C,MAAI,OAAO,oBAAoB;AAC7B,WAAO,EAAE,YAAY,OAAO,QAAQ,MAAK;AAE3C,QAAM,aAAa,IAAI,gBAAe;AACtC,QAAM,SAAS,WAAW;AAC1B,SAAO,EAAE,YAAY,OAAM;AAC7B;;;ACVO,IAAM,YAAY,CACvB,WACA,gBACE;AACF,QAAM,UAAU,UAAU,WAAU;AACpC,QAAM,aAAa,QAAQ;AAE3B,MAAI,YAAY;AACd,WAAO;EACT,WAAW,OAAO,gBAAgB,YAAY;AAC5C,WAAO,YAAY,SAAS;EAC9B,OAAO;AACL,WAAQ,eAA0B;EACpC;AACF;;;ACZM,SAAU,iBAAiB,WAAmB,MAAuB;AAGzE,QAAM,cAAwB,CAAA;AAC9B,QAAM,gBAAgB,CAAC,KAAa,UAAiB;AACnD,gBAAY,KAAK,GAAG,GAAG,IAAI,mBAAmB,KAAK,CAAC,EAAE;EACxD;AAEA,MAAI,WAAW,MAAM;AACnB,kBAAc,SAAS,KAAK,KAAM;EACpC;AACA,MAAI,KAAK,eAAe;AACtB,kBAAc,iBAAiB,KAAK,aAAa;EACnD;AACA,MAAI,KAAK,WAAW;AAClB,QAAI;AACJ,QAAI;AACF,4BAAsB,KAAK,UAAU,KAAK,SAAS;IACrD,SAAS,YAAY;AACnB,aAAO,EAAE,WAAU;IACrB;AACA,kBAAc,aAAa,mBAAmB;EAChD;AACA,MAAI,KAAK,YAAY;AACnB,QAAI;AACJ,QAAI;AACF,6BAAuB,KAAK,UAAU,KAAK,UAAU;IACvD,SAAS,YAAY;AACnB,aAAO,EAAE,WAAU;IACrB;AACA,kBAAc,cAAc,oBAAoB;EAClD;AAQA,MAAI,WAAW,IACb,cAAc;AAChB,QAAM,gBAAgB,UAAU,QAAQ,GAAG;AAC3C,MAAI,kBAAkB,IAAI;AACxB,eAAW,UAAU,OAAO,aAAa;AACzC,kBAAc,UAAU,OAAO,GAAG,aAAa;EACjD;AACA,QAAM,oBAAoB,YAAY,QAAQ,GAAG,MAAM,KAAK,MAAM;AAClE,QAAM,SACJ,cAAc,oBAAoB,YAAY,KAAK,GAAG,IAAI;AAC5D,SAAO,EAAE,OAAM;AACjB;;;AC5BA,IAAM,cAAc,MAAM,MAAM,KAAK;AACrC,SAAS,OAAI;AAAI;AA2OX,IAAO,eAAP,cAA4B,WAAU;EAC1C,YAAY,UAAgC,CAAA,GAAE;AAC5C,QAAI;MACF,MAAM;;MAEN,OAAO;MACP,OAAAC,SAAQ;MACR;MACA;MACA;MACA,yBAAyB;MACzB,GAAG;IAAc,IACf;AAEJ,QAAI,SAAS;AAGX,mBAAa,kBAAkB,WAAW;IAC5C;AAEA,UAAM,aAAa;MACjB,MAAM,QAAQ,EAAE,mBAAmB,mBAAkB,CAAE;MACvD,SAAS,eAAe;MACxB,aAAa,eAAe;MAC5B,SAAS,eAAe;;AAG1B,UAAM,CAAC,cAAa;AAClB,UAAI,YAAY,UAAU,WAAW,GAAG;AAExC,YAAM,UAAU,UAAU,WAAU;AAEpC,YAAM,OAAO,EAAE,GAAG,QAAQ,KAAI;AAC9B,UAAI,wBAAwB,UAAU,KAAK,GAAG;AAC5C,aAAK,SAAS;UACZ;UACA,GAAI,KAAK,UAAU,CAAA;;MAEvB;AAEA,YAAM,gBAAgB;QACpB;QACA,SAAS,QAAQ;QACjB,aAAa,QAAQ;QACrB,SAAS,QAAQ;;AAInB,YAAM,EAAE,SAAAC,UAAS,KAAI,IAAK,iCACxB,WACAD,QACA,oBACA,YACA,aAAa;AAGf,UAAI,KAAK,aAAa,CAAC,wBAAwB;AAC7C,aAAK,YAAY,yBACf,KAAK,WACL,UAAU,KAAK;MAEnB;AAEA,UAAI,aAA0C,IAAI,gBAAe;AACjE,UAAI,oBAAoB,MAAK;AAC3B,qBAAa;MACf;AACA,UAAIC,SAAQ,QAAQ;AAClB,cAAM,iBAA8BA,SAAQ;AAK5C,cAAM,WAAW,MAAK;AACpB,mDAAY,MAAM,eAAe;QACnC;AACA,uBAAe,iBAAiB,SAAS,UAAU,EAAE,MAAM,KAAI,CAAE;AACjE,4BAAoB,MAAK;AACvB,mDAAY,OAAO,oBAAoB,SAAS;AAChD,uBAAa;AAEb,yBAAe,oBAAoB,SAAS,QAAQ;AACpD,8BAAoB;QACtB;AAGA,mBAAW,OAAO,iBAAiB,SAAS,mBAAmB;UAC7D,MAAM;SACP;MACH;AACA,MAAAA,SAAQ,SAAS,WAAW;AAE5B,UAAI,oBAAoB,CAAC,oBAAoB,UAAU,KAAK,GAAG;AAC7D,QAAAA,SAAQ,SAAS;MACnB;AAEA,aAAO,IAAI,WAAW,CAAC,aAAY;AACjC,YAAIA,SAAQ,WAAW,OAAO;AAC5B,gBAAM,EAAE,QAAQ,WAAU,IAAK,iBAAiB,WAAW,IAAI;AAC/D,cAAI,YAAY;AACd,kBAAM;UACR;AACA,sBAAY;QACd,OAAO;AACL,UAAAA,SAAQ,OAAO,KAAK,UAAU,IAAI;QACpC;AAMA,cAAM,eACJ,kBAAkB,MAAM,MAAM,KAAK,KAAK;AAE1C,cAAM,eAAe,SAAS,KAAK,KAAK,QAAQ;AAChD,qBAAc,WAAWA,QAAO,EAC7B,KAAK,CAAC,aAAY;AAzX7B,cAAAC;AA0XY,oBAAU,WAAW,EAAE,SAAQ,CAAE;AACjC,gBAAM,SAAQA,MAAA,SAAS,YAAT,gBAAAA,IAAkB,IAAI;AAEpC,cAAI,UAAU,QAAQ,qBAAqB,KAAK,KAAK,GAAG;AACtD,mBAAO,kBAAkB,UAAU,YAAY;UACjD,OAAO;AACL,mBAAO,0BAA0B,SAAS,EAAE,QAAQ,EAAE,KACpD,YAAY;UAEhB;QACF,CAAC,EACA,KAAK,MAAK;AACT,4BAAiB;AACjB,mBAAS,SAAQ;QACnB,CAAC,EACA,MAAM,CAAC,QAAO;AACb,4BAAiB;AACjB,mBAAS,MAAM,GAAG;QACpB,CAAC;AAEH,eAAO,MAAK;AAGV,cAAI;AAAY,uBAAW,MAAK;QAClC;MACF,CAAC;IACH,CAAC;EACH;;;;ACxSI,IAAO,sBAAP,cAAmC,WAAU;EACjD,YAAY,UAAuC,CAAA,GAAE;AACnD,UAAM,CAAC,WAAW,YAAW;AAC3B,YAAM,SAAS,UAAU;AAEzB,YAAM,gBAAgB,OAAO,cAAc,EAAE;AAC7C,YAAM,UAAU,UAAU,WAAU;AACpC;AACE,cAAM,EACJ,MACA,SAAAC,UACA,YAAY,UAAS,IACnB,QACF,CAAA,GACA,cAAc,iBACd,QAAQ,iBACR,QAAQ,eAAe;AAGzB,YAAI,cAAc,WAAW;AAC3B,oBAAU,WAAW,CAAC,EAAE,SAAS,WAAU,MAAM;AAC/C,mBAAO;cACL,SAAS;;gBAEP;kBACE,6BAA6B;kBAC7B,gCAAgCA;;gBAElC;cAAO;;UAGb,CAAC;QACH;MACF;AACA;AACE,cAAM,EAAE,YAAY,aAAY,IAAK,QACnC,CAAA,GACA,cAAc,yBACd,QAAQ,uBAAuB;AAEjC,YAAI,cAAc,cAAc;AAC9B,oBAAU,aAAa;;YAErB;cACE,eAAe;gBACb,MAAM;gBACN,SAAS,OAAO;;;YAGpB,UAAU;UAAU;QAExB;MACF;AAEA,aAAO,QAAQ,SAAS;IAC1B,CAAC;EACH;;;;ACjHI,IAAO,WAAP,cAAwB,WAAU;EACtC,YAAY,UAA4B,CAAA,GAAE;AACxC,UAAM,EAAE,MAAM,OAAO,QAAO,IAAK,WAAW,KAAK;MAC/C,IAAI,oBAAoB,OAAO;MAC/B,IAAI,aAAa,OAAO;KACzB;AACD,UAAM,OAAO;AACb,WAAO,OAAO,MAAM,EAAE,MAAM,MAAK,CAAE;EACrC;;AAOK,IAAM,iBAAiB,CAAC,UAA4B,CAAA,MACzD,IAAI,SAAS,OAAO;;;AC5DtB,IAAM,WAAW,oBAAI,IAAG;AAGxB,IAAM,oBAAoB,oBAAI,IAAG;AAEjC,IAAI,wBAAwB;AAC5B,IAAI,gCAAgC;AAIpC,SAASC,WAAU,QAAc;AAC/B,SAAO,OAAO,QAAQ,WAAW,GAAG,EAAE,KAAI;AAC5C;AAEA,SAAS,gBAAgB,KAAa;AACpC,SAAOA,WAAU,IAAI,OAAO,KAAK,UAAU,IAAI,OAAO,IAAI,GAAG,CAAC;AAChE;AAKA,SAAS,iBAAiB,KAAiB;AACzC,MAAM,WAAW,oBAAI,IAAG;AACxB,MAAM,cAAgC,CAAA;AAEtC,MAAI,YAAY,QAAQ,SAAA,oBAAkB;AACxC,QAAI,mBAAmB,SAAS,sBAAsB;AACpD,UAAI,eAAe,mBAAmB,KAAK;AAC3C,UAAI,YAAY,gBAAgB,mBAAmB,GAAI;AAGvD,UAAI,eAAe,kBAAkB,IAAI,YAAY;AACrD,UAAI,gBAAgB,CAAC,aAAa,IAAI,SAAS,GAAG;AAGhD,YAAI,uBAAuB;AACzB,kBAAQ,KAAK,iCAAiC,eAAe,+LAEqB;;iBAE3E,CAAC,cAAc;AACxB,0BAAkB,IAAI,cAAc,eAAe,oBAAI,KAAG;;AAG5D,mBAAa,IAAI,SAAS;AAE1B,UAAI,CAAC,SAAS,IAAI,SAAS,GAAG;AAC5B,iBAAS,IAAI,SAAS;AACtB,oBAAY,KAAK,kBAAkB;;WAEhC;AACL,kBAAY,KAAK,kBAAkB;;EAEvC,CAAC;AAED,SAAA,SAAA,SAAA,CAAA,GACK,GAAG,GAAA,EACN,YAAW,CAAA;AAEf;AAEA,SAAS,SAAS,KAAiB;AACjC,MAAM,UAAU,IAAI,IAAyB,IAAI,WAAW;AAE5D,UAAQ,QAAQ,SAAA,MAAI;AAClB,QAAI,KAAK;AAAK,aAAO,KAAK;AAC1B,WAAO,KAAK,IAAI,EAAE,QAAQ,SAAA,KAAG;AAC3B,UAAM,QAAQ,KAAK,GAAG;AACtB,UAAI,SAAS,OAAO,UAAU,UAAU;AACtC,gBAAQ,IAAI,KAAK;;IAErB,CAAC;EACH,CAAC;AAED,MAAM,MAAM,IAAI;AAChB,MAAI,KAAK;AACP,WAAO,IAAI;AACX,WAAO,IAAI;;AAGb,SAAO;AACT;AAEA,SAAS,cAAc,QAAc;AACnC,MAAI,WAAWA,WAAU,MAAM;AAC/B,MAAI,CAAC,SAAS,IAAI,QAAQ,GAAG;AAC3B,QAAM,SAAS,MAAM,QAAQ;MAC3B;MACA,8BAA8B;KACxB;AACR,QAAI,CAAC,UAAU,OAAO,SAAS,YAAY;AACzC,YAAM,IAAI,MAAM,+BAA+B;;AAEjD,aAAS,IACP,UAGA,SAAS,iBAAiB,MAAM,CAAC,CAAC;;AAGtC,SAAO,SAAS,IAAI,QAAQ;AAC9B;AAGM,SAAU,IACd,UAAoC;AACpC,MAAA,OAAA,CAAA;WAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAc;AAAd,SAAA,KAAA,CAAA,IAAA,UAAA,EAAA;;AAGA,MAAI,OAAO,aAAa,UAAU;AAChC,eAAW,CAAC,QAAQ;;AAGtB,MAAI,SAAS,SAAS,CAAC;AAEvB,OAAK,QAAQ,SAAC,KAAK,GAAC;AAClB,QAAI,OAAO,IAAI,SAAS,YAAY;AAClC,gBAAU,IAAI,IAAI,OAAO;WACpB;AACL,gBAAU;;AAEZ,cAAU,SAAS,IAAI,CAAC;EAC1B,CAAC;AAED,SAAO,cAAc,MAAM;AAC7B;AAEM,SAAU,cAAW;AACzB,WAAS,MAAK;AACd,oBAAkB,MAAK;AACzB;AAEM,SAAU,0BAAuB;AACrC,0BAAwB;AAC1B;AAEM,SAAU,sCAAmC;AACjD,kCAAgC;AAClC;AAEM,SAAU,uCAAoC;AAClD,kCAAgC;AAClC;AAEA,IAAM,SAAS;EACb;EACA;EACA;EACA;EACA;;CAGF,SAAiB,OAAG;AAEhB,QAAA,MAKE,OAAM,KAJR,MAAA,cAIE,OAAM,aAHR,MAAA,0BAGE,OAAM,yBAFR,MAAA,sCAEE,OAAM,qCADR,MAAA,uCACE,OAAM;AACZ,GARiB,QAAA,MAAG,CAAA,EAAA;AAUpB,IAAI,SAAO,IAAG;",
  "names": ["print", "_a", "from", "from", "_a", "_a", "fragment", "_a", "from", "d", "_a", "existing", "incoming", "from", "result", "dataId", "result", "context", "value", "selectionSet", "from", "map", "print", "_a", "NetworkStatus", "empty", "_a", "finalize", "info", "subscription", "operation", "_a", "cache", "DELETE", "result", "print", "variables", "observable", "_a", "data", "defaultOptions", "map", "result", "hasOwnProperty", "_a", "contentType", "_a", "print", "normalizedHeaders", "print", "options", "_a", "version", "normalize"]
}
