{
  "version": 3,
  "sources": ["../../@apollo/src/link/retry/delayFunction.ts", "../../@apollo/src/link/retry/retryFunction.ts", "../../@apollo/src/link/retry/retryLink.ts"],
  "sourcesContent": ["import type { RetryLink } from \"./retryLink.js\";\n\nexport function buildDelayFunction(\n  delayOptions?: RetryLink.DelayOptions\n): RetryLink.DelayFunction {\n  const { initial = 300, jitter = true, max = Infinity } = delayOptions || {};\n  // If we're jittering, baseDelay is half of the maximum delay for that\n  // attempt (and is, on average, the delay we will encounter).\n  // If we're not jittering, adjust baseDelay so that the first attempt\n  // lines up with initialDelay, for everyone's sanity.\n  const baseDelay = jitter ? initial : initial / 2;\n\n  return function delayFunction(count: number) {\n    let delay = Math.min(max, baseDelay * 2 ** count);\n    if (jitter) {\n      // We opt for a full jitter approach for a mostly uniform distribution,\n      // but bound it within initialDelay and delay for everyone's sanity.\n      delay = Math.random() * delay;\n    }\n\n    return delay;\n  };\n}\n", "import type { RetryLink } from \"./retryLink.js\";\n\nexport function buildRetryFunction(\n  retryOptions?: RetryLink.AttemptsOptions\n): RetryLink.AttemptsFunction {\n  const { retryIf, max = 5 } =\n    retryOptions || ({} as RetryLink.AttemptsOptions);\n  return function retryFunction(count, operation, error) {\n    if (count >= max) return false;\n    return retryIf ? retryIf(error, operation) : !!error;\n  };\n}\n", "import type { Subscription } from \"rxjs\";\nimport type { Observer } from \"rxjs\";\nimport { Observable } from \"rxjs\";\n\nimport type { ErrorLike } from \"@apollo/client\";\nimport {\n  graphQLResultHasProtocolErrors,\n  PROTOCOL_ERRORS_SYMBOL,\n  toErrorLike,\n} from \"@apollo/client/errors\";\nimport { ApolloLink } from \"@apollo/client/link\";\n\nimport { buildDelayFunction } from \"./delayFunction.js\";\nimport { buildRetryFunction } from \"./retryFunction.js\";\n\nexport declare namespace RetryLink {\n  namespace RetryLinkDocumentationTypes {\n    /**\n     * A function used to determine whether to retry the current operation.\n     *\n     * @param attempt - The current attempt number\n     * @param operation - The current `ApolloLink.Operation` for the request\n     * @param error - The error that triggered the retry attempt\n     * @returns A boolean to indicate whether to retry the current operation\n     */\n    function AttemptsFunction(\n      attempt: number,\n      operation: ApolloLink.Operation,\n      error: ErrorLike\n    ): boolean | Promise<boolean>;\n\n    /**\n     * A function used to determine the delay for a retry attempt.\n     *\n     * @param attempt - The current attempt number\n     * @param operation - The current `ApolloLink.Operation` for the request\n     * @param error - The error that triggered the retry attempt\n     * @returns The delay in milliseconds before attempting the request again\n     */\n    function DelayFunction(\n      attempt: number,\n      operation: ApolloLink.Operation,\n      error: ErrorLike\n    ): number;\n  }\n\n  /** {@inheritDoc @apollo/client/link/retry!RetryLink.RetryLinkDocumentationTypes.DelayFunction:function(1)} */\n  export type DelayFunction = (\n    attempt: number,\n    operation: ApolloLink.Operation,\n    error: ErrorLike\n  ) => number;\n\n  /**\n   * Configuration options for the standard retry delay strategy.\n   */\n  export interface DelayOptions {\n    /**\n     * The number of milliseconds to wait before attempting the first retry.\n     *\n     * Delays will increase exponentially for each attempt. E.g. if this is\n     * set to 100, subsequent retries will be delayed by 200, 400, 800, etc,\n     * until they reach the maximum delay.\n     *\n     * Note that if jittering is enabled, this is the average delay.\n     *\n     * @defaultValue `300`\n     */\n    initial?: number;\n\n    /**\n     * The maximum number of milliseconds that the link should wait for any\n     * retry.\n     *\n     * @defaultValue `Infinity`\n     */\n    max?: number;\n\n    /**\n     * Whether delays between attempts should be randomized.\n     *\n     * This helps avoid [thundering herd](https://en.wikipedia.org/wiki/Thundering_herd_problem)\n     * type situations by better distributing load during major outages. Without\n     * these strategies, when your server comes back up it will be hit by all\n     * of your clients at once, possibly causing it to go down again.\n     *\n     * @defaultValue `true`\n     */\n    jitter?: boolean;\n  }\n\n  /** {@inheritDoc @apollo/client/link/retry!RetryLink.RetryLinkDocumentationTypes.AttemptsFunction:function(1)} */\n  export type AttemptsFunction = (\n    attempt: number,\n    operation: ApolloLink.Operation,\n    error: ErrorLike\n  ) => boolean | Promise<boolean>;\n\n  /**\n   * Configuration options for the standard retry attempt strategy.\n   */\n  export interface AttemptsOptions {\n    /**\n     * The max number of times to try a single operation before giving up.\n     *\n     * Note that this INCLUDES the initial request as part of the count.\n     * E.g. `max` of 1 indicates no retrying should occur.\n     *\n     * Pass `Infinity` for infinite retries.\n     *\n     * @defaultValue `5`\n     */\n    max?: number;\n\n    /**\n     * Predicate function that determines whether a particular error should\n     * trigger a retry.\n     *\n     * For example, you may want to not retry 4xx class HTTP errors.\n     *\n     * @defaultValue `() => true`\n     */\n    retryIf?: (\n      error: ErrorLike,\n      operation: ApolloLink.Operation\n    ) => boolean | Promise<boolean>;\n  }\n\n  /**\n   * Options provided to the `RetryLink` constructor.\n   */\n  export interface Options {\n    /**\n     * Configuration for the delay strategy to use, or a custom delay strategy.\n     */\n    delay?: RetryLink.DelayOptions | RetryLink.DelayFunction;\n\n    /**\n     * Configuration for the retry strategy to use, or a custom retry strategy.\n     */\n    attempts?: RetryLink.AttemptsOptions | RetryLink.AttemptsFunction;\n  }\n}\n\nclass RetryableOperation {\n  private retryCount: number = 0;\n  private currentSubscription: Subscription | null = null;\n  private timerId: ReturnType<typeof setTimeout> | undefined;\n\n  constructor(\n    private observer: Observer<ApolloLink.Result>,\n    private operation: ApolloLink.Operation,\n    private forward: ApolloLink.ForwardFunction,\n    private delayFor: RetryLink.DelayFunction,\n    private retryIf: RetryLink.AttemptsFunction\n  ) {\n    this.try();\n  }\n\n  /**\n   * Stop retrying for the operation, and cancel any in-progress requests.\n   */\n  public cancel() {\n    if (this.currentSubscription) {\n      this.currentSubscription.unsubscribe();\n    }\n    clearTimeout(this.timerId);\n    this.timerId = undefined;\n    this.currentSubscription = null;\n  }\n\n  private try() {\n    this.currentSubscription = this.forward(this.operation).subscribe({\n      next: (result) => {\n        if (graphQLResultHasProtocolErrors(result)) {\n          this.onError(result.extensions[PROTOCOL_ERRORS_SYMBOL], () =>\n            // Pretend like we never encountered this error and move the result\n            // along for Apollo Client core to handle this error.\n            this.observer.next(result)\n          );\n          // Unsubscribe from the current subscription to prevent the `complete`\n          // handler to be called as a result of the stream closing.\n          this.currentSubscription?.unsubscribe();\n          return;\n        }\n\n        this.observer.next(result);\n      },\n      error: (error) => this.onError(error, () => this.observer.error(error)),\n      complete: this.observer.complete.bind(this.observer),\n    });\n  }\n\n  private onError = async (error: unknown, onContinue: () => void) => {\n    this.retryCount += 1;\n    const errorLike = toErrorLike(error);\n\n    const shouldRetry = await this.retryIf(\n      this.retryCount,\n      this.operation,\n      errorLike\n    );\n    if (shouldRetry) {\n      this.scheduleRetry(\n        this.delayFor(this.retryCount, this.operation, errorLike)\n      );\n      return;\n    }\n\n    onContinue();\n  };\n\n  private scheduleRetry(delay: number) {\n    if (this.timerId) {\n      throw new Error(`RetryLink BUG! Encountered overlapping retries`);\n    }\n\n    this.timerId = setTimeout(() => {\n      this.timerId = undefined;\n      this.try();\n    }, delay);\n  }\n}\n\n/**\n * `RetryLink` is a non-terminating link that attempts to retry operations that\n * fail due to network errors. It enables resilient GraphQL operations by\n * automatically retrying failed requests with configurable delay and retry\n * strategies.\n *\n * @remarks\n *\n * `RetryLink` is particularly useful for handling unreliable network conditions\n * where you would rather wait longer than explicitly fail an operation. It\n * provides exponential backoff and jitters delays between attempts by default.\n *\n * > [!NOTE]\n * > This link does not handle retries for GraphQL errors in the response. Use\n * > `ErrorLink` to retry an operation after a GraphQL error. For more\n * > information, see the [Error handling documentation](https://apollographql.com/docs/react/data/error-handling#on-graphql-errors).\n *\n * @example\n *\n * ```ts\n * import { RetryLink } from \"@apollo/client/link/retry\";\n *\n * const link = new RetryLink();\n * ```\n */\nexport class RetryLink extends ApolloLink {\n  private delayFor: RetryLink.DelayFunction;\n  private retryIf: RetryLink.AttemptsFunction;\n\n  constructor(options?: RetryLink.Options) {\n    super();\n    const { attempts, delay } = options || ({} as RetryLink.Options);\n    this.delayFor =\n      typeof delay === \"function\" ? delay : buildDelayFunction(delay);\n    this.retryIf =\n      typeof attempts === \"function\" ? attempts : buildRetryFunction(attempts);\n  }\n\n  public request(\n    operation: ApolloLink.Operation,\n    forward: ApolloLink.ForwardFunction\n  ): Observable<ApolloLink.Result> {\n    return new Observable((observer) => {\n      const retryable = new RetryableOperation(\n        observer,\n        operation,\n        forward,\n        this.delayFor,\n        this.retryIf\n      );\n      return () => {\n        retryable.cancel();\n      };\n    });\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;AAEM,SAAU,mBACd,cAAqC;AAErC,QAAM,EAAE,UAAU,KAAK,SAAS,MAAM,MAAM,SAAQ,IAAK,gBAAgB,CAAA;AAKzE,QAAM,YAAY,SAAS,UAAU,UAAU;AAE/C,SAAO,SAAS,cAAc,OAAa;AACzC,QAAI,QAAQ,KAAK,IAAI,KAAK,YAAY,KAAK,KAAK;AAChD,QAAI,QAAQ;AAGV,cAAQ,KAAK,OAAM,IAAK;IAC1B;AAEA,WAAO;EACT;AACF;;;ACpBM,SAAU,mBACd,cAAwC;AAExC,QAAM,EAAE,SAAS,MAAM,EAAC,IACtB,gBAAiB,CAAA;AACnB,SAAO,SAAS,cAAc,OAAO,WAAW,OAAK;AACnD,QAAI,SAAS;AAAK,aAAO;AACzB,WAAO,UAAU,QAAQ,OAAO,SAAS,IAAI,CAAC,CAAC;EACjD;AACF;;;ACqIA,IAAM,qBAAN,MAAwB;EAKtB,YACU,UACA,WACA,SACA,UACA,SAAmC;AAJnC;AACA;AACA;AACA;AACA;AATF,sCAAqB;AACrB,+CAA2C;AAC3C;AA8CA,mCAAU,OAAO,OAAgB,eAA0B;AACjE,WAAK,cAAc;AACnB,YAAM,YAAY,YAAY,KAAK;AAEnC,YAAM,cAAc,MAAM,KAAK,QAC7B,KAAK,YACL,KAAK,WACL,SAAS;AAEX,UAAI,aAAa;AACf,aAAK,cACH,KAAK,SAAS,KAAK,YAAY,KAAK,WAAW,SAAS,CAAC;AAE3D;MACF;AAEA,iBAAU;IACZ;AA5DU,SAAA,WAAA;AACA,SAAA,YAAA;AACA,SAAA,UAAA;AACA,SAAA,WAAA;AACA,SAAA,UAAA;AAER,SAAK,IAAG;EACV;;;;EAKO,SAAM;AACX,QAAI,KAAK,qBAAqB;AAC5B,WAAK,oBAAoB,YAAW;IACtC;AACA,iBAAa,KAAK,OAAO;AACzB,SAAK,UAAU;AACf,SAAK,sBAAsB;EAC7B;EAEQ,MAAG;AACT,SAAK,sBAAsB,KAAK,QAAQ,KAAK,SAAS,EAAE,UAAU;MAChE,MAAM,CAAC,WAAU;AA3KvB;AA4KQ,YAAI,+BAA+B,MAAM,GAAG;AAC1C,eAAK,QAAQ,OAAO,WAAW,sBAAsB,GAAG;;;YAGtD,KAAK,SAAS,KAAK,MAAM;WAAC;AAI5B,qBAAK,wBAAL,mBAA0B;AAC1B;QACF;AAEA,aAAK,SAAS,KAAK,MAAM;MAC3B;MACA,OAAO,CAAC,UAAU,KAAK,QAAQ,OAAO,MAAM,KAAK,SAAS,MAAM,KAAK,CAAC;MACtE,UAAU,KAAK,SAAS,SAAS,KAAK,KAAK,QAAQ;KACpD;EACH;EAqBQ,cAAc,OAAa;AACjC,QAAI,KAAK,SAAS;AAChB,YAAM,IAAI,MAAM,gDAAgD;IAClE;AAEA,SAAK,UAAU,WAAW,MAAK;AAC7B,WAAK,UAAU;AACf,WAAK,IAAG;IACV,GAAG,KAAK;EACV;;AA4BI,IAAO,YAAP,cAAyB,WAAU;EAIvC,YAAY,SAA2B;AACrC,UAAK;AAJC;AACA;AAIN,UAAM,EAAE,UAAU,MAAK,IAAK,WAAY,CAAA;AACxC,SAAK,WACH,OAAO,UAAU,aAAa,QAAQ,mBAAmB,KAAK;AAChE,SAAK,UACH,OAAO,aAAa,aAAa,WAAW,mBAAmB,QAAQ;EAC3E;EAEO,QACL,WACA,SAAmC;AAEnC,WAAO,IAAI,WAAW,CAAC,aAAY;AACjC,YAAM,YAAY,IAAI,mBACpB,UACA,WACA,SACA,KAAK,UACL,KAAK,OAAO;AAEd,aAAO,MAAK;AACV,kBAAU,OAAM;MAClB;IACF,CAAC;EACH;;",
  "names": []
}
