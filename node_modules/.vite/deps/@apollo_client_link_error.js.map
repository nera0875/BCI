{
  "version": 3,
  "sources": ["../../@apollo/src/link/error/index.ts"],
  "sourcesContent": ["import type { Subscription } from \"rxjs\";\nimport { Observable } from \"rxjs\";\n\nimport type { ErrorLike } from \"@apollo/client\";\nimport {\n  CombinedGraphQLErrors,\n  graphQLResultHasProtocolErrors,\n  PROTOCOL_ERRORS_SYMBOL,\n  toErrorLike,\n} from \"@apollo/client/errors\";\nimport { ApolloLink } from \"@apollo/client/link\";\n\nexport declare namespace ErrorLink {\n  // Using a different namespace name to avoid clash with\n  // `ApolloLink.DocumentationTypes`\n  export namespace ErrorLinkDocumentationTypes {\n    /**\n     * Callback that is called by `ErrorLink` when an error occurs from a\n     * downstream link in link chain.\n     *\n     * @param options - The options object provided by `ErrorLink` to the error\n     * handler when an error occurs.\n     */\n    export function ErrorHandler(\n      options: ErrorHandlerOptions\n    ): Observable<ApolloLink.Result> | void;\n  }\n\n  /** {@inheritDoc @apollo/client/link/error!ErrorLink.ErrorLinkDocumentationTypes.ErrorHandler:function(1)} */\n  export interface ErrorHandler {\n    (options: ErrorHandlerOptions): Observable<ApolloLink.Result> | void;\n  }\n\n  /**\n   * The object provided to the `ErrorHandler` callback function.\n   */\n  export interface ErrorHandlerOptions {\n    /**\n     * The error that occurred during the operation execution. This can be a\n     * `CombinedGraphQLErrors` instance (for GraphQL errors) or another error\n     * type (for network errors).\n     *\n     * Use `CombinedGraphQLErrors.is(error)` to check if it's a GraphQL error with an `errors` array.\n     */\n    error: ErrorLike;\n    /**\n     * The raw GraphQL result from the server (if available), which may include\n     * partial data alongside errors.\n     */\n    result?: ApolloLink.Result;\n\n    /** The details of the GraphQL operation that produced an error. */\n    operation: ApolloLink.Operation;\n\n    /**\n     * A function that calls the next link in the link chain. Calling\n     * `return forward(operation)` in your `ErrorLink` callback\n     * [retries the operation](../../data/error-handling#retrying-operations), returning a new observable for the\n     * upstream link to subscribe to.\n     */\n    forward: ApolloLink.ForwardFunction;\n  }\n}\n\n/**\n * @deprecated\n * Use `ErrorLink` from `@apollo/client/link/error` instead.\n */\nexport function onError(errorHandler: ErrorLink.ErrorHandler) {\n  return new ErrorLink(errorHandler);\n}\n\n/**\n * Use the `ErrorLink` to perform custom logic when a [GraphQL or network error](https://apollographql.com/docs/react/data/error-handling)\n * occurs.\n *\n * @remarks\n *\n * This link is used after the GraphQL operation completes and execution is\n * moving back up your [link chain](https://apollographql.com/docs/react/introduction#handling-a-response). The `errorHandler` function should\n * not return a value unless you want to [retry the operation](https://apollographql.com/docs/react/data/error-handling#retrying-operations).\n *\n * For more information on the types of errors that might be encountered, see\n * the guide on [error handling](https://apollographql.com/docs/react/data/error-handling).\n *\n * @example\n *\n * ```ts\n * import { ErrorLink } from \"@apollo/client/link/error\";\n * import {\n *   CombinedGraphQLErrors,\n *   CombinedProtocolErrors,\n * } from \"@apollo/client/errors\";\n *\n * // Log any GraphQL errors, protocol errors, or network error that occurred\n * const errorLink = new ErrorLink(({ error, operation }) => {\n *   if (CombinedGraphQLErrors.is(error)) {\n *     error.errors.forEach(({ message, locations, path }) =>\n *       console.log(\n *         `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`\n *       )\n *     );\n *   } else if (CombinedProtocolErrors.is(error)) {\n *     error.errors.forEach(({ message, extensions }) =>\n *       console.log(\n *         `[Protocol error]: Message: ${message}, Extensions: ${JSON.stringify(\n *           extensions\n *         )}`\n *       )\n *     );\n *   } else {\n *     console.error(`[Network error]: ${error}`);\n *   }\n * });\n * ```\n */\nexport class ErrorLink extends ApolloLink {\n  constructor(errorHandler: ErrorLink.ErrorHandler) {\n    super((operation, forward) => {\n      return new Observable((observer) => {\n        let sub: Subscription | undefined;\n        let retriedSub: Subscription | undefined;\n        let retriedResult: ReturnType<ErrorLink.ErrorHandler>;\n\n        try {\n          sub = forward(operation).subscribe({\n            next: (result) => {\n              const handler =\n                operation.client[\"queryManager\"].incrementalHandler;\n              const errors =\n                handler.isIncrementalResult(result) ?\n                  handler.extractErrors(result)\n                : result.errors;\n              if (errors) {\n                retriedResult = errorHandler({\n                  error: new CombinedGraphQLErrors(result, errors),\n                  result,\n                  operation,\n                  forward,\n                });\n              } else if (graphQLResultHasProtocolErrors(result)) {\n                retriedResult = errorHandler({\n                  error: result.extensions[PROTOCOL_ERRORS_SYMBOL],\n                  result,\n                  operation,\n                  forward,\n                });\n              }\n\n              retriedSub = retriedResult?.subscribe(observer);\n\n              if (!retriedSub) {\n                observer.next(result);\n              }\n            },\n            error: (error) => {\n              retriedResult = errorHandler({\n                operation,\n                error: toErrorLike(error),\n                forward,\n              });\n              retriedSub = retriedResult?.subscribe(observer);\n\n              if (!retriedSub) {\n                observer.error(error);\n              }\n            },\n            complete: () => {\n              // disable the previous sub from calling complete on observable\n              // if retry is in flight.\n              if (!retriedResult) {\n                observer.complete();\n              }\n            },\n          });\n        } catch (e) {\n          errorHandler({ error: toErrorLike(e), operation, forward });\n          observer.error(e);\n        }\n\n        return () => {\n          if (sub) sub.unsubscribe();\n          if (retriedSub) retriedSub.unsubscribe();\n        };\n      });\n    });\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;AAoEM,SAAU,QAAQ,cAAoC;AAC1D,SAAO,IAAI,UAAU,YAAY;AACnC;AA8CM,IAAO,YAAP,cAAyB,WAAU;EACvC,YAAY,cAAoC;AAC9C,UAAM,CAAC,WAAW,YAAW;AAC3B,aAAO,IAAI,WAAW,CAAC,aAAY;AACjC,YAAI;AACJ,YAAI;AACJ,YAAI;AAEJ,YAAI;AACF,gBAAM,QAAQ,SAAS,EAAE,UAAU;YACjC,MAAM,CAAC,WAAU;AACf,oBAAM,UACJ,UAAU,OAAO,cAAc,EAAE;AACnC,oBAAM,SACJ,QAAQ,oBAAoB,MAAM,IAChC,QAAQ,cAAc,MAAM,IAC5B,OAAO;AACX,kBAAI,QAAQ;AACV,gCAAgB,aAAa;kBAC3B,OAAO,IAAI,sBAAsB,QAAQ,MAAM;kBAC/C;kBACA;kBACA;iBACD;cACH,WAAW,+BAA+B,MAAM,GAAG;AACjD,gCAAgB,aAAa;kBAC3B,OAAO,OAAO,WAAW,sBAAsB;kBAC/C;kBACA;kBACA;iBACD;cACH;AAEA,2BAAa,+CAAe,UAAU;AAEtC,kBAAI,CAAC,YAAY;AACf,yBAAS,KAAK,MAAM;cACtB;YACF;YACA,OAAO,CAAC,UAAS;AACf,8BAAgB,aAAa;gBAC3B;gBACA,OAAO,YAAY,KAAK;gBACxB;eACD;AACD,2BAAa,+CAAe,UAAU;AAEtC,kBAAI,CAAC,YAAY;AACf,yBAAS,MAAM,KAAK;cACtB;YACF;YACA,UAAU,MAAK;AAGb,kBAAI,CAAC,eAAe;AAClB,yBAAS,SAAQ;cACnB;YACF;WACD;QACH,SAAS,GAAG;AACV,uBAAa,EAAE,OAAO,YAAY,CAAC,GAAG,WAAW,QAAO,CAAE;AAC1D,mBAAS,MAAM,CAAC;QAClB;AAEA,eAAO,MAAK;AACV,cAAI;AAAK,gBAAI,YAAW;AACxB,cAAI;AAAY,uBAAW,YAAW;QACxC;MACF,CAAC;IACH,CAAC;EACH;;",
  "names": []
}
